<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AiRomance</title>
  <icon>https://blog.whff521.xyz/images/101.ico</icon>
  <subtitle>爱裸漫三三</subtitle>
  <link href="https://blog.whff521.xyz/atom.xml" rel="self"/>
  <link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
  <link href="https://blog.whff521.xyz/"/>
  <updated>2024-12-25T02:54:30.038Z</updated>
  <id>https://blog.whff521.xyz/</id>
  
  <author>
    <name>AiRomance</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>考研回忆</title>
    <link href="https://blog.whff521.xyz/2024/12/25/%E8%80%83%E7%A0%94%E5%9B%9E%E5%BF%86/"/>
    <id>https://blog.whff521.xyz/2024/12/25/%E8%80%83%E7%A0%94%E5%9B%9E%E5%BF%86/</id>
    <published>2024-12-25T02:02:57.000Z</published>
    <updated>2024-12-25T02:54:30.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="考研回忆"><a href="#考研回忆" class="headerlink" title="考研回忆"></a>考研回忆</h1><h2 id="最近几天"><a href="#最近几天" class="headerlink" title="最近几天"></a>最近几天</h2><p>说说考试吧，政治肖四复习的时候也没有安排时间背诵答题，只是简单的看了几天。没想到政治题今年出的很难，而且肖四也是没压到题，这么看来我的时间安排还算合理。为了增强我自己内心的激情和逻辑思维能力，每天都在看《觉醒年代》，这个电视剧拍的是真的好，不过在此就不多讲了。</p><p>英一破天荒的大作文出了只有图表的。要知道过去十几年都是漫画类型的，只有去年出了漫画加图表，今年就只出了图表。我也只能硬着头皮把我背的漫画作文的句式硬套进去。翻译做的很烂呜呜呜。</p><p>数一更是一塌糊涂，除了选择题能拿一点点分数外，大题基本没有会的。三重积分考了绕直线旋转的，之前真题应该没考过吧，虽然在大纲里要求过，但是着实是没有去重点复习。如果说这科能够够国家线的话，没准还真能进复试了，只能说等成绩出来吧。我自己知道自己做的怎么样，所以我感觉希望渺茫。</p><p>专业课数据结构与算法，对于一个常年在oi浑水摸鱼的人来说简直就是如鱼得水。题目非常简单。拿到试卷的时候简单翻看了一下最后面的DP，求相邻颜色不重复的涂颜色最小代价的问题。坐在考场上，尽管那天是阴天，我宛如在夕阳下坐在门口的老太太，手里不紧不慢地择棉花，忍不住轻哼起来。</p><p>还有一件值得记录的事情。就是在考研前一晚的旅店的床上，我和一起考研的同学手机聊天说如果中午有人给我买饭就好了，那我就不用去挤食堂了。然后我突然想到我真有一位不考研的好朋友，如果他要是来了岂不美哉。当机立断地和他谈话，然后给他买了机票让他赶紧飞过来。他也是被我的想法吓到了，不过最终还是来了。不过飞机是考研第一天下午到的，所以他也就是给我买了第二天的午饭而已。其实饭不饭的不重要，有好朋友陪着就是天大的好事。这是给他买的机票截图：</p><p><img src="https://images.whff521.top/IMG_6368.jpg" alt="ticket"></p><p>之后就是考完了然后陪他在合肥玩了两天，周一上午的合肥动物园没几个游客，跟包场了一样。</p><p>回到宿舍之后第一件事就是把所有考研相关的书都扔了，书桌清静了一大片。下面是扔之前纪念的照片，数据结构和一些数学的书在旅馆的时候就扔了。</p><p><img src="https://images.whff521.top/IMG_6395.JPG" alt="books"></p><h2 id="复习之旅"><a href="#复习之旅" class="headerlink" title="复习之旅"></a>复习之旅</h2><p>回想起2023年十月份好像是，一起和我参加CCSP的学长和我说考研要趁早准备，数学应该今年12月份就开始复习了。如今想起来他的话说的非常正确，可惜我并没有去执行。直到来年的3，4月我才系统的开始复习数学。但是那个时候正是同学们找工作的黄金时期，我也是跟着他们做了简历投递各家公司，所以耽误了很长一段时间。</p><p>不知不觉暑假都到了，我依然没有进入到复习考研的状态，每天就是看看网课，做做数据结构的题。直到暑假快结束了，我同学给我发了一个帕拉迪宇的b站视频。我才大梦初醒。那个视频已经不记得讲了什么了，不过确实是给我骂醒了。我意识到我不能在混混僵僵混日子了，也是在这时去买了好几本练习册，去进入到刷题的状态。由于开始时间很晚，没过几天就是九月份开学了。</p><p>好在软件工程专业大四应该是实习的时间，所以什么课都没有了，我也能天天跑去图书馆学习。我基本时间安排是上午数学，下午英语和数据结构。十一月开了政治，开始用小程序做题，时间安排在晚上。早上九点学到中午十一点半就去吃饭，下午两点半学到五点半，晚饭过后学到晚上八点。回到宿舍后八点半出去操场区域去跳绳，强身健体。每周日休息一天（专心打游戏一天）。</p><p>由于进入复习状态的时间节点太晚，而且是半路转换目标从数二换成数一，着实是复习不完，最后仅仅是完成了全部知识点的学习，做的题目还是太少了。而且在考场上尽管我背会了傅里叶级数系数的公式，但是还是没有算出来最终求和的答案，归根结底还是不会做题。</p><h2 id="往后"><a href="#往后" class="headerlink" title="往后"></a>往后</h2><p>现在终于专心致志玩电脑了，先把大部分精力放在毕业设计上，学日语的进程也不能放下。走一步是一步了，要准备好进入职场，走向社会了。</p>]]></content>
    
    
    <summary type="html">总之非常痛苦的复习之旅终于结束了，也算是大战以后终于解放了。12月份真的是眨眼之间就过去了，经验++。</summary>
    
    
    
    <category term="杂谈" scheme="https://blog.whff521.xyz/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="https://blog.whff521.xyz/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="考研" scheme="https://blog.whff521.xyz/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>关于自主学习</title>
    <link href="https://blog.whff521.xyz/2024/12/19/%E5%85%B3%E4%BA%8E%E8%87%AA%E4%B8%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>https://blog.whff521.xyz/2024/12/19/%E5%85%B3%E4%BA%8E%E8%87%AA%E4%B8%BB%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-12-19T10:30:32.000Z</published>
    <updated>2024-12-19T10:32:33.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于自主学习"><a href="#关于自主学习" class="headerlink" title="关于自主学习"></a>关于自主学习</h1><p>最近也是因为在考研，休闲时间会看《觉醒年代》，今天看到一个英语作文在讲激励式教育。</p><p>激励式教育并不可取，因为如果激励消失后，孩子很难再有动力去学习。</p><p>学习究竟是为了什么，这个问题着实需要自己认真思考一下。</p><p>小学到大学的学习可能都只是仅仅想要升学到更好的学校。所以只需要按部就班的学习，做对试卷上的题目就能一天天混日子。从来没有想过学习本身到底是什么。学习本身绝不仅仅是背许多课文，学许多英语单词，考很高的分数。</p><p>为什么要学习？直到高考后选择专业时可能才是某些人第一次问自己想要干什么的时间。自己的理想和梦想的设立，决定和影响着我们人生未来的发展。但是长达九年的义务教育，是否给自己树立了正确的人生观价值观世界观呢？我自己当然是想成为一名程序员，因为电脑工作者很酷，很帅，能够解决很多有趣的问题，实现很多便利的功能。</p><p>那么实现自己的梦想就是需要学习。到了大学之后就不全是老师带着学生死磕课本的学习模式了，自主学习会逐渐成为大学生学习的常态。你想要成为前端工程师，那就去自学html，js，css，vue，react等，想要当后端工程师就要努力钻研spring boot，java，radis等。</p><p>但实际上这种自主学习的目的也并不单纯。比如想要成为程序员是因为薪资高，那么努力学习的目的可能就转变成了为了以后的薪资。那么和激励式教育又有何不同呢？不过是一个是父母给你东西一个是老板给你钱罢了。</p><p>《觉醒年代》中第一次世界大战结束后，一句话传遍中国，那就是“真理战胜强权”。我觉得，追求真理的学习才是真正的自主学习。这是一种纯粹的，学术上的以及实践上的，科学地认识事物发展规律的过程。求知的欲望从物质的满足转化为精神上的满足。何为真理？真理即是正确的，满足事物发展规律的理论，能够服务于大众，服务于社会的。真理可以根据实际情况而拓展和延伸，应用于万事万物。</p><p>那我们之前的学习还是否有意义？我不管什么真理，假理，我学习就是为了钱，为了自己未来的生活，这行不行？这当然行，大行特行。如果否认了这种学习，就是否认了真理。人们常说失败乃成功之母，真理的发现和归纳也是从无数次失败的实践中得来的。只要是前进性的学习，就不能停歇。巨人的肩膀从来不是一个人的肩膀，而是千千万万的民众用千千万万的实践搭建出来的。</p><p>举个例子，如果一开始的学习是为了一份好工作，那么在学习的过程中你会对这份“好工作”有很多新的认识。哦，原来是这样解决问题的；哦，原来还可以这样用吗。学了很长一段时间之后，你可能觉得自己已经很好的掌握了这种知识，也能够胜任这份“好工作了”。很大概率你确实可以获得这份工作，那之后呢？你想过没有，学习的这个过程远远没有停止。在工作上你会遇到各种各样的问题，往往还是书本上，网络上没有教给你的问题。起初你可能会花费很长时间去解决奇怪的问题，但是随着时间的推移你会越来越熟练，这是因为什么？这正是我讲的“真理”在起作用。在实践中你越来越接近“真理”，所以你越来越懂得用“真理”解决问题。所以你解决问题的速度越来越快，因为这些问题都是同一类“真理”的衍生问题。</p><p>但是还有一类问题是无法解决的。就是框架的物理限制。对于程序员来说，运用的所有功能往往取决于框架提供了什么功能。如果框架没有提供这个功能，而问题的解决需要这个功能，最好的解决办法就是你去实现这个功能。通常来讲这就是开源项目成员比较多的提供贡献的理由。功能的实现肯定不是凭空想象，或许是借鉴于其他框架，或许是借鉴于生活。从用轮子到造轮子的这一过程，离不开自主学习。</p><p>目的仅仅是追求真理吗？追求到真理之后还有学会宣传真理。造了轮子没人用，那意义就微乎其微了。但是究竟该怎么宣传我尚不得知，也正是我以后学习应该注意到的点吧。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;关于自主学习&quot;&gt;&lt;a href=&quot;#关于自主学习&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="杂谈" scheme="https://blog.whff521.xyz/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="https://blog.whff521.xyz/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>第36次CCF CSP计算机软件能力认证记录</title>
    <link href="https://blog.whff521.xyz/2024/12/14/%E7%AC%AC36%E6%AC%A1CCF-CSP%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E8%AE%B0%E5%BD%95/"/>
    <id>https://blog.whff521.xyz/2024/12/14/%E7%AC%AC36%E6%AC%A1CCF-CSP%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E8%AE%B0%E5%BD%95/</id>
    <published>2024-12-14T03:45:40.000Z</published>
    <updated>2024-12-14T07:20:26.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第36次CCF-CSP计算机软件能力认证记录"><a href="#第36次CCF-CSP计算机软件能力认证记录" class="headerlink" title="第36次CCF CSP计算机软件能力认证记录"></a>第36次CCF CSP计算机软件能力认证记录</h1><p>本次应该是我最后一次参加CSP了，明年就毕业了。遗憾的是这次也仅仅只是拿了300分。需要走的路还很远很远。</p><p><img src="https://images.whff521.top/csp300.png" alt="csp300"></p><p>今天去官网看见能把代码下载下来了，就记录一下。</p><p>然而这并不是完整的题解，只是我自身心路历程的记录。如果想看完整的题解的话我推荐<a href="https://www.cnblogs.com/luckyblock/p/18596275">这篇博客</a></p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>简单模拟签到题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">types</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;f&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(c==<span class="string">&#x27;b&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(c==<span class="string">&#x27;l&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">if</span>(c==<span class="string">&#x27;r&#x27;</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">walk</span><span class="params">(<span class="type">int</span> startx,<span class="type">int</span> starty,string s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> tempx = startx+dx[<span class="built_in">types</span>(s[i])];</span><br><span class="line">        <span class="type">int</span> tempy = starty+dy[<span class="built_in">types</span>(s[i])];</span><br><span class="line">        <span class="keyword">if</span>(tempx&lt;=<span class="number">0</span>||tempx&gt;n||tempy&lt;=<span class="number">0</span>||tempy&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">        startx = tempx;</span><br><span class="line">        starty = tempy;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;startx&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;starty&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;temp;</span><br><span class="line">        <span class="built_in">walk</span>(x,y,temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>没有想出来正解，暴力算出来每个位置b变成0时需要的最少w。看别人的做法应该是用求和公式写不等式然后用前缀和做。出题人的仁慈，暴力有80分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[mxlen],b[mxlen];</span><br><span class="line"><span class="type">int</span> needE[mxlen];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> originE = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i!=x) temp+=b[i];</span><br><span class="line">       temp-=a[i];</span><br><span class="line">        <span class="keyword">if</span>(temp&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            originE+=-temp;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> originE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">work</span>(i)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>模拟Cache，（学过计组的有福了）。但是最后应该是因为直接用二维数组暴力维护最近使用的内存所以TLE了一个点，只拿了90分。赛后想起来如果用deque声明数组做把排序操作时间复杂度降下来应该就能过了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> n,N;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">bool</span> changed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node v[mxlen][mxlen];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            v[i][j].id=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wirte</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;id&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;id&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findInCache</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=(id/n)%N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i][j].id==<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(v[i][j].id==id) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadCache</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i=(id/n)%N;</span><br><span class="line">    node qw;</span><br><span class="line">    qw.id = id;qw.changed=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i][j].id==<span class="number">-1</span>)&#123;</span><br><span class="line">            v[i][j].id=qw.id;</span><br><span class="line">            v[i][j].changed = qw.changed;</span><br><span class="line">            ok=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok) &#123;<span class="built_in">read</span>(id);;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(v[i][n<span class="number">-1</span>].changed) <span class="built_in">wirte</span>(v[i][n<span class="number">-1</span>].id);</span><br><span class="line">    v[i][n<span class="number">-1</span>].id = qw.id;</span><br><span class="line">    v[i][n<span class="number">-1</span>].changed = qw.changed;</span><br><span class="line">    <span class="built_in">read</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wirteCache</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=(id/n)%N;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i][j].id==id)&#123;</span><br><span class="line">            pos = j;</span><br><span class="line">            v[i][j].changed = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node temp;</span><br><span class="line">    temp.id = v[i][pos].id;</span><br><span class="line">    temp.changed = v[i][pos].changed;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=pos;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">        v[i][j].id = v[i][j<span class="number">-1</span>].id;</span><br><span class="line">        v[i][j].changed = v[i][j<span class="number">-1</span>].changed;</span><br><span class="line">    &#125;</span><br><span class="line">    v[i][<span class="number">0</span>].id = temp.id;</span><br><span class="line">    v[i][<span class="number">0</span>].changed = temp.changed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readInCache</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=(id/n)%N;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i][j].id==id)&#123;</span><br><span class="line">            pos = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node temp;</span><br><span class="line">    temp.id = v[i][pos].id;</span><br><span class="line">    temp.changed = v[i][pos].changed;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=pos;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">        v[i][j].id = v[i][j<span class="number">-1</span>].id;</span><br><span class="line">        v[i][j].changed = v[i][j<span class="number">-1</span>].changed;</span><br><span class="line">    &#125;</span><br><span class="line">    v[i][<span class="number">0</span>].id = temp.id;</span><br><span class="line">    v[i][<span class="number">0</span>].changed = temp.changed;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> type,a;</span><br><span class="line">        cin&gt;&gt;type&gt;&gt;a;</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">findInCache</span>(a))&#123;</span><br><span class="line">                <span class="built_in">readInCache</span>(a);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">loadCache</span>(a);</span><br><span class="line">                <span class="built_in">readInCache</span>(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">findInCache</span>(a))&#123;</span><br><span class="line">                <span class="built_in">wirteCache</span>(a);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">loadCache</span>(a);</span><br><span class="line">                <span class="built_in">wirteCache</span>(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;N;</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p>这道题更是没有思路。正解应该是DP。赛场上只想到了把所有能到的点用边长为1的边连接，然后dijkstra求最短路，只拿了30分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[mxlen],k[mxlen];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    ll v,w,next;</span><br><span class="line">&#125;G[mxlen];</span><br><span class="line">ll head[mxlen],cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll u,ll v,ll w)</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    G[cnt].w=w;</span><br><span class="line">    G[cnt].v=v;</span><br><span class="line">    G[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    ll d,u;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node&amp; t)<span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d&gt;t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int pre[mxlen],last[mxlen],other[mxlen],len[mxlen],l;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void add(int x,int y,int z)&#123;</span></span><br><span class="line"><span class="comment">//     l++;</span></span><br><span class="line"><span class="comment">//     pre[l] = last[x];</span></span><br><span class="line"><span class="comment">//     last[x] = l;</span></span><br><span class="line"><span class="comment">//     other[l] = y;</span></span><br><span class="line"><span class="comment">//     len[l] = z;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">ll dis[mxlen];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>((node)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node temp = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        ll u =temp.u;</span><br><span class="line">        ll d = temp.d;</span><br><span class="line">        <span class="keyword">if</span>(d!=dis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].next)&#123;</span><br><span class="line">            ll v=G[i].v,w=G[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[u]+w&lt;dis[v])&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                q.<span class="built_in">push</span>((node)&#123;dis[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n]==dis[<span class="number">0</span>]) <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dis[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(n,i+k[i]);j++)&#123;</span><br><span class="line">                <span class="built_in">add</span>(i,j-a[j],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后时间不够了，也没有时间去分析最后一题了，看了一眼根本没看懂呜呜呜。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;第36次CCF-CSP计算机软件能力认证记录&quot;&gt;&lt;a href=&quot;#第36次CCF-CSP计算机软件能力认证记录&quot; class=&quot;headerlink&quot; title=&quot;第36次CCF CSP计算机软件能力认证记录&quot;&gt;&lt;/a&gt;第36次CCF</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://blog.whff521.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="csp" scheme="https://blog.whff521.xyz/tags/csp/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计day0</title>
    <link href="https://blog.whff521.xyz/2024/11/19/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1day0/"/>
    <id>https://blog.whff521.xyz/2024/11/19/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1day0/</id>
    <published>2024-11-19T02:44:09.000Z</published>
    <updated>2024-11-19T09:21:10.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>此为记录毕业设计中代码实现功能记录的系列。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>目前只是创建了项目初始文件和git仓库，由于尚未完成，所以github仓库暂为私有不公开状态。</p><h3 id="后端-SpringBoot"><a href="#后端-SpringBoot" class="headerlink" title="后端 SpringBoot"></a>后端 SpringBoot</h3><p>创建项目截图如下：</p><p><img src="https://images.whff521.top/Screenshot%202024-11-19%20at%2010.58.59.png" alt="springboot1"></p><p><img src="https://images.whff521.top/Screenshot%202024-11-19%20at%2011.00.43.png" alt="springboot2"></p><p>Maven仓库，java17，jar包，Spring Boot 3.3.5，预装插件为 MySQL Driver，Lombok，Spring Web</p><h3 id="前端-Android"><a href="#前端-Android" class="headerlink" title="前端 Android"></a>前端 Android</h3><p>创建截图如下：</p><p><img src="https://images.whff521.top/Screenshot%202024-11-17%20at%2018.56.37.png" alt="android"></p><p>java编写， Minimum SDK：API24(Android 7.0),Groovy DSL 构建。</p><p>因为感觉好玩，初始选了Android Studio给的Navigation Drawer Views Activity，现在用这种布局的软件比较少，打算做一个和小红书差不多的。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Day-0&quot;&gt;&lt;a href=&quot;#Day-0&quot; class=&quot;headerlink&quot; title=&quot;Day 0&quot;&gt;&lt;/a&gt;Day 0&lt;/h1&gt;&lt;p&gt;此为记录毕业设计中代码实现功能记录的系列。&lt;/p&gt;
&lt;h2 id=&quot;创建项目&quot;&gt;&lt;a href=&quot;#创建项目&quot;</summary>
        
      
    
    
    
    <category term="毕业设计" scheme="https://blog.whff521.xyz/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="毕业设计" scheme="https://blog.whff521.xyz/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://blog.whff521.xyz/2024/10/31/%E6%8E%92%E5%BA%8F/"/>
    <id>https://blog.whff521.xyz/2024/10/31/%E6%8E%92%E5%BA%8F/</id>
    <published>2024-10-31T01:38:09.000Z</published>
    <updated>2024-11-14T09:32:00.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>在数据结构中，<strong>排序</strong>（Sorting）指的是将一个数据集合中的元素按指定顺序重新排列的过程。排序是计算机科学的基本操作之一，对数据处理和分析具有重要作用。排序的结果通常是按从小到大（升序）或从大到小（降序）排列的有序序列。</p><h2 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h2><ol><li><p><strong>内部排序和外部排序</strong>：</p><ul><li><strong>内部排序</strong>：数据量较小，能够将所有待排序的记录一次性加载到内存中完成排序。</li><li><strong>外部排序</strong>：数据量较大，无法一次加载到内存中，需要借助外存（如硬盘）分批次处理并排序。</li></ul></li><li><p><strong>稳定性</strong>：</p><ul><li><strong>稳定排序</strong>：若两个相等的元素在排序前后的相对位置不变，则排序算法是稳定的。例如，若记录有相同的键值，稳定排序会保持它们的初始顺序。</li><li><strong>不稳定排序</strong>：可能会改变相等元素的相对位置。</li></ul></li><li><p><strong>时间复杂度</strong>：排序算法的时间复杂度通常以 $O(n^2)$ 或 $O(n \log n)$ 为主，决定了其在不同规模数据上的效率。</p></li><li><p><strong>空间复杂度</strong>：算法在排序过程中额外占用的存储空间。部分排序算法只需少量辅助空间（如原地排序），而有些则需要较多的辅助空间。</p></li><li><p><strong>排序算法的适用场景</strong>：根据数据量、数据特性（如是否近似有序）以及稳定性要求，选择合适的排序算法。</p></li></ol><h2 id="常见的排序算法及其特性"><a href="#常见的排序算法及其特性" class="headerlink" title="常见的排序算法及其特性"></a>常见的排序算法及其特性</h2><h3 id="1-冒泡排序（Bubble-Sort）："><a href="#1-冒泡排序（Bubble-Sort）：" class="headerlink" title="1. 冒泡排序（Bubble Sort）："></a>1. <strong>冒泡排序（Bubble Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：通过重复遍历待排序的序列，依次比较相邻元素，将较大或较小的元素向后交换。</li><li><strong>时间复杂度</strong>：$O(n^2)$</li><li><strong>特点</strong>：简单但效率低，适用于数据量小的情况。</li><li><strong>稳定性</strong>：稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">bool</span> swapped = <span class="literal">false</span>; <span class="comment">// 用于检测是否发生交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 arr[j] 和 arr[j + 1]</span></span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果在一轮遍历中没有发生交换，说明数组已排序</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bubbleSort</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-选择排序（Selection-Sort）："><a href="#2-选择排序（Selection-Sort）：" class="headerlink" title="2. 选择排序（Selection Sort）："></a>2. <strong>选择排序（Selection Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：每次从未排序部分选择最小（或最大）元素，放在已排序部分的末尾。</li><li><strong>时间复杂度</strong>：$O(n^2)$</li><li><strong>特点</strong>：减少了交换次数，但依然不适合大型数据。</li><li><strong>稳定性</strong>：不稳定</li></ul><h3 id="3-插入排序（Insertion-Sort）："><a href="#3-插入排序（Insertion-Sort）：" class="headerlink" title="3. 插入排序（Insertion Sort）："></a>3. <strong>插入排序（Insertion Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：将待排序数据分成已排序和未排序两部分，逐个将未排序元素插入已排序部分的正确位置。</li><li><strong>时间复杂度</strong>：$O(n^2)$</li><li><strong>特点</strong>：适用于小规模或近乎有序的序列。</li><li><strong>稳定性</strong>：稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> key = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前元素插入到已排序部分</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">insertionSort</span>(arr, n);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-归并排序（Merge-Sort）："><a href="#4-归并排序（Merge-Sort）：" class="headerlink" title="4. 归并排序（Merge Sort）："></a>4. <strong>归并排序（Merge Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：采用分治法，将数据分成子序列分别排序，再将有序子序列合并为完整序列。</li><li><strong>时间复杂度</strong>：$O(n \log n)$</li><li><strong>特点</strong>：效率高，适用于大型数据集，但需要额外存储空间。</li><li><strong>稳定性</strong>：稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = right - mid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时数组</span></span><br><span class="line">    <span class="type">int</span>* leftArr = <span class="keyword">new</span> <span class="type">int</span>[n1];</span><br><span class="line">    <span class="type">int</span>* rightArr = <span class="keyword">new</span> <span class="type">int</span>[n2];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝数据到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">        leftArr[i] = arr[left + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n2; j++)</span><br><span class="line">        rightArr[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并临时数组到原数组</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArr[i] &lt;= rightArr[j]) &#123;</span><br><span class="line">            arr[k] = leftArr[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = rightArr[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝剩余元素（如果有）</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = leftArr[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = rightArr[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放临时数组</span></span><br><span class="line">    <span class="keyword">delete</span>[] leftArr;</span><br><span class="line">    <span class="keyword">delete</span>[] rightArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归排序左右两部分</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, left, mid);</span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并排序后的两部分</span></span><br><span class="line">        <span class="built_in">merge</span>(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-快速排序（Quick-Sort）："><a href="#5-快速排序（Quick-Sort）：" class="headerlink" title="5. 快速排序（Quick Sort）："></a>5. <strong>快速排序（Quick Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：同样采用分治法，通过选择一个基准元素将数组分为两部分，再对每部分递归排序。</li><li><strong>时间复杂度</strong>：平均 $O(n \log n)$，最差 $O(n^2)$</li><li><strong>特点</strong>：通常比其他排序算法快，适合大型数据集，但对有序数组性能不佳。</li><li><strong>稳定性</strong>：不稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high]; <span class="comment">// 选择最后一个元素作为枢轴</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;       <span class="comment">// i 是较小元素的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt; high; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123; </span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]); <span class="comment">// 将较小的元素交换到前面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[high]); <span class="comment">// 将枢轴放到正确位置</span></span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;                <span class="comment">// 返回枢轴的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high); <span class="comment">// 获取分区索引</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>); <span class="comment">// 递归排序左半部分</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high); <span class="comment">// 递归排序右半部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-堆排序（Heap-Sort）："><a href="#6-堆排序（Heap-Sort）：" class="headerlink" title="6. 堆排序（Heap Sort）："></a>6. <strong>堆排序（Heap Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：利用堆这种数据结构进行排序，将数组构建成最大堆或最小堆，逐步取出堆顶元素排序。</li><li><strong>时间复杂度</strong>：$O(n \log n)$</li><li><strong>特点</strong>：时间复杂度稳定，但不适合小规模数据。</li><li><strong>稳定性</strong>：不稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点 i 及其子树调整为最大堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;         <span class="comment">// 将当前节点 i 设为最大值</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;    <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;   <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大值不是当前节点，则交换并递归调整</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主堆排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐一提取元素，重建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]); <span class="comment">// 将堆顶元素移到数组末尾</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);         <span class="comment">// 对剩余的元素重新进行堆化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">heapSort</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="7-希尔排序（Shell-Sort）："><a href="#7-希尔排序（Shell-Sort）：" class="headerlink" title="7. 希尔排序（Shell Sort）："></a>7. <strong>希尔排序（Shell Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：插入排序的改进版，逐步将数据分组并进行插入排序，最后整体排序。</li><li><strong>时间复杂度</strong>：介于 $O(n)$ 和 $O(n^2)$ 之间，具体取决于增量序列。</li><li><strong>特点</strong>：相对高效，尤其在数据量较大时。</li><li><strong>稳定性</strong>：不稳定</li></ul><h3 id="8-计数排序（Counting-Sort）："><a href="#8-计数排序（Counting-Sort）：" class="headerlink" title="8. 计数排序（Counting Sort）："></a>8. <strong>计数排序（Counting Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：适合数据范围较小的整数序列，通过统计数据出现的次数进行排序。</li><li><strong>时间复杂度</strong>：$O(n + k)$，其中 $k$ 为数值范围。</li><li><strong>特点</strong>：非常高效，但仅适用于特定场景。</li><li><strong>稳定性</strong>：稳定</li></ul><h3 id="9-基数排序（Radix-Sort）："><a href="#9-基数排序（Radix-Sort）：" class="headerlink" title="9. 基数排序（Radix Sort）："></a>9. <strong>基数排序（Radix Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：按数位或字符位置逐步排序，适合整数或字符串等定长数据。</li><li><strong>时间复杂度</strong>：$O(d \times (n + k))$，其中 $d$ 是位数，$k$ 为基数。</li><li><strong>特点</strong>：适用于数值或字符数据，效率高。</li><li><strong>稳定性</strong>：稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组中最大元素的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数排序，用于按特定位数对数组排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> exp)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* output = <span class="keyword">new</span> <span class="type">int</span>[n]; <span class="comment">// 输出数组</span></span><br><span class="line">    <span class="type">int</span> count[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;      <span class="comment">// 计数数组（基数范围为 0 到 9）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计在当前位数出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count[(arr[i] / exp) % <span class="number">10</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算累积和，更新 count 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建输出数组，按当前位数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> index = (arr[i] / exp) % <span class="number">10</span>;</span><br><span class="line">        output[count[index] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        count[index]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将排序好的数据拷贝回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = output[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基数排序的主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="built_in">getMax</span>(arr, n); <span class="comment">// 获取最大元素以确定最高位数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每一位数进行计数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> exp = <span class="number">1</span>; max / exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">countSort</span>(arr, n, exp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">170</span>, <span class="number">45</span>, <span class="number">75</span>, <span class="number">90</span>, <span class="number">802</span>, <span class="number">24</span>, <span class="number">2</span>, <span class="number">66</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">radixSort</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>代码说明:</li></ul><ol><li><code>getMax</code> 函数用于找到数组中的最大值，确定排序过程中最高的位数。</li><li><code>countSort</code> 函数实现了针对当前位数的计数排序。<code>exp</code> 表示当前处理的位数（例如，个位、十位等），通过 <code>arr[i] / exp % 10</code> 提取该位上的数字。</li><li><code>radixSort</code> 函数调用 <code>countSort</code>，从最低位开始对数组进行多轮排序，直到最高位。<br>基数排序的时间复杂度为 $O(d \cdot (n + k))$，其中 $d$ 是数字的最大位数，$n$ 是数组长度，$k$ 是基数（通常为10）。在处理整数的情况下，它通常被认为是线性时间排序算法。</li></ol><h3 id="10-桶排序（Bucket-Sort）："><a href="#10-桶排序（Bucket-Sort）：" class="headerlink" title="10. 桶排序（Bucket Sort）："></a>10. <strong>桶排序（Bucket Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：将数据分到不同的桶中，然后对每个桶进行排序，最后合并桶。</li><li><strong>时间复杂度</strong>：平均 $O(n + k)$</li><li><strong>特点</strong>：适合数据分布均匀的情况。</li><li><strong>稳定性</strong>：稳定（取决于桶内排序方法）</li></ul><h2 id="选择排序算法的依据"><a href="#选择排序算法的依据" class="headerlink" title="选择排序算法的依据"></a>选择排序算法的依据</h2><p>根据数据特性和需求，选择排序算法时一般考虑以下因素：</p><ul><li><strong>数据规模</strong>：数据规模小可以选择简单算法（如插入、选择、冒泡），规模较大可以考虑快速排序或归并排序。</li><li><strong>数据特性</strong>：若数据接近有序，选择插入排序；对于整数范围较小的数据，可以选择计数排序。</li><li><strong>稳定性要求</strong>：需要稳定的排序算法可以选择归并排序、计数排序、基数排序等。</li><li><strong>空间要求</strong>：对空间要求较高的场景可优先考虑堆排序或快速排序（可原地排序）。</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="数据结构" scheme="https://blog.whff521.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="排序" scheme="https://blog.whff521.xyz/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
