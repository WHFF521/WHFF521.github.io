<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AiRomance</title>
  <icon>https://blog.whff521.xyz/images/101.ico</icon>
  <subtitle>爱裸漫三三</subtitle>
  <link href="https://blog.whff521.xyz/atom.xml" rel="self"/>
  <link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
  <link href="https://blog.whff521.xyz/"/>
  <updated>2024-09-17T14:45:33.514Z</updated>
  <id>https://blog.whff521.xyz/</id>
  
  <author>
    <name>AiRomance</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HDU 1025 longest increasing subsequence</title>
    <link href="https://blog.whff521.xyz/2024/09/17/HDU-1025-longest-increasing-subsequence/"/>
    <id>https://blog.whff521.xyz/2024/09/17/HDU-1025-longest-increasing-subsequence/</id>
    <published>2024-09-17T13:57:39.000Z</published>
    <updated>2024-09-17T14:45:33.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Constructing-Roads-In-JGShining’s-Kingdom"><a href="#Constructing-Roads-In-JGShining’s-Kingdom" class="headerlink" title="Constructing Roads In JGShining’s Kingdom"></a>Constructing Roads In JGShining’s Kingdom</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1025">problem link</a></p><h2 id="The-meaning-of-the-problem"><a href="#The-meaning-of-the-problem" class="headerlink" title="The meaning of the problem"></a>The meaning of the problem</h2><p>So why this is longest increasing subsequence Problem ? Look at the picture below:</p><p><img src="https://images.whff521.top/hdu1025.jpg" alt="hdu1025"></p><p>As the problem described, we can’t have crossed lines. Each line has two endpoints. One is the “rich” endpoint above and the other is the “poor” endpoint below. The rich endpoints’ number of the lines we finally pick up should be <strong>monotonically increasing</strong>. The corresponding poor endpoints should be <strong>monotonically increasing</strong> too. Otherwise the lines will be crossed.</p><p>Let’s use <strong><code>a[p]=q</code> to represent that the p city can link q city</strong>. Then the problem tend to become a question of longest increasing subsequence.</p><h2 id="The-Algorithm"><a href="#The-Algorithm" class="headerlink" title="The Algorithm"></a>The Algorithm</h2><p>There is a quite easy way to understand the LIS problem. I learned it from <a href="https://leetcode.cn/problems/longest-increasing-subsequence/solutions/13118/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/">this tutorial</a></p><blockquote><p>A clever approach. Create a new array <code>cell</code> to store the longest increasing subsequence.  </p><p>Iterate through the original sequence, and binary insert each element into <code>cell</code>.</p><p>If all the elements in <code>cell</code> are smaller than the current one, append it at the end.<br>Otherwise, <strong>replace the smallest element in <code>cell</code> that is larger than the current one</strong>.<br>In short, the idea is to keep <code>cell</code> storing relatively smaller elements. Although <code>cell</code> may not represent the actual longest increasing subsequence, its length is correct.</p><p>Author: ColdMe<br>Link: <a href="https://leetcode.cn/problems/longest-increasing-subsequence/solutions/13118/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/">https://leetcode.cn/problems/longest-increasing-subsequence/solutions/13118/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/</a><br>Source: LeetCode<br>Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please credit the source.</p></blockquote><p>There are ways to prove that the <code>cell</code> array is monotonically increasing. Anything detailed you can see <a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence">Wikipedia</a></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> seq[mxlen];</span><br><span class="line"><span class="type">int</span> a[mxlen];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            a[x]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(seq,<span class="number">0</span>,<span class="built_in">sizeof</span>(seq));</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;seq[len])&#123;</span><br><span class="line">                seq[++len] = a[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> l=<span class="number">1</span>,r=len;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">                    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(seq[mid]&gt;=a[i]) r = mid<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                seq[l] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// When the number of roads is greater than 2, an s needs to be added after the road.</span></span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\nMy king, at most 1 road can be built.\n\n&quot;</span>,++cnt);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\nMy king, at most %d roads can be built.\n\n&quot;</span>,++cnt,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Constructing-Roads-In-JGShining’s-Kingdom&quot;&gt;&lt;a href=&quot;#Constructing-Roads-In-JGShining’s-Kingdom&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="最长上升子序列" scheme="https://blog.whff521.xyz/tags/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1023 Train Problem II 高精度卡特兰数</title>
    <link href="https://blog.whff521.xyz/2024/09/16/HDU-1023-Train-Problem-II-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    <id>https://blog.whff521.xyz/2024/09/16/HDU-1023-Train-Problem-II-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/</id>
    <published>2024-09-16T03:19:59.000Z</published>
    <updated>2024-09-16T03:52:18.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="High-precision-Catalan-number"><a href="#High-precision-Catalan-number" class="headerlink" title="High-precision Catalan number"></a>High-precision Catalan number</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1023">problem link</a></p><p>This is a classic problem of finding the number of stack push ans pop sequences. The only headache is that it requires high precision.</p><h2 id="How-to-determine-whether-it-is-a-Catalan-number"><a href="#How-to-determine-whether-it-is-a-Catalan-number" class="headerlink" title="How to determine whether it is a Catalan number"></a>How to determine whether it is a Catalan number</h2><p>For a more detailed introduction to the Catalan number,see <a href="https://oi-wiki.org/math/combinatorics/catalan/">oi-wiki</a> and <a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0">wikipedia</a></p><p>I think there is another simple way to judge, which is to see whether the first few numbers are consistent with the Catalan number. If they are the same, then it is likely to be a correct guess.</p><p><img src="https://images.whff521.top/catalan.png" alt="截图来自oi-wiki"></p><h2 id="Algortithm-Implementation"><a href="#Algortithm-Implementation" class="headerlink" title="Algortithm Implementation"></a>Algortithm Implementation</h2><p>We use <code>catalan[i][j]</code> to represent the j-th digital of the i-th Catalan number. </p><p>The formula I use is <code>h(n) = (4n-2)*h(n-1)/(n+1)</code>.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> catalan[<span class="number">105</span>][mxlen];</span><br><span class="line"><span class="comment">// catalan[i][j] stores the j-th digit of the i-th catalan number</span></span><br><span class="line"><span class="comment">// h(n) = (4n-2)*h(n-1)/(n+1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    catalan[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;mxlen;j++)&#123;</span><br><span class="line">            tmp+=catalan[i<span class="number">-1</span>][j]*(<span class="number">4</span>*i<span class="number">-2</span>);</span><br><span class="line">            catalan[i][j] = tmp%<span class="number">10</span>;</span><br><span class="line">            tmp/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mxlen is big enough, so tmp will be 0 after the loop</span></span><br><span class="line">        j=mxlen<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(catalan[i][j]==<span class="number">0</span>) j--;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            tmp = tmp*<span class="number">10</span>+catalan[i][j];</span><br><span class="line">            catalan[i][j--] = tmp/(i+<span class="number">1</span>);  </span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;=i+<span class="number">1</span>) tmp%=(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Catalan number is a integer, so remain is 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pre_work</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="type">int</span> i = mxlen<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(catalan[n][i]==<span class="number">0</span>) i--;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,catalan[n][i--]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;High-precision-Catalan-number&quot;&gt;&lt;a href=&quot;#High-precision-Catalan-number&quot; class=&quot;headerlink&quot; title=&quot;High-precision Catalan</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="卡特兰数" scheme="https://blog.whff521.xyz/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1011 Starship Troopers 树形DP</title>
    <link href="https://blog.whff521.xyz/2024/09/13/HDU-1011-Starship-Troopers-%E6%A0%91%E5%BD%A2DP/"/>
    <id>https://blog.whff521.xyz/2024/09/13/HDU-1011-Starship-Troopers-%E6%A0%91%E5%BD%A2DP/</id>
    <published>2024-09-13T07:34:37.000Z</published>
    <updated>2024-09-13T11:24:00.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案会比你想象的简单很多"><a href="#答案会比你想象的简单很多" class="headerlink" title="答案会比你想象的简单很多"></a>答案会比你想象的简单很多</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1011">题目链接</a></p><p>这道题最大的障碍应该是猜对题意。。。题里说的“possibility”应该不是真正的相对于人数的概率，而是可以随意相加的数字，你可以直接当成获得这个数量的金币之类的。</p><p>树形迷宫，只要你能放置超过对应数量的士兵在这个节点，你就可以获得这个节点的“possibility”。同时你可以继续向这个节点的子节点进行进攻，你甚至可以兵分几路向下前进。这些被放置的士兵只能留在被放置的节点而不能重复利用。你一共有m个士兵，求出你可以获得的“possibility”的最大值。</p><h2 id="正向思考"><a href="#正向思考" class="headerlink" title="正向思考"></a>正向思考</h2><p>每当你占领一个节点，面临的就是你如何要用剩下的军队，分成几部分去这个节点的子节点。显然正向出发去求你并不知道到底怎样决策才能获得最大价值，因为你甚至还不知道接下来你会面临什么样的节点。</p><h2 id="反向思考"><a href="#反向思考" class="headerlink" title="反向思考"></a>反向思考</h2><p>这就要搬出和深搜常绑定的一个词——“回溯”。我们一路深搜到叶子节点，我们要从终点走到起点。面对只有一个节点，你当然知道你最少需要多少士兵，你最大能获得多少价值。我们用<code>dp[x][i]</code>表示第x节点用掉i个士兵获得的最大的价值。如果当前节点最少需要j个士兵，那么dp[x][j～m]的初始值就是当前节点的价值量。毕竟人少了不行，但是人多了是肯定可以的。</p><p>当两个叶子汇聚到一个父节点应该怎么转移呢？我们需要就将人分成两部分，一部分x个人给一个叶子，一部分y个人给另一个（或者另好几个）叶子，父节点用的人数就是<code>x+y+i</code>个人。因为我们已经知道了每个节点用多少人能够获得多少价值，我们可以枚举所有情况来进行更新最优解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> pre[mxlen*<span class="number">2</span>],last[mxlen],other[mxlen*<span class="number">2</span>],l;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    l++;</span><br><span class="line">    pre[l] = last[x];</span><br><span class="line">    last[x] = l;</span><br><span class="line">    other[l] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dp[mxlen][mxlen];</span><br><span class="line"><span class="type">bool</span> vis[mxlen];</span><br><span class="line"><span class="type">int</span> bugs[mxlen],brains[mxlen];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">    <span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="built_in">sizeof</span>(last));</span><br><span class="line">    <span class="built_in">memset</span>(other,<span class="number">0</span>,<span class="built_in">sizeof</span>(other));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 向上取整</span></span><br><span class="line">    <span class="type">int</span> needed = (bugs[x]+<span class="number">19</span>)/<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=needed;i&lt;=m;i++)&#123;</span><br><span class="line">        dp[x][i] = brains[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=last[x];p;p=pre[p])&#123;</span><br><span class="line">        <span class="type">int</span> y = other[p];</span><br><span class="line">        <span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = m;i&gt;=needed;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i-needed;j++)&#123;</span><br><span class="line">                <span class="comment">//第x节点消耗i个士兵能获得的最大价值</span></span><br><span class="line">                dp[x][i] = <span class="built_in">max</span>(dp[x][i],dp[x][i-j]+dp[y][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">-1</span>&amp;&amp;m==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">prepare</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;bugs[i],&amp;brains[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">add</span>(x,y);</span><br><span class="line">            <span class="built_in">add</span>(y,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        cout&lt;&lt;dp[<span class="number">1</span>][m]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;答案会比你想象的简单很多&quot;&gt;&lt;a href=&quot;#答案会比你想象的简单很多&quot; class=&quot;headerlink&quot; title=&quot;答案会比你想象的简单很多&quot;&gt;&lt;/a&gt;答案会比你想象的简单很多&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="深搜" scheme="https://blog.whff521.xyz/tags/%E6%B7%B1%E6%90%9C/"/>
    
    <category term="动态规划" scheme="https://blog.whff521.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>HDOJ 1010 Tempter of the Bone 深搜&amp;剪枝</title>
    <link href="https://blog.whff521.xyz/2024/09/12/HDOJ-1010-Tempter-of-the-Bone-%E6%B7%B1%E6%90%9C-%E5%89%AA%E6%9E%9D/"/>
    <id>https://blog.whff521.xyz/2024/09/12/HDOJ-1010-Tempter-of-the-Bone-%E6%B7%B1%E6%90%9C-%E5%89%AA%E6%9E%9D/</id>
    <published>2024-09-12T14:29:27.000Z</published>
    <updated>2024-09-12T14:59:18.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="细心和智慧并存的解答"><a href="#细心和智慧并存的解答" class="headerlink" title="细心和智慧并存的解答"></a>细心和智慧并存的解答</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1010">题目链接</a> </p><p>题的大致意思是能不能从起点经过T时间精准到达终点，图中有一些障碍不能走，走过的格子也不能再走。</p><p>其中数据是最大7*7的迷宫，最多50个迷宫。</p><h2 id="智慧之处——精准的剪枝"><a href="#智慧之处——精准的剪枝" class="headerlink" title="智慧之处——精准的剪枝"></a>智慧之处——精准的剪枝</h2><p>类似全排列的深搜时间复杂度是O(n!)，7*7的数据是过不去的。  </p><p>首先就是普通地剪枝：</p><ul><li>如果时间已经大于T，就不用再走了</li><li>如果已经有正确答案，要及时地退出搜索</li></ul><p>然后是奇偶剪枝，这里参考了<a href="https://blog.csdn.net/code_pang/article/details/8839432">其他博客</a>  </p><p>这里我重新画了一张图，如下：</p><p><img src="https://images.whff521.top/maze.jpg" alt="maze"></p><p>图中的S可以代表任何你走到的位置，不一定是起点。就如图中的红色和蓝色路径，这两条路径是最少需要的时间。如果剩余时间少于最短路径长度，那么是一定不能到达终点的。  </p><p>既然时间不够一定不能到达，时间刚好和剩余最少时间相等也能到达，那么还剩一种情况，就是时间大于剩余最少时间。这也应该是大概率会遇到的情况。根据题意我们只能在第T秒精准到达终点，我们时间多出来的怎么办呢？——我们需要在终点周围“<strong>徘徊</strong>”。  </p><p>如图中的绿色和黄色箭头所示，你比最短路径多走出来的路径，一定是先“出去”，再“回来”。多走的路径是“对称的”，那多出来的路径长度一定是偶数。  </p><p>这就是奇偶性剪枝。加上这个剪枝就能过所有的测试数据。</p><h2 id="细心之处——多数据下数组的重复利用"><a href="#细心之处——多数据下数组的重复利用" class="headerlink" title="细心之处——多数据下数组的重复利用"></a>细心之处——多数据下数组的重复利用</h2><p>尽管我写过无数个全排列暴力骗过不少10分、20分。但是在这道题上还是因为粗心而浪费了不少时间。  </p><p>在做杭电这前十道题的时候我就发现基本都是多数据的形式。所以除了输入会重新填入数据的数组外，其他数据都需要进行“<strong>初始化</strong>”。</p><p>但是即使我清空了<code>vis</code>数据，我发现代码运行的答案竟然是错误的（样例是能过的）。  </p><p>原因就是这道题毕竟不是全排列，vis数组不能只在dfs的for循环中去设置。<strong>你的起点在你走出第一步后就再也不能回来了</strong>。</p><p><code>vis[startX][startY]=true;</code></p><p>代码： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> mp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> n,m,T;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">string ans;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> startX,startY,endX,endY;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="string">&quot;YES&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(step&gt;T) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mp[x][y]==<span class="string">&#x27;D&#x27;</span>&amp;&amp;step==T)&#123;</span><br><span class="line">        ans = <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余时间小于到终点的最短距离</span></span><br><span class="line">    <span class="keyword">if</span>(T-step&lt;(<span class="built_in">abs</span>(x-endX)+<span class="built_in">abs</span>(y-endY)))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剩余时间剪去最短距离不是偶数</span></span><br><span class="line">    <span class="keyword">if</span>((T-step-(<span class="built_in">abs</span>(x-endX)+<span class="built_in">abs</span>(y-endY)))%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> nx = x+dx[i];</span><br><span class="line">        <span class="type">int</span> ny = y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(nx&gt;=<span class="number">1</span>&amp;&amp;nx&lt;=n&amp;&amp;ny&gt;=<span class="number">1</span>&amp;&amp;ny&lt;=m&amp;&amp;!vis[nx][ny]&amp;&amp;mp[nx][ny]!=<span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">            vis[nx][ny]=<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(nx,ny,step+<span class="number">1</span>);</span><br><span class="line">            vis[nx][ny]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;T);</span><br><span class="line">        <span class="keyword">if</span>(!n&amp;&amp;!m&amp;&amp;!T) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                cin&gt;&gt;mp[i][j];</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">                    startX=i;</span><br><span class="line">                    startY=j;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                    endX=i;</span><br><span class="line">                    endY=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">        <span class="comment">// vis记得清空</span></span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="comment">// 起点要标记为已访问 </span></span><br><span class="line">        vis[startX][startY]=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(startX,startY,<span class="number">0</span>);</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;细心和智慧并存的解答&quot;&gt;&lt;a href=&quot;#细心和智慧并存的解答&quot; class=&quot;headerlink&quot; title=&quot;细心和智慧并存的解答&quot;&gt;&lt;/a&gt;细心和智慧并存的解答&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="深搜" scheme="https://blog.whff521.xyz/tags/%E6%B7%B1%E6%90%9C/"/>
    
    <category term="剪枝" scheme="https://blog.whff521.xyz/tags/%E5%89%AA%E6%9E%9D/"/>
    
  </entry>
  
  <entry>
    <title>HDOJ 1007 Quoit Design 圆环设计</title>
    <link href="https://blog.whff521.xyz/2024/09/11/HDOJ-1007-Quoit-Design-%E5%9C%86%E7%8E%AF%E8%AE%BE%E8%AE%A1/"/>
    <id>https://blog.whff521.xyz/2024/09/11/HDOJ-1007-Quoit-Design-%E5%9C%86%E7%8E%AF%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-09-10T16:42:25.000Z</published>
    <updated>2024-09-11T00:33:45.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一道经典的分治"><a href="#一道经典的分治" class="headerlink" title="一道经典的分治"></a>一道经典的分治</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1007">题目链接</a></p><p>题意是套圈游戏要设计一款尺寸最大的圆环，满足圆环不会一次套中两个物品。每个物品有一个摆放坐标。我们要求的是这些物品中相邻最近的两个物品之间的距离，这个距离就是我们要求的圆环的直径。  </p><p>这个类型网上常称为<code>寻找最近点对问题</code>。  </p><p>数据是十万（1e5），分治算法时间复杂度是<code>O(nlogn)</code>，刚好能够跑完。</p><p>分治的思想就是我们先将所有点按照横坐标从小到大排序，然后将点分成左右两部分，也就是图中的<code>L</code>和<code>R</code>区域，这样我们就可以分别求两边的距离最小值。当然在中间线的<code>mid</code>部分也是需要求距离的。</p><p>在算完两边的距离最小值<code>d</code>后，我们将中间线向左和向右扩展<code>d</code>长度，组成<code>mid</code>的领域。可以知道如果领域再扩大增加的点并不会形成更优的答案。这里需要注意，我们的<code>L</code>和<code>R</code>区域是以中间线为界，也就是说<code>mid</code>区域其实是叠加在两边区域之上的。</p><p><img src="https://images.whff521.top/fenzhi.jpg" alt="fenzhi"></p><p>虽然中间区域的点已经会排除掉一些点，但是直接用双重循环找最短距离会超时。这是因为如果点都在中间密集的话时间复杂度会接近<code>O(n*n)</code>。</p><p>所以我们需要把中间点按照<code>y</code>的从小到大排序，在循环中如果两点纵坐标之间的距离已经大于<code>d</code>的时候及时跳出循环，完成剪枝。在<a href="http://oi-wiki.com/geometry/nearest-points/">oi-wiki</a>中有证明，这里的满足条件的点不会超过7。</p><p>边界问题：自己与自己之间距离设置成足够大的值，如果区间只有两个点，则直接计算两点之间距离。</p><p><strong>PS: 函数命名不要用distance，会和C++库中函数重名而导致CE</strong> </p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;points[mxlen];</span><br><span class="line"><span class="comment">// sort by x</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpx</span><span class="params">(node qw,node er)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(qw.x==er.x) <span class="keyword">return</span> qw.y&lt;er.y;</span><br><span class="line">    <span class="keyword">return</span> qw.x&lt;er.x;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort by y</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpy</span><span class="params">(node qw,node er)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(qw.y==er.y) <span class="keyword">return</span> qw.x&lt;er.x;</span><br><span class="line">    <span class="keyword">return</span> qw.y&lt;er.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// count the distance between two points</span></span><br><span class="line"><span class="comment">// name can not be distance, because there is a function named distance in cmath</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(node qw,node er)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((qw.x-er.x)*(qw.x-er.x)+(qw.y-er.y)*(qw.y-er.y));</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">node temp[mxlen];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="number">1e20</span>;</span><br><span class="line">    <span class="comment">// if there are only two points</span></span><br><span class="line">    <span class="keyword">if</span>(l+<span class="number">1</span>==r) <span class="keyword">return</span> <span class="built_in">dis</span>(points[l],points[r]);</span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">min</span>(<span class="built_in">solve</span>(l,mid),<span class="built_in">solve</span>(mid+<span class="number">1</span>,r));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort by y, otherwise the code will TLE</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid;i&gt;=l&amp;&amp;points[mid].x-points[i].x&lt;d;i--) temp[len++] = points[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=r&amp;&amp;points[i].x-points[mid].x&lt;d;i++) temp[len++] = points[i];</span><br><span class="line">    <span class="built_in">sort</span>(temp+<span class="number">1</span>,temp+len,cmpy);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len&amp;&amp;temp[j].y-temp[i].y&lt;d;j++)&#123;</span><br><span class="line">            d = <span class="built_in">min</span>(d,<span class="built_in">dis</span>(temp[i],temp[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;points[i].x,&amp;points[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(points+<span class="number">1</span>,points+n+<span class="number">1</span>,cmpx);</span><br><span class="line">        <span class="type">double</span> ans = <span class="built_in">solve</span>(<span class="number">1</span>,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,ans/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;一道经典的分治&quot;&gt;&lt;a href=&quot;#一道经典的分治&quot; class=&quot;headerlink&quot; title=&quot;一道经典的分治&quot;&gt;&lt;/a&gt;一道经典的分治&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="分治" scheme="https://blog.whff521.xyz/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
</feed>
