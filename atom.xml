<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AiRomance</title>
  <icon>https://blog.whff521.xyz/images/101.ico</icon>
  <subtitle>爱裸漫三三</subtitle>
  <link href="https://blog.whff521.xyz/atom.xml" rel="self"/>
  <link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
  <link href="https://blog.whff521.xyz/"/>
  <updated>2024-09-24T04:24:31.136Z</updated>
  <id>https://blog.whff521.xyz/</id>
  
  <author>
    <name>AiRomance</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HDU 1465 (错位排列问题)</title>
    <link href="https://blog.whff521.xyz/2024/09/23/HDU-1465-%E9%94%99%E4%BD%8D%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.whff521.xyz/2024/09/23/HDU-1465-%E9%94%99%E4%BD%8D%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</id>
    <published>2024-09-23T06:13:33.000Z</published>
    <updated>2024-09-24T04:24:31.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Derangement-Problem"><a href="#Derangement-Problem" class="headerlink" title="Derangement Problem"></a>Derangement Problem</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1465">problem link</a></p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>You have <code>n</code> letters, each with a different recipient. However, all the letters are delivered to the wrong recipients, meaning no one receives the letter intended for them. You need to determine how many possible ways this can happen.</p><p>This problem can be simplified to a case where you have an array of numbers from 1 to n. For each position in the array(starting from index 1), the number in that position is different from its index. The goal is to count how many such arrangement exist.</p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>This is a classic <strong>derangement</strong> problem. You can find a more detailed explanation on <a href="https://oi-wiki.org/math/combinatorics/derangement/">oi-wiki</a> and <a href="https://en.wikipedia.org/wiki/Derangement">wikipedia</a>.</p><p>I solved the problem using a recursive approach. Let<code>D[i]</code>represent the number of derangements when <code>n = i</code>. The recursive formula is: <code>D[i]=(i-1)D[i-1]+(i-1)D[i-2]</code>.</p><p>Here’s an explanation of the formula:</p><p>Assume we already know the answers for <code>i-1</code>. Now, we add the <code>i-th</code> number to the sequence in the <code>i-th</code> position. Since the number in each position must differ from the position itself, we need to swap <code>i</code> with a number in the previous positions. The first case is where all of the previous <code>i-1</code> numbers are already deranged, so we can swap <code>i</code> with any of them, giving us <code>(i-1)D[i-1]</code> possibilities. The second case is where <code>i-2</code> numbers are deranged, but one number matches its index. In this case, we swap <code>i</code> with that number, which gives us <code>(i-1)D[i-2]</code> possibilities.</p><p><img src="https://images.whff521.top/Dislocation.jpg" alt="dislocation"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll a[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;=<span class="number">20</span>;i++)&#123;</span><br><span class="line">        a[i] = (i<span class="number">-1</span>)*(a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Derangement-Problem&quot;&gt;&lt;a href=&quot;#Derangement-Problem&quot; class=&quot;headerlink&quot; title=&quot;Derangement Problem&quot;&gt;&lt;/a&gt;Derangement</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数论" scheme="https://blog.whff521.xyz/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="错位排列" scheme="https://blog.whff521.xyz/tags/%E9%94%99%E4%BD%8D%E6%8E%92%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Notes of Lecture 23: Computational Complexity</title>
    <link href="https://blog.whff521.xyz/2024/09/21/Notes-of-Lecture-23-Computational-Complexity/"/>
    <id>https://blog.whff521.xyz/2024/09/21/Notes-of-Lecture-23-Computational-Complexity/</id>
    <published>2024-09-21T11:19:41.000Z</published>
    <updated>2024-09-21T14:24:21.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Notes-of-Lecture-23-Computational-Complexity"><a href="#Notes-of-Lecture-23-Computational-Complexity" class="headerlink" title="Notes of Lecture 23: Computational Complexity"></a>Notes of Lecture 23: Computational Complexity</h1><p><a href="https://youtu.be/moPtwq_cVH8?si=u92BMoXF0Yqg1YH5">video link</a></p><h2 id="P-EXP-R"><a href="#P-EXP-R" class="headerlink" title="P,EXP,R"></a>P,EXP,R</h2><p>P &#x3D; {problems solvable in at most(&lt;&#x3D;) polynomial time}</p><p>EXP &#x3D; {problems solvable in exponential(2^$n^c$) time}</p><p>R &#x3D; {problems solvable in finite time}</p><p><img src="https://images.whff521.top/PEXPR.png" alt="P,EXP,R"></p><p>The axis is computational difficulty.</p><h2 id="Most-problems-uncomputable"><a href="#Most-problems-uncomputable" class="headerlink" title="Most problems uncomputable"></a>Most problems uncomputable</h2><p>Examples:</p><ul><li>negative-weight cycle detection (P)</li><li>NxN Chess (EXP&amp;!P)</li><li>Tetris (EXP, don’t know whether is P)</li><li>halting problem: given program, does it ever halt&#x2F;stop? (not in R)</li></ul><p>Most decision problems are uncomputable (not in R)</p><ul><li>program $\approx$ binary string $\approx$ natural number (integer)</li><li>decision problem &#x3D; function : input($\approx$ binary string (N)) -&gt;{yes(1),no(0)}</li></ul><p>So decision problem is in $\mathbb{R}$;</p><p>$|\mathbb{R}|$ &gt;&gt; $|\mathbb{N}|$ &#x3D;&gt; almost every problem unsolvable by any program</p><h2 id="NP"><a href="#NP" class="headerlink" title="NP"></a>NP</h2><p>NP &#x3D; {decision problems solvable in polynomial time via a “lucky” algorithm}</p><ul><li><p>nondeterministic model : algorithm makes guesses &amp; says YES&#x2F;NO.</p></li><li><p>guesses are guaranteed to lead to “YES” if possible </p></li><li><p>Tetris is NP</p></li></ul><p>proof &#x3D; sequence of moves to make</p><p>NP &#x3D; {decision problems with “solutions” that can be “checked” in polynomial time}</p><ul><li>When answer &#x3D; YES, can prove it &amp; check proof in polynomial time.</li></ul><h2 id="Hardness-Completeness"><a href="#Hardness-Completeness" class="headerlink" title="Hardness &amp; Completeness"></a>Hardness &amp; Completeness</h2><p>P!&#x3D;NP : big conjecture $\approx$ “can’t engineer luck” $\approx$ generating (proofs of) solutions can be harder than checking them.</p><p>Claim: if P!&#x3D;NP then Tetris is NP-P &#x3D;&gt; not in P.</p><p>Why? Tetris is NP-hard(as hard as every problem which is NP)</p><ul><li>in fact Tetris is NP-complete &#x3D; NP $\cap$ NP-hard</li></ul><p><img src="https://images.whff521.top/NPwholeAxis.png" alt="whole axis"></p><h2 id="Reductions"><a href="#Reductions" class="headerlink" title="Reductions"></a>Reductions</h2><p>Reductions: A -&gt; B</p><p>convert problem A(don’t know how to solve) into problem B(you know how to solve)</p><ul><li><p>unweighted shortest paths -&gt; weighted shortest paths</p></li><li><p>min-product path -&gt; shortest path</p></li><li><p>longest path -&gt; shortest path</p></li></ul><p>B is as hard ad A</p><p>3- partition [Karp] -&gt; Tetris</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Notes-of-Lecture-23-Computational-Complexity&quot;&gt;&lt;a href=&quot;#Notes-of-Lecture-23-Computational-Complexity&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="摘抄" scheme="https://blog.whff521.xyz/categories/%E6%91%98%E6%8A%84/"/>
    
    
    <category term="NP" scheme="https://blog.whff521.xyz/tags/NP/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1085 multiple knapsack problem</title>
    <link href="https://blog.whff521.xyz/2024/09/19/HDU-1085-multiple-knapsack-problem/"/>
    <id>https://blog.whff521.xyz/2024/09/19/HDU-1085-multiple-knapsack-problem/</id>
    <published>2024-09-19T12:31:59.000Z</published>
    <updated>2024-09-19T13:05:17.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Multiple-Knapsack-Problem"><a href="#Multiple-Knapsack-Problem" class="headerlink" title="Multiple Knapsack Problem"></a>Multiple Knapsack Problem</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1085">problem link</a></p><h2 id="The-Meaning-of-the-problem"><a href="#The-Meaning-of-the-problem" class="headerlink" title="The Meaning of the problem"></a>The Meaning of the problem</h2><p>You have three kinds of coins. Their face values are 1,2 and 5. Of cause you only have a limited number of coins. You need to find the minimum value that you can’t represent exactly with these coins.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>There are  lots of people solve this problem using Generating function. That way is too hard to understand. We just need to think of this problem as a multiple knapsack problem.</p><p>I learned from <a href="https://seramasumi.github.io/docs/Algorithms/mc-%E5%BE%AE%E8%AF%BE%E5%A0%82-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html">this blog</a></p><p><code>dp[j] = 1</code> means that <code>j</code> value can be represent by the coins.</p><p>Set <code>dp[0] = 1</code> initially. And the transfer equation is <code>dp[j] = max(dp[j],dp[j-k*money[i]])</code></p><p>Let’s assume there is only one 1 yuan coin, one 2 yuan coin and one 5 yuan coin. When <code>d[j]</code> need changing, we should see whether <code>d[j-value]</code> can be represent.</p><p>The top row of the table shows the total amount of money. The leftmost column of the table shows the face value of the coins.</p><p>Here’s the picture to show how the sequence is changed.</p><p><img src="https://images.whff521.top/Screenshot%202024-09-19%20at%2020.29.36.png" alt="knapsack sheet"></p><p>The top row of the table shows the total amount of money. The leftmost column of the table shows the face value of the coins.</p><p>The answer is <code>i</code> where <code>dp[i] = 0</code>.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[mxlen];</span><br><span class="line"><span class="type">int</span> num[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> money[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n1,n2,n5;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;num[<span class="number">1</span>],&amp;num[<span class="number">2</span>],&amp;num[<span class="number">3</span>]);        </span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;num[<span class="number">2</span>]==<span class="number">0</span>&amp;&amp;num[<span class="number">3</span>]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> sum = num[<span class="number">1</span>]+<span class="number">2</span>*num[<span class="number">2</span>]+<span class="number">5</span>*num[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 多重背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 倒序是因为我们转移需要上一层的数据，正序的话会改变值从而后面的值更新错误</span></span><br><span class="line">            <span class="comment">// 因为实际上这是用一维数组代替二维数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=money[i];j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k*money[i]&lt;=j&amp;&amp;k&lt;=num[i];k++)&#123;</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j],dp[j-k*money[i]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = sum+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=sum;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[i]) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Multiple-Knapsack-Problem&quot;&gt;&lt;a href=&quot;#Multiple-Knapsack-Problem&quot; class=&quot;headerlink&quot; title=&quot;Multiple Knapsack Problem&quot;&gt;&lt;/a&gt;Multiple</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="多重背包" scheme="https://blog.whff521.xyz/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1025 longest increasing subsequence</title>
    <link href="https://blog.whff521.xyz/2024/09/17/HDU-1025-longest-increasing-subsequence/"/>
    <id>https://blog.whff521.xyz/2024/09/17/HDU-1025-longest-increasing-subsequence/</id>
    <published>2024-09-17T13:57:39.000Z</published>
    <updated>2024-09-17T14:45:33.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Constructing-Roads-In-JGShining’s-Kingdom"><a href="#Constructing-Roads-In-JGShining’s-Kingdom" class="headerlink" title="Constructing Roads In JGShining’s Kingdom"></a>Constructing Roads In JGShining’s Kingdom</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1025">problem link</a></p><h2 id="The-meaning-of-the-problem"><a href="#The-meaning-of-the-problem" class="headerlink" title="The meaning of the problem"></a>The meaning of the problem</h2><p>So why this is longest increasing subsequence Problem ? Look at the picture below:</p><p><img src="https://images.whff521.top/hdu1025.jpg" alt="hdu1025"></p><p>As the problem described, we can’t have crossed lines. Each line has two endpoints. One is the “rich” endpoint above and the other is the “poor” endpoint below. The rich endpoints’ number of the lines we finally pick up should be <strong>monotonically increasing</strong>. The corresponding poor endpoints should be <strong>monotonically increasing</strong> too. Otherwise the lines will be crossed.</p><p>Let’s use <strong><code>a[p]=q</code> to represent that the p city can link q city</strong>. Then the problem tend to become a question of longest increasing subsequence.</p><h2 id="The-Algorithm"><a href="#The-Algorithm" class="headerlink" title="The Algorithm"></a>The Algorithm</h2><p>There is a quite easy way to understand the LIS problem. I learned it from <a href="https://leetcode.cn/problems/longest-increasing-subsequence/solutions/13118/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/">this tutorial</a></p><blockquote><p>A clever approach. Create a new array <code>cell</code> to store the longest increasing subsequence.  </p><p>Iterate through the original sequence, and binary insert each element into <code>cell</code>.</p><p>If all the elements in <code>cell</code> are smaller than the current one, append it at the end.<br>Otherwise, <strong>replace the smallest element in <code>cell</code> that is larger than the current one</strong>.<br>In short, the idea is to keep <code>cell</code> storing relatively smaller elements. Although <code>cell</code> may not represent the actual longest increasing subsequence, its length is correct.</p><p>Author: ColdMe<br>Link: <a href="https://leetcode.cn/problems/longest-increasing-subsequence/solutions/13118/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/">https://leetcode.cn/problems/longest-increasing-subsequence/solutions/13118/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/</a><br>Source: LeetCode<br>Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please credit the source.</p></blockquote><p>There are ways to prove that the <code>cell</code> array is monotonically increasing. Anything detailed you can see <a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence">Wikipedia</a></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> seq[mxlen];</span><br><span class="line"><span class="type">int</span> a[mxlen];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            a[x]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(seq,<span class="number">0</span>,<span class="built_in">sizeof</span>(seq));</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;seq[len])&#123;</span><br><span class="line">                seq[++len] = a[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> l=<span class="number">1</span>,r=len;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">                    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(seq[mid]&gt;=a[i]) r = mid<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                seq[l] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// When the number of roads is greater than 2, an s needs to be added after the road.</span></span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\nMy king, at most 1 road can be built.\n\n&quot;</span>,++cnt);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\nMy king, at most %d roads can be built.\n\n&quot;</span>,++cnt,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Constructing-Roads-In-JGShining’s-Kingdom&quot;&gt;&lt;a href=&quot;#Constructing-Roads-In-JGShining’s-Kingdom&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="最长上升子序列" scheme="https://blog.whff521.xyz/tags/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1023 Train Problem II 高精度卡特兰数</title>
    <link href="https://blog.whff521.xyz/2024/09/16/HDU-1023-Train-Problem-II-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    <id>https://blog.whff521.xyz/2024/09/16/HDU-1023-Train-Problem-II-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/</id>
    <published>2024-09-16T03:19:59.000Z</published>
    <updated>2024-09-16T03:52:18.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="High-precision-Catalan-number"><a href="#High-precision-Catalan-number" class="headerlink" title="High-precision Catalan number"></a>High-precision Catalan number</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1023">problem link</a></p><p>This is a classic problem of finding the number of stack push ans pop sequences. The only headache is that it requires high precision.</p><h2 id="How-to-determine-whether-it-is-a-Catalan-number"><a href="#How-to-determine-whether-it-is-a-Catalan-number" class="headerlink" title="How to determine whether it is a Catalan number"></a>How to determine whether it is a Catalan number</h2><p>For a more detailed introduction to the Catalan number,see <a href="https://oi-wiki.org/math/combinatorics/catalan/">oi-wiki</a> and <a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0">wikipedia</a></p><p>I think there is another simple way to judge, which is to see whether the first few numbers are consistent with the Catalan number. If they are the same, then it is likely to be a correct guess.</p><p><img src="https://images.whff521.top/catalan.png" alt="截图来自oi-wiki"></p><h2 id="Algortithm-Implementation"><a href="#Algortithm-Implementation" class="headerlink" title="Algortithm Implementation"></a>Algortithm Implementation</h2><p>We use <code>catalan[i][j]</code> to represent the j-th digital of the i-th Catalan number. </p><p>The formula I use is <code>h(n) = (4n-2)*h(n-1)/(n+1)</code>.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> catalan[<span class="number">105</span>][mxlen];</span><br><span class="line"><span class="comment">// catalan[i][j] stores the j-th digit of the i-th catalan number</span></span><br><span class="line"><span class="comment">// h(n) = (4n-2)*h(n-1)/(n+1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    catalan[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;mxlen;j++)&#123;</span><br><span class="line">            tmp+=catalan[i<span class="number">-1</span>][j]*(<span class="number">4</span>*i<span class="number">-2</span>);</span><br><span class="line">            catalan[i][j] = tmp%<span class="number">10</span>;</span><br><span class="line">            tmp/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mxlen is big enough, so tmp will be 0 after the loop</span></span><br><span class="line">        j=mxlen<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(catalan[i][j]==<span class="number">0</span>) j--;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            tmp = tmp*<span class="number">10</span>+catalan[i][j];</span><br><span class="line">            catalan[i][j--] = tmp/(i+<span class="number">1</span>);  </span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;=i+<span class="number">1</span>) tmp%=(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Catalan number is a integer, so remain is 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pre_work</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="type">int</span> i = mxlen<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(catalan[n][i]==<span class="number">0</span>) i--;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,catalan[n][i--]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;High-precision-Catalan-number&quot;&gt;&lt;a href=&quot;#High-precision-Catalan-number&quot; class=&quot;headerlink&quot; title=&quot;High-precision Catalan</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="卡特兰数" scheme="https://blog.whff521.xyz/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    
  </entry>
  
</feed>
