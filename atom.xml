<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AiRomance</title>
  <icon>https://blog.whff521.xyz/images/101.ico</icon>
  <subtitle>爱裸漫三三</subtitle>
  <link href="https://blog.whff521.xyz/atom.xml" rel="self"/>
  <link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
  <link href="https://blog.whff521.xyz/"/>
  <updated>2024-10-12T09:18:02.308Z</updated>
  <id>https://blog.whff521.xyz/</id>
  
  <author>
    <name>AiRomance</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HDU 1024 M子段和最大</title>
    <link href="https://blog.whff521.xyz/2024/10/12/HDU-1024-M%E5%AD%90%E6%AE%B5%E5%92%8C%E6%9C%80%E5%A4%A7/"/>
    <id>https://blog.whff521.xyz/2024/10/12/HDU-1024-M%E5%AD%90%E6%AE%B5%E5%92%8C%E6%9C%80%E5%A4%A7/</id>
    <published>2024-10-12T08:13:56.000Z</published>
    <updated>2024-10-12T09:18:02.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="M子段和最大问题"><a href="#M子段和最大问题" class="headerlink" title="M子段和最大问题"></a>M子段和最大问题</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1024">Problem Link</a></p><p>Given an array and divide into m sequences. One sequences at least has one number and the sequences can’t contain the number with same index. And the index of the numbers in one sequence should be continuous. Notice that we don’t have to use all the numbers.</p><p>N between 1 to 1e6.</p><h2 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="SOLUTION"></a>SOLUTION</h2><p><strong><code>Dynamic programming</code></strong>. </p><p>Let <code>d[i][j]</code> denote the maximum sum of the current array that is divided into i segments and the last segment ends with the jth number. </p><p>When comes to the jth number, we have two options. One is the jth number to be a new segments, the other is to add it to the back of the last segment which ends with (j-1)th number.</p><p>So the transfer equation is <code>dp[i][j]=max(pre_max+a[j],dp[i][j-1]+a[j])</code>. <code>pre_max</code> represents to the maximum answer that the pre array divided into <code>i-1</code> segments.</p><p><a href="https://blog.csdn.net/winter2121/article/details/72848482">Reference blog</a></p><p><img src="https://images.whff521.top/hdu-1024.jpg" alt="Reference Image"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll dp[mxlen];</span><br><span class="line">ll a[mxlen];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="comment">// 用memset会超时</span></span><br><span class="line">        <span class="comment">//memset(dp,0,sizeof(dp));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            ll pre = dp[i<span class="number">-1</span>];</span><br><span class="line">            ll pre_max = -inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n-m+i;j++)&#123;</span><br><span class="line">                pre_max = <span class="built_in">max</span>(pre_max,pre);</span><br><span class="line">                pre = dp[j];</span><br><span class="line">                <span class="keyword">if</span>(j!=i) dp[j] = <span class="built_in">max</span>(pre_max,dp[j<span class="number">-1</span>])+a[j];</span><br><span class="line">                <span class="keyword">else</span> dp[j] = pre_max+a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = -inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m;i&lt;=n;i++)&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;M子段和最大问题&quot;&gt;&lt;a href=&quot;#M子段和最大问题&quot; class=&quot;headerlink&quot; title=&quot;M子段和最大问题&quot;&gt;&lt;/a&gt;M子段和最大问题&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="子段和" scheme="https://blog.whff521.xyz/tags/%E5%AD%90%E6%AE%B5%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1029 寻找数列主元素</title>
    <link href="https://blog.whff521.xyz/2024/10/08/HDU-1029-%E5%AF%BB%E6%89%BE%E6%95%B0%E5%88%97%E4%B8%BB%E5%85%83%E7%B4%A0/"/>
    <id>https://blog.whff521.xyz/2024/10/08/HDU-1029-%E5%AF%BB%E6%89%BE%E6%95%B0%E5%88%97%E4%B8%BB%E5%85%83%E7%B4%A0/</id>
    <published>2024-10-08T09:17:36.000Z</published>
    <updated>2024-10-08T09:38:41.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寻找数列主元素"><a href="#寻找数列主元素" class="headerlink" title="寻找数列主元素"></a>寻找数列主元素</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1029">Problem link</a></p><p>Finding a integer that appears at least (N+1)&#x2F;2 times in the array.</p><h2 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h2><p>The <strong>Boyer-Moore Voting Algorithm</strong> (Moore’s Voting Algorithm) is a highly efficient method to find the majority element in a sequence (an element that appears more than half the time). It operates in <strong>O(n) time</strong> and uses <strong>O(1) space</strong>.</p><h3 id="Key-Idea"><a href="#Key-Idea" class="headerlink" title="Key Idea:"></a>Key Idea:</h3><p>The algorithm works by maintaining a <strong>candidate</strong> for the majority element and a <strong>counter</strong> to track its occurrences. It leverages a “pairing” or “cancellation” mechanism to eliminate non-majority elements.</p><h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps:"></a>Steps:</h3><ol><li><strong>Initialize</strong>:<ul><li>Set the <code>candidate</code> to <code>None</code> and the <code>count</code> to <code>0</code>.</li></ul></li><li><strong>First Pass (Finding the Candidate)</strong>:<ul><li>Traverse the array:<ul><li>If <code>count == 0</code>, set the current element as the <code>candidate</code> and set <code>count = 1</code>.</li><li>If the current element matches the <code>candidate</code>, increment <code>count</code>.</li><li>If the current element differs from the <code>candidate</code>, decrement <code>count</code>.</li></ul></li></ul></li><li><strong>Second Pass (Validation)</strong>:<ul><li>After completing the first pass, the <code>candidate</code> is the potential majority element. To confirm, traverse the array again and count the occurrences of the <code>candidate</code>. If it appears more than half the time, it is the majority element; otherwise, there is no majority element.</li></ul></li></ol><h3 id="Time-and-Space-Complexity"><a href="#Time-and-Space-Complexity" class="headerlink" title="Time and Space Complexity:"></a>Time and Space Complexity:</h3><ul><li><strong>Time Complexity</strong>: O(n) – two passes through the array.</li><li><strong>Space Complexity</strong>: O(1) – constant space is used for the <code>candidate</code> and <code>count</code>.</li></ul><h3 id="Key-Reasons-for-its-Effectiveness"><a href="#Key-Reasons-for-its-Effectiveness" class="headerlink" title="Key Reasons for its Effectiveness:"></a>Key Reasons for its Effectiveness:</h3><h4 id="1-Majority-Element-Dominates"><a href="#1-Majority-Element-Dominates" class="headerlink" title="1. Majority Element Dominates:"></a>1. <strong>Majority Element Dominates</strong>:</h4><p>If there is a majority element, it must appear <strong>more than half</strong> the time in the array. Let’s say the majority element is <code>M</code>, and the number of occurrences of <code>M</code> is greater than half of the total elements in the array (i.e., <code>count(M) &gt; n/2</code>). </p><p>In any process of matching pairs of elements, <code>M</code> will never be fully canceled out because it occurs more frequently than any other element.</p><h4 id="2-Cancellation-Process"><a href="#2-Cancellation-Process" class="headerlink" title="2. Cancellation Process:"></a>2. <strong>Cancellation Process</strong>:</h4><p>During the first pass, the algorithm essentially “cancels out” elements that are different from each other by using the <code>count</code> to increase and decrease based on whether an element matches the current candidate.</p><ul><li>Every time an element that is <strong>not the candidate</strong> is encountered, the <code>count</code> is decreased, effectively <strong>canceling out</strong> both the current candidate and the opposing element.</li><li>When the <code>count</code> reaches zero, a new candidate is chosen. This new candidate can still be the majority element or a temporary placeholder if more occurrences of the majority element appear later.</li></ul><p>This step ensures that elements that appear fewer times will eventually be canceled out by the majority element.</p><h4 id="3-Why-the-Majority-Element-Survives"><a href="#3-Why-the-Majority-Element-Survives" class="headerlink" title="3. Why the Majority Element Survives:"></a>3. <strong>Why the Majority Element Survives</strong>:</h4><p>The majority element will <strong>not be canceled out completely</strong> because it appears more than half the time. Even though other elements may reduce the <code>count</code> temporarily, the majority element’s higher frequency ensures that it will eventually remain as the candidate by the end of the first pass.</p><h3 id="Example-Walkthrough"><a href="#Example-Walkthrough" class="headerlink" title="Example Walkthrough:"></a>Example Walkthrough:</h3><p>Consider an array <code>[2, 2, 1, 1, 1, 2, 2]</code>:</p><ol><li>Initial <code>candidate = None</code>, <code>count = 0</code>.</li><li>First element <code>2</code>: <code>count == 0</code>, so <code>candidate = 2</code>, <code>count = 1</code>.</li><li>Second element <code>2</code>: <code>candidate == 2</code>, <code>count = 2</code>.</li><li>Third element <code>1</code>: <code>candidate != 1</code>, <code>count = 1</code>.</li><li>Fourth element <code>1</code>: <code>candidate != 1</code>, <code>count = 0</code>.</li><li>Fifth element <code>1</code>: <code>count == 0</code>, so <code>candidate = 1</code>, <code>count = 1</code>.</li><li>Sixth element <code>2</code>: <code>candidate != 2</code>, <code>count = 0</code>.</li><li>Seventh element <code>2</code>: <code>count == 0</code>, so <code>candidate = 2</code>, <code>count = 1</code>.</li></ol><p>After this, <code>candidate = 2</code>. In the verification step, <code>2</code> appears 4 times, which is more than <code>n/2 = 3.5</code>, confirming it is the majority element.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>This problem guarantees that there will be an answer. So we don’t need the step of check.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        ll x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">                ans = x;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans==x)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;寻找数列主元素&quot;&gt;&lt;a href=&quot;#寻找数列主元素&quot; class=&quot;headerlink&quot; title=&quot;寻找数列主元素&quot;&gt;&lt;/a&gt;寻找数列主元素&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="摩尔投票法" scheme="https://blog.whff521.xyz/tags/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1465 (错位排列问题)</title>
    <link href="https://blog.whff521.xyz/2024/09/23/HDU-1465-%E9%94%99%E4%BD%8D%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.whff521.xyz/2024/09/23/HDU-1465-%E9%94%99%E4%BD%8D%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</id>
    <published>2024-09-23T06:13:33.000Z</published>
    <updated>2024-09-24T04:24:31.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Derangement-Problem"><a href="#Derangement-Problem" class="headerlink" title="Derangement Problem"></a>Derangement Problem</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1465">problem link</a></p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>You have <code>n</code> letters, each with a different recipient. However, all the letters are delivered to the wrong recipients, meaning no one receives the letter intended for them. You need to determine how many possible ways this can happen.</p><p>This problem can be simplified to a case where you have an array of numbers from 1 to n. For each position in the array(starting from index 1), the number in that position is different from its index. The goal is to count how many such arrangement exist.</p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>This is a classic <strong>derangement</strong> problem. You can find a more detailed explanation on <a href="https://oi-wiki.org/math/combinatorics/derangement/">oi-wiki</a> and <a href="https://en.wikipedia.org/wiki/Derangement">wikipedia</a>.</p><p>I solved the problem using a recursive approach. Let<code>D[i]</code>represent the number of derangements when <code>n = i</code>. The recursive formula is: <code>D[i]=(i-1)D[i-1]+(i-1)D[i-2]</code>.</p><p>Here’s an explanation of the formula:</p><p>Assume we already know the answers for <code>i-1</code>. Now, we add the <code>i-th</code> number to the sequence in the <code>i-th</code> position. Since the number in each position must differ from the position itself, we need to swap <code>i</code> with a number in the previous positions. The first case is where all of the previous <code>i-1</code> numbers are already deranged, so we can swap <code>i</code> with any of them, giving us <code>(i-1)D[i-1]</code> possibilities. The second case is where <code>i-2</code> numbers are deranged, but one number matches its index. In this case, we swap <code>i</code> with that number, which gives us <code>(i-1)D[i-2]</code> possibilities.</p><p><img src="https://images.whff521.top/Dislocation.jpg" alt="dislocation"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll a[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;=<span class="number">20</span>;i++)&#123;</span><br><span class="line">        a[i] = (i<span class="number">-1</span>)*(a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Derangement-Problem&quot;&gt;&lt;a href=&quot;#Derangement-Problem&quot; class=&quot;headerlink&quot; title=&quot;Derangement Problem&quot;&gt;&lt;/a&gt;Derangement</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="数论" scheme="https://blog.whff521.xyz/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="错位排列" scheme="https://blog.whff521.xyz/tags/%E9%94%99%E4%BD%8D%E6%8E%92%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Notes of Lecture 23: Computational Complexity</title>
    <link href="https://blog.whff521.xyz/2024/09/21/Notes-of-Lecture-23-Computational-Complexity/"/>
    <id>https://blog.whff521.xyz/2024/09/21/Notes-of-Lecture-23-Computational-Complexity/</id>
    <published>2024-09-21T11:19:41.000Z</published>
    <updated>2024-09-21T14:24:21.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Notes-of-Lecture-23-Computational-Complexity"><a href="#Notes-of-Lecture-23-Computational-Complexity" class="headerlink" title="Notes of Lecture 23: Computational Complexity"></a>Notes of Lecture 23: Computational Complexity</h1><p><a href="https://youtu.be/moPtwq_cVH8?si=u92BMoXF0Yqg1YH5">video link</a></p><h2 id="P-EXP-R"><a href="#P-EXP-R" class="headerlink" title="P,EXP,R"></a>P,EXP,R</h2><p>P &#x3D; {problems solvable in at most(&lt;&#x3D;) polynomial time}</p><p>EXP &#x3D; {problems solvable in exponential(2^$n^c$) time}</p><p>R &#x3D; {problems solvable in finite time}</p><p><img src="https://images.whff521.top/PEXPR.png" alt="P,EXP,R"></p><p>The axis is computational difficulty.</p><h2 id="Most-problems-uncomputable"><a href="#Most-problems-uncomputable" class="headerlink" title="Most problems uncomputable"></a>Most problems uncomputable</h2><p>Examples:</p><ul><li>negative-weight cycle detection (P)</li><li>NxN Chess (EXP&amp;!P)</li><li>Tetris (EXP, don’t know whether is P)</li><li>halting problem: given program, does it ever halt&#x2F;stop? (not in R)</li></ul><p>Most decision problems are uncomputable (not in R)</p><ul><li>program $\approx$ binary string $\approx$ natural number (integer)</li><li>decision problem &#x3D; function : input($\approx$ binary string (N)) -&gt;{yes(1),no(0)}</li></ul><p>So decision problem is in $\mathbb{R}$;</p><p>$|\mathbb{R}|$ &gt;&gt; $|\mathbb{N}|$ &#x3D;&gt; almost every problem unsolvable by any program</p><h2 id="NP"><a href="#NP" class="headerlink" title="NP"></a>NP</h2><p>NP &#x3D; {decision problems solvable in polynomial time via a “lucky” algorithm}</p><ul><li><p>nondeterministic model : algorithm makes guesses &amp; says YES&#x2F;NO.</p></li><li><p>guesses are guaranteed to lead to “YES” if possible </p></li><li><p>Tetris is NP</p></li></ul><p>proof &#x3D; sequence of moves to make</p><p>NP &#x3D; {decision problems with “solutions” that can be “checked” in polynomial time}</p><ul><li>When answer &#x3D; YES, can prove it &amp; check proof in polynomial time.</li></ul><h2 id="Hardness-Completeness"><a href="#Hardness-Completeness" class="headerlink" title="Hardness &amp; Completeness"></a>Hardness &amp; Completeness</h2><p>P!&#x3D;NP : big conjecture $\approx$ “can’t engineer luck” $\approx$ generating (proofs of) solutions can be harder than checking them.</p><p>Claim: if P!&#x3D;NP then Tetris is NP-P &#x3D;&gt; not in P.</p><p>Why? Tetris is NP-hard(as hard as every problem which is NP)</p><ul><li>in fact Tetris is NP-complete &#x3D; NP $\cap$ NP-hard</li></ul><p><img src="https://images.whff521.top/NPwholeAxis.png" alt="whole axis"></p><h2 id="Reductions"><a href="#Reductions" class="headerlink" title="Reductions"></a>Reductions</h2><p>Reductions: A -&gt; B</p><p>convert problem A(don’t know how to solve) into problem B(you know how to solve)</p><ul><li><p>unweighted shortest paths -&gt; weighted shortest paths</p></li><li><p>min-product path -&gt; shortest path</p></li><li><p>longest path -&gt; shortest path</p></li></ul><p>B is as hard ad A</p><p>3- partition [Karp] -&gt; Tetris</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Notes-of-Lecture-23-Computational-Complexity&quot;&gt;&lt;a href=&quot;#Notes-of-Lecture-23-Computational-Complexity&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="摘抄" scheme="https://blog.whff521.xyz/categories/%E6%91%98%E6%8A%84/"/>
    
    
    <category term="NP" scheme="https://blog.whff521.xyz/tags/NP/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1085 multiple knapsack problem</title>
    <link href="https://blog.whff521.xyz/2024/09/19/HDU-1085-multiple-knapsack-problem/"/>
    <id>https://blog.whff521.xyz/2024/09/19/HDU-1085-multiple-knapsack-problem/</id>
    <published>2024-09-19T12:31:59.000Z</published>
    <updated>2024-09-19T13:05:17.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Multiple-Knapsack-Problem"><a href="#Multiple-Knapsack-Problem" class="headerlink" title="Multiple Knapsack Problem"></a>Multiple Knapsack Problem</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1085">problem link</a></p><h2 id="The-Meaning-of-the-problem"><a href="#The-Meaning-of-the-problem" class="headerlink" title="The Meaning of the problem"></a>The Meaning of the problem</h2><p>You have three kinds of coins. Their face values are 1,2 and 5. Of cause you only have a limited number of coins. You need to find the minimum value that you can’t represent exactly with these coins.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>There are  lots of people solve this problem using Generating function. That way is too hard to understand. We just need to think of this problem as a multiple knapsack problem.</p><p>I learned from <a href="https://seramasumi.github.io/docs/Algorithms/mc-%E5%BE%AE%E8%AF%BE%E5%A0%82-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html">this blog</a></p><p><code>dp[j] = 1</code> means that <code>j</code> value can be represent by the coins.</p><p>Set <code>dp[0] = 1</code> initially. And the transfer equation is <code>dp[j] = max(dp[j],dp[j-k*money[i]])</code></p><p>Let’s assume there is only one 1 yuan coin, one 2 yuan coin and one 5 yuan coin. When <code>d[j]</code> need changing, we should see whether <code>d[j-value]</code> can be represent.</p><p>The top row of the table shows the total amount of money. The leftmost column of the table shows the face value of the coins.</p><p>Here’s the picture to show how the sequence is changed.</p><p><img src="https://images.whff521.top/Screenshot%202024-09-19%20at%2020.29.36.png" alt="knapsack sheet"></p><p>The top row of the table shows the total amount of money. The leftmost column of the table shows the face value of the coins.</p><p>The answer is <code>i</code> where <code>dp[i] = 0</code>.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[mxlen];</span><br><span class="line"><span class="type">int</span> num[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> money[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n1,n2,n5;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;num[<span class="number">1</span>],&amp;num[<span class="number">2</span>],&amp;num[<span class="number">3</span>]);        </span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;num[<span class="number">2</span>]==<span class="number">0</span>&amp;&amp;num[<span class="number">3</span>]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> sum = num[<span class="number">1</span>]+<span class="number">2</span>*num[<span class="number">2</span>]+<span class="number">5</span>*num[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 多重背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 倒序是因为我们转移需要上一层的数据，正序的话会改变值从而后面的值更新错误</span></span><br><span class="line">            <span class="comment">// 因为实际上这是用一维数组代替二维数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=money[i];j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k*money[i]&lt;=j&amp;&amp;k&lt;=num[i];k++)&#123;</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j],dp[j-k*money[i]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = sum+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=sum;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[i]) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Multiple-Knapsack-Problem&quot;&gt;&lt;a href=&quot;#Multiple-Knapsack-Problem&quot; class=&quot;headerlink&quot; title=&quot;Multiple Knapsack Problem&quot;&gt;&lt;/a&gt;Multiple</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="多重背包" scheme="https://blog.whff521.xyz/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
</feed>
