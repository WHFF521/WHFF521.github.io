<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AiRomance</title>
  <icon>https://blog.whff521.xyz/images/101.ico</icon>
  <subtitle>爱裸漫三三</subtitle>
  <link href="https://blog.whff521.xyz/atom.xml" rel="self"/>
  <link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
  <link href="https://blog.whff521.xyz/"/>
  <updated>2024-10-30T02:13:42.439Z</updated>
  <id>https://blog.whff521.xyz/</id>
  
  <author>
    <name>AiRomance</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线性表</title>
    <link href="https://blog.whff521.xyz/2024/10/30/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://blog.whff521.xyz/2024/10/30/%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2024-10-30T02:04:39.000Z</published>
    <updated>2024-10-30T02:13:42.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是一种数据结构，表示由<strong>同一类型的元素按顺序排列</strong>的有限集合。线性表中的元素有顺序关系，可以通过顺序号访问。它是最常用的结构之一，常用于实现数据的顺序存储和查找操作。</p><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><p>一个线性表 $( L )$ 可以定义为一个具有相同类型的元素集合，其中第一个元素为 $( a_1 )$，第二个元素为 $( a_2 )$，依次排列，直到第 $( n )$ 个元素 $( a_n )$。线性表的长度是元素的个数，当长度为 0 时，称其为空表。</p><p>在数学上可以表示为：<br>$[ L &#x3D; { a_1, a_2, \dots, a_n } ]$</p><h2 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h2><p>线性表的基本操作主要包括以下几个：</p><ol><li><p><strong>初始化</strong>（Initialization）</p><ul><li>创建一个空的线性表。</li></ul></li><li><p><strong>插入</strong>（Insert）</p><ul><li>将一个新元素插入到线性表的指定位置。插入时，需要将插入位置后的所有元素向后移动。</li></ul></li><li><p><strong>删除</strong>（Delete）</p><ul><li>删除线性表中的指定位置的元素。删除时，需要将删除位置后的所有元素向前移动。</li></ul></li><li><p><strong>查找</strong>（Find&#x2F;Search）</p><ul><li>根据元素的值查找其在表中的位置，或根据位置查找对应的元素值。</li></ul></li><li><p><strong>更新</strong>（Update）</p><ul><li>修改线性表中指定位置的元素值。</li></ul></li><li><p><strong>遍历</strong>（Traverse）</p><ul><li>顺序访问线性表中的每一个元素，通常用于打印或处理每个元素。</li></ul></li><li><p><strong>获取长度</strong>（Length）</p><ul><li>获取线性表中元素的个数。</li></ul></li></ol><h2 id="线性表的实现方式"><a href="#线性表的实现方式" class="headerlink" title="线性表的实现方式"></a>线性表的实现方式</h2><p>线性表的实现通常有两种存储结构：</p><ul><li><strong>顺序存储结构</strong>：使用数组存储元素，适合顺序访问，但插入和删除操作的效率较低。</li><li><strong>链式存储结构</strong>：使用链表存储元素，适合频繁的插入和删除操作，常见的链表类型包括单链表、循环链表和双向链表。</li></ul><h3 id="1-顺序表的实现"><a href="#1-顺序表的实现" class="headerlink" title="1. 顺序表的实现"></a>1. 顺序表的实现</h3><p>顺序表使用数组实现，其特点是可以直接通过索引访问元素，效率高，但插入和删除需要移动元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqList</span>() : <span class="built_in">length</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt; length || length &gt;= MAX_SIZE) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = length; i &gt; pos; --i) data[i] = data[i - <span class="number">1</span>];</span><br><span class="line">        data[pos] = value;</span><br><span class="line">        length++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt;= length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt; length - <span class="number">1</span>; ++i) data[i] = data[i + <span class="number">1</span>];</span><br><span class="line">        length--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">            <span class="keyword">if</span> (data[i] == value) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) std::cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-单链表的实现"><a href="#2-单链表的实现" class="headerlink" title="2. 单链表的实现"></a>2. 单链表的实现</h3><p>单链表由节点构成，适合频繁的插入和删除操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SinglyLinkedList</span>() : <span class="built_in">head</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(value);</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node *prev = <span class="literal">nullptr</span>, *curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr &amp;&amp; curr-&gt;data != value) &#123;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!curr) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prev) prev-&gt;next = curr-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> head = curr-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> curr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">find</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;data == value) <span class="keyword">return</span> curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            std::cout &lt;&lt; curr-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-循环链表的实现"><a href="#3-循环链表的实现" class="headerlink" title="3. 循环链表的实现"></a>3. 循环链表的实现</h3><p>循环链表的最后一个节点指向第一个节点，形成一个循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    CNode* next;</span><br><span class="line">    <span class="built_in">CNode</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CNode* tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircularLinkedList</span>() : <span class="built_in">tail</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        CNode* newNode = <span class="keyword">new</span> <span class="built_in">CNode</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (!tail) &#123;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            tail-&gt;next = tail;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode-&gt;next = tail-&gt;next;</span><br><span class="line">            tail-&gt;next = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tail) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        CNode *curr = tail-&gt;next, *prev = tail;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;data == value) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curr == tail) tail = (tail-&gt;next == tail) ? <span class="literal">nullptr</span> : prev;</span><br><span class="line">                prev-&gt;next = curr-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> curr;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (curr != tail-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">CNode* <span class="title">find</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tail) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        CNode* curr = tail-&gt;next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;data == value) <span class="keyword">return</span> curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (curr != tail-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tail) <span class="keyword">return</span>;</span><br><span class="line">        CNode* curr = tail-&gt;next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; curr-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (curr != tail-&gt;next);</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-双向链表的实现"><a href="#4-双向链表的实现" class="headerlink" title="4. 双向链表的实现"></a>4. 双向链表的实现</h3><p>双向链表每个节点有前驱和后继指针，方便双向遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    DNode* prev;</span><br><span class="line">    DNode* next;</span><br><span class="line">    <span class="built_in">DNode</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DNode* head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DoublyLinkedList</span>() : <span class="built_in">head</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        DNode* newNode = <span class="keyword">new</span> <span class="built_in">DNode</span>(value);</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        <span class="keyword">if</span> (head) head-&gt;prev = newNode;</span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        DNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr &amp;&amp; curr-&gt;data != value) curr = curr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!curr) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;prev) curr-&gt;prev-&gt;next = curr-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> head = curr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;next) curr-&gt;next-&gt;prev = curr-&gt;prev;</span><br><span class="line">        <span class="keyword">delete</span> curr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DNode* <span class="title">find</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        DNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;data == value) <span class="keyword">return</span> curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            std::cout &lt;&lt; curr-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些代码分别实现了顺序表、单链表、循环链表和双向链表的数据结构及其基本操作，适合考试和项目中的线性表应用。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="数据结构" scheme="https://blog.whff521.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="线性表" scheme="https://blog.whff521.xyz/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>CCSP2024 赛后回忆</title>
    <link href="https://blog.whff521.xyz/2024/10/23/CCSP2024-%E8%B5%9B%E5%90%8E%E5%9B%9E%E5%BF%86/"/>
    <id>https://blog.whff521.xyz/2024/10/23/CCSP2024-%E8%B5%9B%E5%90%8E%E5%9B%9E%E5%BF%86/</id>
    <published>2024-10-23T13:00:17.000Z</published>
    <updated>2024-10-24T13:51:37.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CCSP2024-赛后回忆"><a href="#CCSP2024-赛后回忆" class="headerlink" title="CCSP2024 赛后回忆"></a>CCSP2024 赛后回忆</h1><p>这次是在浙江金华的浙江师范大学，虽然说这里可能有一点点偏僻，但是店铺什么的基本都有，奶茶店，肯德基什么的甚至开在了校内。</p><p>这应该是我大学最后一次参加国家级的赛事了吧。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="I-O-任务调度队列"><a href="#I-O-任务调度队列" class="headerlink" title="I&#x2F;O 任务调度队列"></a>I&#x2F;O 任务调度队列</h3><p>按来的时间排个序，奇数放第一个队列，偶数放第二个队列，保证每个任务等待的时间最小就可以了，签到题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t[mxlen];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;t[i];</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">sort</span>(t+<span class="number">1</span>,t+n+<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t[i]&gt;=ans1)&#123;</span><br><span class="line">                    ans1 = t[i]+<span class="number">10</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    ans1 += <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(t[i]&gt;=ans2)&#123;</span><br><span class="line">                    ans2 = t[i]+<span class="number">10</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> ans2 +=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans1&gt;ans2) <span class="built_in">swap</span>(ans1,ans2);</span><br><span class="line">        cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数树"><a href="#数树" class="headerlink" title="数树"></a>数树</h3><p>模拟题？直接按照他说的把功能都写了就行了，记录一下每个节点的父节点是什么。一开始只用了一位数组来记录点和父节点断开，改来改去只有45分。后来突然想到他可能和好多节点都断开，直接用vector存一下就过了。</p><p>第二天听颁奖典礼上讲题解说的是分快树，LCT做。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> pre_ans;</span><br><span class="line"><span class="type">int</span> w[mxlen];</span><br><span class="line"><span class="type">int</span> father[mxlen];</span><br><span class="line"><span class="type">int</span> now_root = <span class="number">1</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; broken[mxlen];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[mxlen];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_relation</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;broken[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(broken[u][i]==v) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_father</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    father[u] = fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check_relation</span>(u,g[u][i])) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">find_father</span>(g[u][i],u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pre_ans) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">return</span> v^pre_ans;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs_weight</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check_relation</span>(u,g[u][i])) <span class="keyword">continue</span>;</span><br><span class="line">        ans+=<span class="built_in">dfs_weight</span>(g[u][i],u,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(w[u]&gt;x) ans++;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_heaviest</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = w[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check_relation</span>(u,g[u][i])) <span class="keyword">continue</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,<span class="built_in">find_heaviest</span>(g[u][i],u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">find_minw_minindex</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    node tmp = &#123;w[u],u&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check_relation</span>(u,g[u][i])) <span class="keyword">continue</span>;</span><br><span class="line">        node son = <span class="built_in">find_minw_minindex</span>(g[u][i],u);</span><br><span class="line">        <span class="keyword">if</span>(son.weight&lt;tmp.weight)&#123;</span><br><span class="line">            tmp.weight = son.weight;</span><br><span class="line">            tmp.index = son.index;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(son.weight==tmp.weight)&#123;</span><br><span class="line">            <span class="keyword">if</span>(son.index&lt;tmp.index)&#123;</span><br><span class="line">                tmp.weight = son.weight;</span><br><span class="line">                tmp.index = son.index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u,x;</span><br><span class="line">    <span class="comment">// ask how many points&#x27; weight more than v in u subtree</span></span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;x;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        x = <span class="built_in">change</span>(x);</span><br><span class="line">        pre_ans = <span class="built_in">dfs_weight</span>(u,father[u],x);</span><br><span class="line">        cout&lt;&lt;pre_ans&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;x;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        x = <span class="built_in">change</span>(x);</span><br><span class="line">        w[u] = x;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;x;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        x = <span class="built_in">change</span>(x);</span><br><span class="line">        n++;</span><br><span class="line">        g[n].<span class="built_in">push_back</span>(u);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(n);</span><br><span class="line">        father[n] = u;</span><br><span class="line">        w[n] = x;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        broken[u].<span class="built_in">push_back</span>(father[u]);</span><br><span class="line">        broken[father[u]].<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="built_in">find_father</span>(u,<span class="number">-1</span>);</span><br><span class="line">        pre_ans = <span class="built_in">find_heaviest</span>(u,father[u]);</span><br><span class="line">        cout&lt;&lt;pre_ans&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">5</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        node temp = <span class="built_in">find_minw_minindex</span>(u,father[u]);</span><br><span class="line">        pre_ans = temp.index;</span><br><span class="line">        cout&lt;&lt;pre_ans&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">6</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        <span class="built_in">find_father</span>(u,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">            g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;w[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">find_father</span>(now_root,<span class="number">-1</span>);</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        pre_ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            cin&gt;&gt;op;</span><br><span class="line">            <span class="built_in">solve</span>(op);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="贝壳统计（shell）"><a href="#贝壳统计（shell）" class="headerlink" title="贝壳统计（shell）"></a>贝壳统计（shell）</h3><p>这题。。。。80分带修莫队板子题。后面插入元素的改了半天都会超时，不懂怎么改。只拿了80分。</p><p>一开始直接暴力做能拿40分。我看这1e5的数据，两维数组都开不了，也没办法记忆化，就想起来了之前看过的快慢指针，我拿两个指针来回记录时间应该会小一点，很遗憾还是40分。我看着我写的<code>pre_l--</code>和<code>pre_r++</code>越看越熟悉，，，这不就是莫队吗？？？？！！！还好这比赛让带U盘，然后我点开里面的模版（赛前都没看过，不知道从哪里下的了都），直接目录直达带修莫队，ubuntu里复制pdf里代码到vscode里缩进都没了，我也没管，粘过来改改变量名称直接就拿了80分。</p><p>第二天题解讲的是线段树什么的维护增加位置的个数，把添加的数改为负数，还没插入的为负数不用管，好像有点道理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e5</span>+<span class="number">1e4</span>+<span class="number">15</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[mxlen*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> block = <span class="number">2589</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span>&#123;</span><br><span class="line">    <span class="type">int</span> id,l,r,t;</span><br><span class="line">&#125;q[mxlen];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Modify</span>&#123;</span><br><span class="line">    <span class="type">int</span> pos,col,lst;</span><br><span class="line">&#125;c[mxlen];</span><br><span class="line"><span class="type">int</span> cnt[mxlen];</span><br><span class="line"><span class="type">int</span> bi[mxlen];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Query &amp;a, <span class="type">const</span> Query &amp;b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> al = bi[a.l], ar = bi[a.r];</span><br><span class="line"><span class="type">int</span> bl = bi[b.l], br = bi[b.r];</span><br><span class="line"><span class="keyword">if</span>(al != bl)<span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line"><span class="keyword">if</span>(ar != br)<span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line"><span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[x] == <span class="number">0</span>)res ++ ;</span><br><span class="line">cnt[x] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">cnt[x] -- ;</span><br><span class="line"><span class="keyword">if</span>(cnt[x] == <span class="number">0</span>)res -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mq = <span class="number">0</span>,mc = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans[mxlen];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> res)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(res&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">res=-res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(res&gt;<span class="number">9</span>)</span><br><span class="line"><span class="built_in">write</span>(res/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(res%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modui</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">    bi[i] = (i - <span class="number">1</span>) / block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + mq, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> k = <span class="number">1</span>, i = <span class="number">0</span>, j = <span class="number">1</span>, t = <span class="number">0</span>, res = <span class="number">0</span>; k &lt;= mq; ++ k)&#123;</span><br><span class="line">        <span class="type">int</span> id = q[k].id, l = q[k].l, r = q[k].r, tim = q[k].t;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; r)res += ++ cnt[a[ ++ i]] == <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; r)res -= -- cnt[a[i -- ]] == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; l)res -= -- cnt[a[j ++ ]] == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &gt; l)res += ++ cnt[a[ -- j]] == <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//再处理y轴</span></span><br><span class="line">    <span class="keyword">while</span>(t &lt; tim)&#123;</span><br><span class="line">    t ++ ;</span><br><span class="line">    <span class="keyword">if</span>(c[t].pos &gt;= j &amp;&amp; c[t].pos &lt;= i)&#123;</span><br><span class="line">    <span class="built_in">del</span>(a[c[t].pos], res);</span><br><span class="line">    <span class="built_in">add</span>(c[t].col, res);</span><br><span class="line">    <span class="comment">//res -= !--cnt[w[c[t].pos]] - !cnt[c[t].col]++;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[c[t].pos], c[t].col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t &gt; tim)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c[t].pos &gt;= j &amp;&amp; c[t].pos &lt;= i)&#123;</span><br><span class="line">    <span class="built_in">del</span>(a[c[t].pos], res);</span><br><span class="line">    <span class="built_in">add</span>(c[t].col, res);</span><br><span class="line">    <span class="comment">//res -= !--cnt[w[c[t].pos]] - !cnt[c[t].col]++;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[c[t].pos], c[t].col);</span><br><span class="line">    t -- ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[id] = res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=mq;i++)&#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i]), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_large</span><span class="params">(<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> L,R;</span><br><span class="line">        cin&gt;&gt;L&gt;&gt;R;</span><br><span class="line">        q[++mq] = (Query)&#123;mq,L,R,mc&#125;;        </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> P,V;</span><br><span class="line">        cin&gt;&gt;P&gt;&gt;V;</span><br><span class="line">        c[++mc] = (Modify)&#123;P,V&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">modui</span>();</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        mq = <span class="number">0</span>;</span><br><span class="line">        mc = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> P,V;</span><br><span class="line">        cin&gt;&gt;P&gt;&gt;V;</span><br><span class="line">        n++;</span><br><span class="line">       a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+P,V);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1e4</span>)&#123;</span><br><span class="line">        <span class="built_in">solve_large</span>(op);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> L,R;</span><br><span class="line">        cin&gt;&gt;L&gt;&gt;R;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=L;i&lt;=R;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[a[i]])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                vis[a[i]]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> P,V;</span><br><span class="line">        cin&gt;&gt;P&gt;&gt;V;</span><br><span class="line">        a[P] = V;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> P,V;</span><br><span class="line">        cin&gt;&gt;P&gt;&gt;V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        a.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            a.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            cin&gt;&gt;op;</span><br><span class="line">            <span class="built_in">solve</span>(op);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">1e4</span>&amp;&amp;op!=<span class="number">3</span>) <span class="built_in">modui</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>后两题真的折磨，光输入都差不多写了100多行，然而就只拿到了10分，这里就不贴代码了。我觉得要是平时写过系统相关的代码应该很快能写出来，我看有人很快就写完了。我调了半天真的有点崩溃了，看了看排行榜感觉再努力也进不了金牌了，还是早早收场就提前出来了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后是拿了290分，差十分银。这次可以说是大意失荆州——骄兵必败了。六点半的时候还排在银奖队伍中前部位，因为七点后就封傍了，我觉得就算有人后面写出来后两题也不至于把我退到铜吧（请不要学我。。。）。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;CCSP2024-赛后回忆&quot;&gt;&lt;a href=&quot;#CCSP2024-赛后回忆&quot; class=&quot;headerlink&quot; title=&quot;CCSP2024 赛后回忆&quot;&gt;&lt;/a&gt;CCSP2024</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="CCSP" scheme="https://blog.whff521.xyz/tags/CCSP/"/>
    
  </entry>
  
  <entry>
    <title>HDU 4870 概率DP</title>
    <link href="https://blog.whff521.xyz/2024/10/15/HDU-4870-%E6%A6%82%E7%8E%87DP/"/>
    <id>https://blog.whff521.xyz/2024/10/15/HDU-4870-%E6%A6%82%E7%8E%87DP/</id>
    <published>2024-10-15T07:39:36.000Z</published>
    <updated>2024-10-15T07:57:54.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HDU-4870-概率DP"><a href="#HDU-4870-概率DP" class="headerlink" title="HDU 4870 概率DP"></a>HDU 4870 概率DP</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=4870">Problem Link</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>新账号打rank，rank从0开始，打到1000分结束。每场rank增加50的概率为p，否则rank-100。新人用两个信号去打，每次用rank值低的账号，问任意一个账号达到rank1000分，新人要打的期望场数。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p><a href="https://www.cnblogs.com/philo-zhou/p/11330699.html">参考博客</a></p><p>将分数离散为赢了加1分，输了减2分。用<code>dp[i]</code>表示从i-1分到i分需要打的期望场数。</p><p>每次比赛有两种情况，一是p概率赢了加1分，二是(1-p)概率输了减2分。</p><p><code>dp[i]=1*p+(1-p)(1+dp[i-2]+dp[i-1]+dp[i])</code></p><p>期望等于所有情况乘以概率的和。</p><ul><li>一场就赢了，则是<code>1*p</code></li><li>一场输了，则需要<code>(1+dp[i-2]+dp[i-1]+dp[i])</code>场才能赢回来。其中1是输了这场，然后从<code>i-3</code>打到<code>i-2</code>,从<code>i-2</code>打到<code>i-1</code>，从<code>i-1</code>打到<code>i</code>分。</li></ul><p>化简得</p><p><code>dp[i]=(1+(1-p)*(dp[i-2]+dp[i-1]))/p</code></p><p><code>dp[1] = 1/p, dp[2] = 1/p/p</code></p><p>注意，因为最低分是0分，所以计算<code>dp[1]</code>和<code>dp[2]</code>的时候公式里填0补充。</p><p>用<code>tot</code>记录每一分需要的场数，因为有两个账号，且每次都是用分数低的，所以最后一定是一个账号1000分，另一个账号950分。我们计算两个账号都是1000分需要的场数，即<code>tot*2</code>，然后减去一个950分到1000分的期望场数(<code>dp[20]</code>)，即是答案。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">25</span>;</span><br><span class="line"><span class="type">double</span> dp[mxlen];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> p;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;p)!=EOF)&#123;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>/p;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>/p/p;</span><br><span class="line">        <span class="type">double</span> tot = dp[<span class="number">1</span>]+dp[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">20</span>;i++)&#123;</span><br><span class="line">            dp[i] = (<span class="number">1</span>+(<span class="number">1</span>-p)*(dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]))/p;</span><br><span class="line">            tot += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>,<span class="number">2</span>*tot-dp[<span class="number">20</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;HDU-4870-概率DP&quot;&gt;&lt;a href=&quot;#HDU-4870-概率DP&quot; class=&quot;headerlink&quot; title=&quot;HDU 4870 概率DP&quot;&gt;&lt;/a&gt;HDU 4870 概率DP&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="DP" scheme="https://blog.whff521.xyz/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1024 M子段和最大</title>
    <link href="https://blog.whff521.xyz/2024/10/12/HDU-1024-M%E5%AD%90%E6%AE%B5%E5%92%8C%E6%9C%80%E5%A4%A7/"/>
    <id>https://blog.whff521.xyz/2024/10/12/HDU-1024-M%E5%AD%90%E6%AE%B5%E5%92%8C%E6%9C%80%E5%A4%A7/</id>
    <published>2024-10-12T08:13:56.000Z</published>
    <updated>2024-10-12T09:18:02.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="M子段和最大问题"><a href="#M子段和最大问题" class="headerlink" title="M子段和最大问题"></a>M子段和最大问题</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1024">Problem Link</a></p><p>Given an array and divide into m sequences. One sequences at least has one number and the sequences can’t contain the number with same index. And the index of the numbers in one sequence should be continuous. Notice that we don’t have to use all the numbers.</p><p>N between 1 to 1e6.</p><h2 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="SOLUTION"></a>SOLUTION</h2><p><strong><code>Dynamic programming</code></strong>. </p><p>Let <code>d[i][j]</code> denote the maximum sum of the current array that is divided into i segments and the last segment ends with the jth number. </p><p>When comes to the jth number, we have two options. One is the jth number to be a new segments, the other is to add it to the back of the last segment which ends with (j-1)th number.</p><p>So the transfer equation is <code>dp[i][j]=max(pre_max+a[j],dp[i][j-1]+a[j])</code>. <code>pre_max</code> represents to the maximum answer that the pre array divided into <code>i-1</code> segments.</p><p><a href="https://blog.csdn.net/winter2121/article/details/72848482">Reference blog</a></p><p><img src="https://images.whff521.top/hdu-1024.jpg" alt="Reference Image"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll dp[mxlen];</span><br><span class="line">ll a[mxlen];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="comment">// 用memset会超时</span></span><br><span class="line">        <span class="comment">//memset(dp,0,sizeof(dp));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            ll pre = dp[i<span class="number">-1</span>];</span><br><span class="line">            ll pre_max = -inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n-m+i;j++)&#123;</span><br><span class="line">                pre_max = <span class="built_in">max</span>(pre_max,pre);</span><br><span class="line">                pre = dp[j];</span><br><span class="line">                <span class="keyword">if</span>(j!=i) dp[j] = <span class="built_in">max</span>(pre_max,dp[j<span class="number">-1</span>])+a[j];</span><br><span class="line">                <span class="keyword">else</span> dp[j] = pre_max+a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = -inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m;i&lt;=n;i++)&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;M子段和最大问题&quot;&gt;&lt;a href=&quot;#M子段和最大问题&quot; class=&quot;headerlink&quot; title=&quot;M子段和最大问题&quot;&gt;&lt;/a&gt;M子段和最大问题&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="子段和" scheme="https://blog.whff521.xyz/tags/%E5%AD%90%E6%AE%B5%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1029 寻找数列主元素</title>
    <link href="https://blog.whff521.xyz/2024/10/08/HDU-1029-%E5%AF%BB%E6%89%BE%E6%95%B0%E5%88%97%E4%B8%BB%E5%85%83%E7%B4%A0/"/>
    <id>https://blog.whff521.xyz/2024/10/08/HDU-1029-%E5%AF%BB%E6%89%BE%E6%95%B0%E5%88%97%E4%B8%BB%E5%85%83%E7%B4%A0/</id>
    <published>2024-10-08T09:17:36.000Z</published>
    <updated>2024-10-08T09:38:41.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寻找数列主元素"><a href="#寻找数列主元素" class="headerlink" title="寻找数列主元素"></a>寻找数列主元素</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1029">Problem link</a></p><p>Finding a integer that appears at least (N+1)&#x2F;2 times in the array.</p><h2 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h2><p>The <strong>Boyer-Moore Voting Algorithm</strong> (Moore’s Voting Algorithm) is a highly efficient method to find the majority element in a sequence (an element that appears more than half the time). It operates in <strong>O(n) time</strong> and uses <strong>O(1) space</strong>.</p><h3 id="Key-Idea"><a href="#Key-Idea" class="headerlink" title="Key Idea:"></a>Key Idea:</h3><p>The algorithm works by maintaining a <strong>candidate</strong> for the majority element and a <strong>counter</strong> to track its occurrences. It leverages a “pairing” or “cancellation” mechanism to eliminate non-majority elements.</p><h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps:"></a>Steps:</h3><ol><li><strong>Initialize</strong>:<ul><li>Set the <code>candidate</code> to <code>None</code> and the <code>count</code> to <code>0</code>.</li></ul></li><li><strong>First Pass (Finding the Candidate)</strong>:<ul><li>Traverse the array:<ul><li>If <code>count == 0</code>, set the current element as the <code>candidate</code> and set <code>count = 1</code>.</li><li>If the current element matches the <code>candidate</code>, increment <code>count</code>.</li><li>If the current element differs from the <code>candidate</code>, decrement <code>count</code>.</li></ul></li></ul></li><li><strong>Second Pass (Validation)</strong>:<ul><li>After completing the first pass, the <code>candidate</code> is the potential majority element. To confirm, traverse the array again and count the occurrences of the <code>candidate</code>. If it appears more than half the time, it is the majority element; otherwise, there is no majority element.</li></ul></li></ol><h3 id="Time-and-Space-Complexity"><a href="#Time-and-Space-Complexity" class="headerlink" title="Time and Space Complexity:"></a>Time and Space Complexity:</h3><ul><li><strong>Time Complexity</strong>: O(n) – two passes through the array.</li><li><strong>Space Complexity</strong>: O(1) – constant space is used for the <code>candidate</code> and <code>count</code>.</li></ul><h3 id="Key-Reasons-for-its-Effectiveness"><a href="#Key-Reasons-for-its-Effectiveness" class="headerlink" title="Key Reasons for its Effectiveness:"></a>Key Reasons for its Effectiveness:</h3><h4 id="1-Majority-Element-Dominates"><a href="#1-Majority-Element-Dominates" class="headerlink" title="1. Majority Element Dominates:"></a>1. <strong>Majority Element Dominates</strong>:</h4><p>If there is a majority element, it must appear <strong>more than half</strong> the time in the array. Let’s say the majority element is <code>M</code>, and the number of occurrences of <code>M</code> is greater than half of the total elements in the array (i.e., <code>count(M) &gt; n/2</code>). </p><p>In any process of matching pairs of elements, <code>M</code> will never be fully canceled out because it occurs more frequently than any other element.</p><h4 id="2-Cancellation-Process"><a href="#2-Cancellation-Process" class="headerlink" title="2. Cancellation Process:"></a>2. <strong>Cancellation Process</strong>:</h4><p>During the first pass, the algorithm essentially “cancels out” elements that are different from each other by using the <code>count</code> to increase and decrease based on whether an element matches the current candidate.</p><ul><li>Every time an element that is <strong>not the candidate</strong> is encountered, the <code>count</code> is decreased, effectively <strong>canceling out</strong> both the current candidate and the opposing element.</li><li>When the <code>count</code> reaches zero, a new candidate is chosen. This new candidate can still be the majority element or a temporary placeholder if more occurrences of the majority element appear later.</li></ul><p>This step ensures that elements that appear fewer times will eventually be canceled out by the majority element.</p><h4 id="3-Why-the-Majority-Element-Survives"><a href="#3-Why-the-Majority-Element-Survives" class="headerlink" title="3. Why the Majority Element Survives:"></a>3. <strong>Why the Majority Element Survives</strong>:</h4><p>The majority element will <strong>not be canceled out completely</strong> because it appears more than half the time. Even though other elements may reduce the <code>count</code> temporarily, the majority element’s higher frequency ensures that it will eventually remain as the candidate by the end of the first pass.</p><h3 id="Example-Walkthrough"><a href="#Example-Walkthrough" class="headerlink" title="Example Walkthrough:"></a>Example Walkthrough:</h3><p>Consider an array <code>[2, 2, 1, 1, 1, 2, 2]</code>:</p><ol><li>Initial <code>candidate = None</code>, <code>count = 0</code>.</li><li>First element <code>2</code>: <code>count == 0</code>, so <code>candidate = 2</code>, <code>count = 1</code>.</li><li>Second element <code>2</code>: <code>candidate == 2</code>, <code>count = 2</code>.</li><li>Third element <code>1</code>: <code>candidate != 1</code>, <code>count = 1</code>.</li><li>Fourth element <code>1</code>: <code>candidate != 1</code>, <code>count = 0</code>.</li><li>Fifth element <code>1</code>: <code>count == 0</code>, so <code>candidate = 1</code>, <code>count = 1</code>.</li><li>Sixth element <code>2</code>: <code>candidate != 2</code>, <code>count = 0</code>.</li><li>Seventh element <code>2</code>: <code>count == 0</code>, so <code>candidate = 2</code>, <code>count = 1</code>.</li></ol><p>After this, <code>candidate = 2</code>. In the verification step, <code>2</code> appears 4 times, which is more than <code>n/2 = 3.5</code>, confirming it is the majority element.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>This problem guarantees that there will be an answer. So we don’t need the step of check.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        ll x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">                ans = x;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans==x)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;寻找数列主元素&quot;&gt;&lt;a href=&quot;#寻找数列主元素&quot; class=&quot;headerlink&quot; title=&quot;寻找数列主元素&quot;&gt;&lt;/a&gt;寻找数列主元素&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="摩尔投票法" scheme="https://blog.whff521.xyz/tags/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95/"/>
    
  </entry>
  
</feed>
