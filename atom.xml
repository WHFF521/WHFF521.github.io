<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AiRomance</title>
  <icon>https://blog.whff521.xyz/images/101.ico</icon>
  <subtitle>爱裸漫三三</subtitle>
  <link href="https://blog.whff521.xyz/atom.xml" rel="self"/>
  <link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
  <link href="https://blog.whff521.xyz/"/>
  <updated>2024-09-21T12:46:59.244Z</updated>
  <id>https://blog.whff521.xyz/</id>
  
  <author>
    <name>AiRomance</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Notes of Lecture 23: Computational Complexity</title>
    <link href="https://blog.whff521.xyz/2024/09/21/Notes-of-Lecture-23-Computational-Complexity/"/>
    <id>https://blog.whff521.xyz/2024/09/21/Notes-of-Lecture-23-Computational-Complexity/</id>
    <published>2024-09-21T11:19:41.000Z</published>
    <updated>2024-09-21T12:46:59.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Notes-of-Lecture-23-Computational-Complexity"><a href="#Notes-of-Lecture-23-Computational-Complexity" class="headerlink" title="Notes of Lecture 23: Computational Complexity"></a>Notes of Lecture 23: Computational Complexity</h1><h2 id="P-EXP-R"><a href="#P-EXP-R" class="headerlink" title="P,EXP,R"></a>P,EXP,R</h2><p>P &#x3D; {problems solvable in at most(&lt;&#x3D;) polynomial time}</p><p>EXP &#x3D; {problems solvable in exponential(2^$n^c$) time}</p><p>R &#x3D; {problems solvable in finite time}</p><p><img src="https://images.whff521.top/PEXPR.png" alt="P,EXP,R"></p><p>The axis is computational difficulty.</p><h2 id="Most-problems-uncomputable"><a href="#Most-problems-uncomputable" class="headerlink" title="Most problems uncomputable"></a>Most problems uncomputable</h2><p>Examples:</p><ul><li>negative-weight cycle detection (P)</li><li>NxN Chess (EXP&amp;!P)</li><li>Tetris (EXP, don’t know whether is P)</li><li>halting problem: given program, does it ever halt&#x2F;stop? (not in R)</li></ul><p>Most decision problems are uncomputable (not in R)</p><ul><li>program $\approx$ binary string $\approx$ natural number (integer)</li><li>decision problem &#x3D; function : input($\approx$ binary string (N)) -&gt;{yes(1),no(0)}</li></ul><p>So decision problem is in $\mathbb{R}$;</p><p>$|\mathbb{R}|$ &gt;&gt; $|\mathbb{N}|$ &#x3D;&gt; almost every problem unsolvable by any program</p><h2 id="NP"><a href="#NP" class="headerlink" title="NP"></a>NP</h2><p>NP &#x3D; {decision problems solvable in polynomial time via a “lucky” algorithm}</p><ul><li><p>nondeterministic model : algorithm makes guesses &amp; says YES&#x2F;NO.</p></li><li><p>guesses are guaranteed to lead to “YES” if possible </p></li><li><p>Tetris is NP</p></li></ul><p>proof &#x3D; sequence of moves to make</p><p>NP &#x3D; {decision problems with “solutions” that can be “checked” in polynomial time}</p><ul><li>When answer &#x3D; YES, can prove it &amp; check proof in polynomial time.</li></ul><h2 id="Hardness-Completeness"><a href="#Hardness-Completeness" class="headerlink" title="Hardness &amp; Completeness"></a>Hardness &amp; Completeness</h2><p>P!&#x3D;NP : big conjecture $\approx$ “can’t engineer luck” $\approx$ generating (proofs of) solutions can be harder than checking them.</p><p>Claim: if P!&#x3D;NP then Tetris is NP-P &#x3D;&gt; not in P.</p><p>Why? Tetris is NP-hard(as hard as every problem which is NP)</p><ul><li>in fact Tetris is NP-complete &#x3D; NP $\cap$ NP-hard</li></ul><p><img src="https://images.whff521.top/NPwholeAxis.png" alt="whole axis"></p><h2 id="Reductions"><a href="#Reductions" class="headerlink" title="Reductions"></a>Reductions</h2><p>Reductions: A -&gt; B</p><p>convert problem A(don’t know how to solve) into problem B(you know how to solve)</p><ul><li><p>unweighted shortest paths -&gt; weighted shortest paths</p></li><li><p>min-product path -&gt; shortest path</p></li><li><p>longest path -&gt; shortest path</p></li></ul><p>B is as hard ad A</p><p>3- partition [Karp] -&gt; Tetris</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Notes-of-Lecture-23-Computational-Complexity&quot;&gt;&lt;a href=&quot;#Notes-of-Lecture-23-Computational-Complexity&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="摘抄" scheme="https://blog.whff521.xyz/categories/%E6%91%98%E6%8A%84/"/>
    
    
    <category term="NP" scheme="https://blog.whff521.xyz/tags/NP/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1085 multiple knapsack problem</title>
    <link href="https://blog.whff521.xyz/2024/09/19/HDU-1085-multiple-knapsack-problem/"/>
    <id>https://blog.whff521.xyz/2024/09/19/HDU-1085-multiple-knapsack-problem/</id>
    <published>2024-09-19T12:31:59.000Z</published>
    <updated>2024-09-19T13:05:17.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Multiple-Knapsack-Problem"><a href="#Multiple-Knapsack-Problem" class="headerlink" title="Multiple Knapsack Problem"></a>Multiple Knapsack Problem</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1085">problem link</a></p><h2 id="The-Meaning-of-the-problem"><a href="#The-Meaning-of-the-problem" class="headerlink" title="The Meaning of the problem"></a>The Meaning of the problem</h2><p>You have three kinds of coins. Their face values are 1,2 and 5. Of cause you only have a limited number of coins. You need to find the minimum value that you can’t represent exactly with these coins.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>There are  lots of people solve this problem using Generating function. That way is too hard to understand. We just need to think of this problem as a multiple knapsack problem.</p><p>I learned from <a href="https://seramasumi.github.io/docs/Algorithms/mc-%E5%BE%AE%E8%AF%BE%E5%A0%82-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html">this blog</a></p><p><code>dp[j] = 1</code> means that <code>j</code> value can be represent by the coins.</p><p>Set <code>dp[0] = 1</code> initially. And the transfer equation is <code>dp[j] = max(dp[j],dp[j-k*money[i]])</code></p><p>Let’s assume there is only one 1 yuan coin, one 2 yuan coin and one 5 yuan coin. When <code>d[j]</code> need changing, we should see whether <code>d[j-value]</code> can be represent.</p><p>The top row of the table shows the total amount of money. The leftmost column of the table shows the face value of the coins.</p><p>Here’s the picture to show how the sequence is changed.</p><p><img src="https://images.whff521.top/Screenshot%202024-09-19%20at%2020.29.36.png" alt="knapsack sheet"></p><p>The top row of the table shows the total amount of money. The leftmost column of the table shows the face value of the coins.</p><p>The answer is <code>i</code> where <code>dp[i] = 0</code>.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[mxlen];</span><br><span class="line"><span class="type">int</span> num[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> money[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n1,n2,n5;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;num[<span class="number">1</span>],&amp;num[<span class="number">2</span>],&amp;num[<span class="number">3</span>]);        </span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;num[<span class="number">2</span>]==<span class="number">0</span>&amp;&amp;num[<span class="number">3</span>]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> sum = num[<span class="number">1</span>]+<span class="number">2</span>*num[<span class="number">2</span>]+<span class="number">5</span>*num[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 多重背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 倒序是因为我们转移需要上一层的数据，正序的话会改变值从而后面的值更新错误</span></span><br><span class="line">            <span class="comment">// 因为实际上这是用一维数组代替二维数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=money[i];j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k*money[i]&lt;=j&amp;&amp;k&lt;=num[i];k++)&#123;</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j],dp[j-k*money[i]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = sum+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=sum;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[i]) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Multiple-Knapsack-Problem&quot;&gt;&lt;a href=&quot;#Multiple-Knapsack-Problem&quot; class=&quot;headerlink&quot; title=&quot;Multiple Knapsack Problem&quot;&gt;&lt;/a&gt;Multiple</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="多重背包" scheme="https://blog.whff521.xyz/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1025 longest increasing subsequence</title>
    <link href="https://blog.whff521.xyz/2024/09/17/HDU-1025-longest-increasing-subsequence/"/>
    <id>https://blog.whff521.xyz/2024/09/17/HDU-1025-longest-increasing-subsequence/</id>
    <published>2024-09-17T13:57:39.000Z</published>
    <updated>2024-09-17T14:45:33.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Constructing-Roads-In-JGShining’s-Kingdom"><a href="#Constructing-Roads-In-JGShining’s-Kingdom" class="headerlink" title="Constructing Roads In JGShining’s Kingdom"></a>Constructing Roads In JGShining’s Kingdom</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1025">problem link</a></p><h2 id="The-meaning-of-the-problem"><a href="#The-meaning-of-the-problem" class="headerlink" title="The meaning of the problem"></a>The meaning of the problem</h2><p>So why this is longest increasing subsequence Problem ? Look at the picture below:</p><p><img src="https://images.whff521.top/hdu1025.jpg" alt="hdu1025"></p><p>As the problem described, we can’t have crossed lines. Each line has two endpoints. One is the “rich” endpoint above and the other is the “poor” endpoint below. The rich endpoints’ number of the lines we finally pick up should be <strong>monotonically increasing</strong>. The corresponding poor endpoints should be <strong>monotonically increasing</strong> too. Otherwise the lines will be crossed.</p><p>Let’s use <strong><code>a[p]=q</code> to represent that the p city can link q city</strong>. Then the problem tend to become a question of longest increasing subsequence.</p><h2 id="The-Algorithm"><a href="#The-Algorithm" class="headerlink" title="The Algorithm"></a>The Algorithm</h2><p>There is a quite easy way to understand the LIS problem. I learned it from <a href="https://leetcode.cn/problems/longest-increasing-subsequence/solutions/13118/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/">this tutorial</a></p><blockquote><p>A clever approach. Create a new array <code>cell</code> to store the longest increasing subsequence.  </p><p>Iterate through the original sequence, and binary insert each element into <code>cell</code>.</p><p>If all the elements in <code>cell</code> are smaller than the current one, append it at the end.<br>Otherwise, <strong>replace the smallest element in <code>cell</code> that is larger than the current one</strong>.<br>In short, the idea is to keep <code>cell</code> storing relatively smaller elements. Although <code>cell</code> may not represent the actual longest increasing subsequence, its length is correct.</p><p>Author: ColdMe<br>Link: <a href="https://leetcode.cn/problems/longest-increasing-subsequence/solutions/13118/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/">https://leetcode.cn/problems/longest-increasing-subsequence/solutions/13118/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/</a><br>Source: LeetCode<br>Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please credit the source.</p></blockquote><p>There are ways to prove that the <code>cell</code> array is monotonically increasing. Anything detailed you can see <a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence">Wikipedia</a></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> seq[mxlen];</span><br><span class="line"><span class="type">int</span> a[mxlen];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            a[x]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(seq,<span class="number">0</span>,<span class="built_in">sizeof</span>(seq));</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;seq[len])&#123;</span><br><span class="line">                seq[++len] = a[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> l=<span class="number">1</span>,r=len;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">                    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(seq[mid]&gt;=a[i]) r = mid<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                seq[l] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// When the number of roads is greater than 2, an s needs to be added after the road.</span></span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\nMy king, at most 1 road can be built.\n\n&quot;</span>,++cnt);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\nMy king, at most %d roads can be built.\n\n&quot;</span>,++cnt,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Constructing-Roads-In-JGShining’s-Kingdom&quot;&gt;&lt;a href=&quot;#Constructing-Roads-In-JGShining’s-Kingdom&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="最长上升子序列" scheme="https://blog.whff521.xyz/tags/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1023 Train Problem II 高精度卡特兰数</title>
    <link href="https://blog.whff521.xyz/2024/09/16/HDU-1023-Train-Problem-II-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    <id>https://blog.whff521.xyz/2024/09/16/HDU-1023-Train-Problem-II-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/</id>
    <published>2024-09-16T03:19:59.000Z</published>
    <updated>2024-09-16T03:52:18.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="High-precision-Catalan-number"><a href="#High-precision-Catalan-number" class="headerlink" title="High-precision Catalan number"></a>High-precision Catalan number</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1023">problem link</a></p><p>This is a classic problem of finding the number of stack push ans pop sequences. The only headache is that it requires high precision.</p><h2 id="How-to-determine-whether-it-is-a-Catalan-number"><a href="#How-to-determine-whether-it-is-a-Catalan-number" class="headerlink" title="How to determine whether it is a Catalan number"></a>How to determine whether it is a Catalan number</h2><p>For a more detailed introduction to the Catalan number,see <a href="https://oi-wiki.org/math/combinatorics/catalan/">oi-wiki</a> and <a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0">wikipedia</a></p><p>I think there is another simple way to judge, which is to see whether the first few numbers are consistent with the Catalan number. If they are the same, then it is likely to be a correct guess.</p><p><img src="https://images.whff521.top/catalan.png" alt="截图来自oi-wiki"></p><h2 id="Algortithm-Implementation"><a href="#Algortithm-Implementation" class="headerlink" title="Algortithm Implementation"></a>Algortithm Implementation</h2><p>We use <code>catalan[i][j]</code> to represent the j-th digital of the i-th Catalan number. </p><p>The formula I use is <code>h(n) = (4n-2)*h(n-1)/(n+1)</code>.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> catalan[<span class="number">105</span>][mxlen];</span><br><span class="line"><span class="comment">// catalan[i][j] stores the j-th digit of the i-th catalan number</span></span><br><span class="line"><span class="comment">// h(n) = (4n-2)*h(n-1)/(n+1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    catalan[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;mxlen;j++)&#123;</span><br><span class="line">            tmp+=catalan[i<span class="number">-1</span>][j]*(<span class="number">4</span>*i<span class="number">-2</span>);</span><br><span class="line">            catalan[i][j] = tmp%<span class="number">10</span>;</span><br><span class="line">            tmp/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mxlen is big enough, so tmp will be 0 after the loop</span></span><br><span class="line">        j=mxlen<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(catalan[i][j]==<span class="number">0</span>) j--;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            tmp = tmp*<span class="number">10</span>+catalan[i][j];</span><br><span class="line">            catalan[i][j--] = tmp/(i+<span class="number">1</span>);  </span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;=i+<span class="number">1</span>) tmp%=(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Catalan number is a integer, so remain is 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pre_work</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="type">int</span> i = mxlen<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(catalan[n][i]==<span class="number">0</span>) i--;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,catalan[n][i--]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;High-precision-Catalan-number&quot;&gt;&lt;a href=&quot;#High-precision-Catalan-number&quot; class=&quot;headerlink&quot; title=&quot;High-precision Catalan</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="卡特兰数" scheme="https://blog.whff521.xyz/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1011 Starship Troopers 树形DP</title>
    <link href="https://blog.whff521.xyz/2024/09/13/HDU-1011-Starship-Troopers-%E6%A0%91%E5%BD%A2DP/"/>
    <id>https://blog.whff521.xyz/2024/09/13/HDU-1011-Starship-Troopers-%E6%A0%91%E5%BD%A2DP/</id>
    <published>2024-09-13T07:34:37.000Z</published>
    <updated>2024-09-13T11:24:00.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="答案会比你想象的简单很多"><a href="#答案会比你想象的简单很多" class="headerlink" title="答案会比你想象的简单很多"></a>答案会比你想象的简单很多</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1011">题目链接</a></p><p>这道题最大的障碍应该是猜对题意。。。题里说的“possibility”应该不是真正的相对于人数的概率，而是可以随意相加的数字，你可以直接当成获得这个数量的金币之类的。</p><p>树形迷宫，只要你能放置超过对应数量的士兵在这个节点，你就可以获得这个节点的“possibility”。同时你可以继续向这个节点的子节点进行进攻，你甚至可以兵分几路向下前进。这些被放置的士兵只能留在被放置的节点而不能重复利用。你一共有m个士兵，求出你可以获得的“possibility”的最大值。</p><h2 id="正向思考"><a href="#正向思考" class="headerlink" title="正向思考"></a>正向思考</h2><p>每当你占领一个节点，面临的就是你如何要用剩下的军队，分成几部分去这个节点的子节点。显然正向出发去求你并不知道到底怎样决策才能获得最大价值，因为你甚至还不知道接下来你会面临什么样的节点。</p><h2 id="反向思考"><a href="#反向思考" class="headerlink" title="反向思考"></a>反向思考</h2><p>这就要搬出和深搜常绑定的一个词——“回溯”。我们一路深搜到叶子节点，我们要从终点走到起点。面对只有一个节点，你当然知道你最少需要多少士兵，你最大能获得多少价值。我们用<code>dp[x][i]</code>表示第x节点用掉i个士兵获得的最大的价值。如果当前节点最少需要j个士兵，那么dp[x][j～m]的初始值就是当前节点的价值量。毕竟人少了不行，但是人多了是肯定可以的。</p><p>当两个叶子汇聚到一个父节点应该怎么转移呢？我们需要就将人分成两部分，一部分x个人给一个叶子，一部分y个人给另一个（或者另好几个）叶子，父节点用的人数就是<code>x+y+i</code>个人。因为我们已经知道了每个节点用多少人能够获得多少价值，我们可以枚举所有情况来进行更新最优解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> pre[mxlen*<span class="number">2</span>],last[mxlen],other[mxlen*<span class="number">2</span>],l;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    l++;</span><br><span class="line">    pre[l] = last[x];</span><br><span class="line">    last[x] = l;</span><br><span class="line">    other[l] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dp[mxlen][mxlen];</span><br><span class="line"><span class="type">bool</span> vis[mxlen];</span><br><span class="line"><span class="type">int</span> bugs[mxlen],brains[mxlen];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">    <span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="built_in">sizeof</span>(last));</span><br><span class="line">    <span class="built_in">memset</span>(other,<span class="number">0</span>,<span class="built_in">sizeof</span>(other));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 向上取整</span></span><br><span class="line">    <span class="type">int</span> needed = (bugs[x]+<span class="number">19</span>)/<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=needed;i&lt;=m;i++)&#123;</span><br><span class="line">        dp[x][i] = brains[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=last[x];p;p=pre[p])&#123;</span><br><span class="line">        <span class="type">int</span> y = other[p];</span><br><span class="line">        <span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = m;i&gt;=needed;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i-needed;j++)&#123;</span><br><span class="line">                <span class="comment">//第x节点消耗i个士兵能获得的最大价值</span></span><br><span class="line">                dp[x][i] = <span class="built_in">max</span>(dp[x][i],dp[x][i-j]+dp[y][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">-1</span>&amp;&amp;m==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">prepare</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;bugs[i],&amp;brains[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">add</span>(x,y);</span><br><span class="line">            <span class="built_in">add</span>(y,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        cout&lt;&lt;dp[<span class="number">1</span>][m]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;答案会比你想象的简单很多&quot;&gt;&lt;a href=&quot;#答案会比你想象的简单很多&quot; class=&quot;headerlink&quot; title=&quot;答案会比你想象的简单很多&quot;&gt;&lt;/a&gt;答案会比你想象的简单很多&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="深搜" scheme="https://blog.whff521.xyz/tags/%E6%B7%B1%E6%90%9C/"/>
    
    <category term="动态规划" scheme="https://blog.whff521.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
