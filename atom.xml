<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AiRomance</title>
  <icon>https://blog.whff521.xyz/images/101.ico</icon>
  <subtitle>爱裸漫三三</subtitle>
  <link href="https://blog.whff521.xyz/atom.xml" rel="self"/>
  <link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
  <link href="https://blog.whff521.xyz/"/>
  <updated>2024-10-30T07:53:16.055Z</updated>
  <id>https://blog.whff521.xyz/</id>
  
  <author>
    <name>AiRomance</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>哈希表</title>
    <link href="https://blog.whff521.xyz/2024/10/30/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://blog.whff521.xyz/2024/10/30/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2024-10-30T07:46:43.000Z</published>
    <updated>2024-10-30T07:53:16.055Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表（Hash Table）是一种用于存储键值对的数据结构，可以通过哈希函数快速地根据键找到对应的值。哈希表的查找、插入和删除操作在平均情况下具有 <code>O(1)</code> 的时间复杂度，非常高效。</p><h2 id="1-哈希表的基本概念"><a href="#1-哈希表的基本概念" class="headerlink" title="1. 哈希表的基本概念"></a>1. 哈希表的基本概念</h2><p>哈希表的核心思想是将键通过一个<strong>哈希函数</strong>（Hash Function）映射到一个哈希表的索引位置上。若两个键映射到同一位置（即出现<strong>哈希冲突</strong>），则需要解决冲突以保证数据存储的正确性。</p><h3 id="哈希表的术语"><a href="#哈希表的术语" class="headerlink" title="哈希表的术语"></a>哈希表的术语</h3><ul><li><strong>哈希函数</strong>：将键映射到表中某个位置的函数。</li><li><strong>哈希冲突</strong>：两个不同的键被映射到同一个位置。</li><li><strong>装载因子</strong>：表中已填充元素的数量与哈希表大小的比值。较高的装载因子会增加冲突发生的可能性。</li></ul><h2 id="2-哈希表的实现方式"><a href="#2-哈希表的实现方式" class="headerlink" title="2. 哈希表的实现方式"></a>2. 哈希表的实现方式</h2><p>哈希表的常用实现方式主要有两种：</p><ol><li><strong>开放寻址法</strong>：在发生冲突时，通过寻找其他空闲位置来存储元素。常见的开放寻址方法包括线性探测、二次探测和双重哈希。</li><li><strong>链地址法（拉链法）</strong>：在每个哈希表位置存储一个链表，在发生冲突时将新元素插入到链表中。</li></ol><h2 id="3-哈希表的-C-实现"><a href="#3-哈希表的-C-实现" class="headerlink" title="3. 哈希表的 C++ 实现"></a>3. 哈希表的 C++ 实现</h2><h3 id="使用链地址法（拉链法）的-C-实现"><a href="#使用链地址法（拉链法）的-C-实现" class="headerlink" title="使用链地址法（拉链法）的 C++ 实现"></a>使用链地址法（拉链法）的 C++ 实现</h3><p>我们可以使用一个数组加链表的结构来实现哈希表。每个数组元素是一个链表，用于解决哈希冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; table;  <span class="comment">// 哈希表的数组，每个位置是一个链表</span></span><br><span class="line">    <span class="type">int</span> size;                 <span class="comment">// 哈希表的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数：简单取模法</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunction</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HashTable</span>(<span class="type">int</span> s) : <span class="built_in">size</span>(s) &#123;</span><br><span class="line">        table.<span class="built_in">resize</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line">        table[index].<span class="built_in">push_back</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line">        table[index].<span class="built_in">remove</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : table[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element == key) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示哈希表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : table[i]) &#123;</span><br><span class="line">                cout &lt;&lt; element &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">HashTable <span class="title">hashTable</span><span class="params">(<span class="number">7</span>)</span></span>; <span class="comment">// 创建大小为 7 的哈希表</span></span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hash Table:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Searching for 15: &quot;</span> &lt;&lt; (hashTable.<span class="built_in">search</span>(<span class="number">15</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">remove</span>(<span class="number">15</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After removing 15:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul><li><strong>哈希函数</strong>：这里我们用简单的取模方法，将键值对映射到表中的某个位置。<code>hashFunction(int key)</code> 通过 <code>key % size</code> 计算索引。</li><li><strong>插入操作</strong>：将元素插入到哈希表中指定索引的链表中。</li><li><strong>删除操作</strong>：从哈希表中指定索引的链表中删除目标元素。</li><li><strong>查找操作</strong>：检查目标元素是否在哈希表的某个位置的链表中。</li></ul><h3 id="开放寻址法的几种探测方法"><a href="#开放寻址法的几种探测方法" class="headerlink" title="开放寻址法的几种探测方法"></a>开放寻址法的几种探测方法</h3><ol><li><strong>线性探测</strong>（Linear Probing）：冲突时按固定步长（通常为 1）查找下一个空位。</li><li><strong>二次探测</strong>（Quadratic Probing）：冲突时按二次方步长查找下一个空位，步长逐渐增加以避免簇现象。</li><li><strong>双重哈希</strong>（Double Hashing）：使用两个哈希函数，当冲突发生时，通过第二个哈希函数计算步长。</li></ol><p>下面我们以<strong>线性探测法</strong>为例，展示开放寻址法的实现。</p><h3 id="使用开放寻址法的哈希表-C-实现"><a href="#使用开放寻址法的哈希表-C-实现" class="headerlink" title="使用开放寻址法的哈希表 C++ 实现"></a>使用开放寻址法的哈希表 C++ 实现</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul><li>使用一个数组保存元素，初始值为 -1 或 <code>nullptr</code> 表示该位置空闲。</li><li>插入元素时，如果计算出的索引位置被占用，则按探测策略查找下一个位置。</li><li>删除元素时，采用标记（例如 <code>-2</code>）表示“删除状态”，这样在查找时不会打断探测链。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenAddressHashTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; table; <span class="comment">// 哈希表数组</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数：简单取模</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunction</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OpenAddressHashTable</span>(<span class="type">int</span> s) : <span class="built_in">size</span>(s) &#123;</span><br><span class="line">        table.<span class="built_in">resize</span>(size, <span class="number">-1</span>); <span class="comment">// -1 表示空闲位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线性探测</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> probeIndex = (index + i) % size;  <span class="comment">// 线性探测</span></span><br><span class="line">            <span class="keyword">if</span> (table[probeIndex] == <span class="number">-1</span> || table[probeIndex] == <span class="number">-2</span>) &#123; <span class="comment">// 找到空闲或已删除位置</span></span><br><span class="line">                table[probeIndex] = key;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 哈希表已满</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线性探测</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> probeIndex = (index + i) % size;</span><br><span class="line">            <span class="keyword">if</span> (table[probeIndex] == key) &#123;  <span class="comment">// 找到目标元素</span></span><br><span class="line">                table[probeIndex] = <span class="number">-2</span>; <span class="comment">// -2 标记删除状态</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (table[probeIndex] == <span class="number">-1</span>) &#123;  <span class="comment">// 没找到且遇到空闲位置，停止查找</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线性探测</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> probeIndex = (index + i) % size;</span><br><span class="line">            <span class="keyword">if</span> (table[probeIndex] == key) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">// 找到目标元素</span></span><br><span class="line">            <span class="keyword">if</span> (table[probeIndex] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 找到空闲位置，停止查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示哈希表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; table[i] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (table[i] == <span class="number">-2</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: [Deleted]&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: [Empty]&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">OpenAddressHashTable <span class="title">hashTable</span><span class="params">(<span class="number">7</span>)</span></span>; <span class="comment">// 创建大小为 7 的哈希表</span></span><br><span class="line"></span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hash Table:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Searching for 15: &quot;</span> &lt;&lt; (hashTable.<span class="built_in">search</span>(<span class="number">15</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">remove</span>(<span class="number">15</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After removing 15:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><ul><li><strong>哈希函数</strong>：使用 <code>key % size</code> 计算元素的初始索引位置。</li><li><strong>线性探测</strong>：在发生冲突时，通过逐次递增索引来查找下一个空闲位置，直到找到空位或返回失败。</li><li><strong>删除标记</strong>：删除元素时，将该位置标记为 <code>-2</code>（表示已删除），防止探测链的中断。<code>-1</code> 表示空闲位置。</li><li><strong>查找与删除</strong>：查找元素时遇到 <code>-1</code> 即可停止查找，遇到 <code>-2</code> 则继续探测链。</li></ul><h3 id="其他探测方法简述"><a href="#其他探测方法简述" class="headerlink" title="其他探测方法简述"></a>其他探测方法简述</h3><ol><li><strong>二次探测</strong>：冲突时探测间隔为 $( i^2 )$ （如 <code>index + i^2</code>）。这样可以避免线性探测中的“主簇”问题，但可能引入新的探测区域。</li><li><strong>双重哈希</strong>：冲突时通过第二个哈希函数计算步长，跳跃性地寻找位置，减少了探测链的聚集现象。</li></ol><p>开放寻址法通常比链地址法更节省空间，但当装载因子过高时，开放寻址法的性能下降更明显。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;哈希表（Hash Table）是一种用于存储键值对的数据结构，可以通过哈希函数快速地根据键找到对应的值。哈希表的查找、插入和删除操作在平均情况下具有 &lt;code&gt;O(1)&lt;/code&gt; 的时间复杂度，非常高效。&lt;/p&gt;
&lt;h2 id=&quot;1-哈希表的基本概念&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="数据结构" scheme="https://blog.whff521.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="哈希表" scheme="https://blog.whff521.xyz/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列</title>
    <link href="https://blog.whff521.xyz/2024/10/30/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>https://blog.whff521.xyz/2024/10/30/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2024-10-30T02:17:05.000Z</published>
    <updated>2024-10-30T02:32:41.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-栈的基本概念与操作"><a href="#1-栈的基本概念与操作" class="headerlink" title="1. 栈的基本概念与操作"></a>1. 栈的基本概念与操作</h2><p>栈（Stack）是一种<strong>后进先出</strong>（LIFO, Last In First Out）的数据结构，最后插入的元素最先被删除。</p><h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><ol><li><strong>初始化</strong>：创建一个空栈。</li><li><strong>入栈（Push）</strong>：将一个元素压入栈顶。</li><li><strong>出栈（Pop）</strong>：从栈顶删除一个元素。</li><li><strong>取栈顶元素（Top）</strong>：获取栈顶元素的值，但不删除它。</li><li><strong>判断是否为空</strong>：检查栈是否为空。</li></ol><h2 id="2-队列的基本概念与操作"><a href="#2-队列的基本概念与操作" class="headerlink" title="2. 队列的基本概念与操作"></a>2. 队列的基本概念与操作</h2><p>队列（Queue）是一种<strong>先进先出</strong>（FIFO, First In First Out）的数据结构，最先插入的元素最先被删除。</p><h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><ol><li><strong>初始化</strong>：创建一个空队列。</li><li><strong>入队（Enqueue）</strong>：将一个元素加入到队尾。</li><li><strong>出队（Dequeue）</strong>：从队头删除一个元素。</li><li><strong>取队头元素（Front）</strong>：获取队头元素的值，但不删除它。</li><li><strong>判断是否为空</strong>：检查队列是否为空。</li></ol><h2 id="3-栈的顺序存储结构"><a href="#3-栈的顺序存储结构" class="headerlink" title="3. 栈的顺序存储结构"></a>3. 栈的顺序存储结构</h2><p>栈的顺序存储结构通常使用数组实现，栈顶指针 <code>top</code> 用于指向栈顶元素。</p><h3 id="栈的顺序存储结构的-C-实现"><a href="#栈的顺序存储结构的-C-实现" class="headerlink" title="栈的顺序存储结构的 C++ 实现"></a>栈的顺序存储结构的 C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>() : <span class="built_in">top</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top &gt;= MAX_SIZE - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 栈满</span></span><br><span class="line">        data[++top] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 栈空</span></span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 栈空</span></span><br><span class="line">        <span class="keyword">return</span> data[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= top; ++i) std::cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-队列的顺序存储结构"><a href="#4-队列的顺序存储结构" class="headerlink" title="4. 队列的顺序存储结构"></a>4. 队列的顺序存储结构</h2><p>队列的顺序存储结构可以用循环数组实现，使用 <code>front</code> 和 <code>rear</code> 两个指针分别指向队头和队尾。</p><h3 id="队列的顺序存储结构的-C-实现"><a href="#队列的顺序存储结构的-C-实现" class="headerlink" title="队列的顺序存储结构的 C++ 实现"></a>队列的顺序存储结构的 C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>() : <span class="built_in">front</span>(<span class="number">0</span>), <span class="built_in">rear</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">enqueue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((rear + <span class="number">1</span>) % MAX_SIZE == front) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 队列满</span></span><br><span class="line">        data[rear] = value;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == rear) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 队列空</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == rear) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 队列空</span></span><br><span class="line">        <span class="keyword">return</span> data[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = front;</span><br><span class="line">        <span class="keyword">while</span> (i != rear) &#123;</span><br><span class="line">            std::cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            i = (i + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-栈的链式存储结构"><a href="#5-栈的链式存储结构" class="headerlink" title="5. 栈的链式存储结构"></a>5. 栈的链式存储结构</h2><p>栈的链式存储结构使用链表实现，每次入栈和出栈都在链表的头部操作。</p><h3 id="栈的链式存储结构的-C-实现"><a href="#栈的链式存储结构的-C-实现" class="headerlink" title="栈的链式存储结构的 C++ 实现"></a>栈的链式存储结构的 C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* top;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedStack</span>() : <span class="built_in">top</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(value);</span><br><span class="line">        newNode-&gt;next = top;</span><br><span class="line">        top = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!top) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 栈空</span></span><br><span class="line">        Node* temp = top;</span><br><span class="line">        top = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top ? top-&gt;data : <span class="number">-1</span>;  <span class="comment">// 栈空返回 -1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node* curr = top;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            std::cout &lt;&lt; curr-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-队列的链式存储结构"><a href="#6-队列的链式存储结构" class="headerlink" title="6. 队列的链式存储结构"></a>6. 队列的链式存储结构</h2><p>队列的链式存储结构使用链表实现，链表的头部作为队头，尾部作为队尾。</p><h3 id="队列的链式存储结构的-C-实现"><a href="#队列的链式存储结构的-C-实现" class="headerlink" title="队列的链式存储结构的 C++ 实现"></a>队列的链式存储结构的 C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    QNode* next;</span><br><span class="line">    <span class="built_in">QNode</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QNode *front, *rear;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedQueue</span>() : <span class="built_in">front</span>(<span class="literal">nullptr</span>), <span class="built_in">rear</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        QNode* newNode = <span class="keyword">new</span> <span class="built_in">QNode</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (!rear) &#123;</span><br><span class="line">            front = rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rear-&gt;next = newNode;</span><br><span class="line">            rear = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!front) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 队列空</span></span><br><span class="line">        QNode* temp = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!front) rear = <span class="literal">nullptr</span>;  <span class="comment">// 队列变空</span></span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front ? front-&gt;data : <span class="number">-1</span>;  <span class="comment">// 队列空返回 -1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QNode* curr = front;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            std::cout &lt;&lt; curr-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>栈</strong>：遵循 LIFO 原则，典型操作包括入栈和出栈。</li><li><strong>队列</strong>：遵循 FIFO 原则，典型操作包括入队和出队。</li><li><strong>顺序存储</strong>：使用数组实现，适合容量固定的情况，操作简单。</li><li><strong>链式存储</strong>：使用链表实现，适合动态长度的情况，节省空间。</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;1-栈的基本概念与操作&quot;&gt;&lt;a href=&quot;#1-栈的基本概念与操作&quot; class=&quot;headerlink&quot; title=&quot;1. 栈的基本概念与操作&quot;&gt;&lt;/a&gt;1.</summary>
        
      
    
    
    
    <category term="数据结构" scheme="https://blog.whff521.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="栈与队列" scheme="https://blog.whff521.xyz/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>线性表</title>
    <link href="https://blog.whff521.xyz/2024/10/30/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://blog.whff521.xyz/2024/10/30/%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2024-10-30T02:04:39.000Z</published>
    <updated>2024-10-30T02:13:42.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是一种数据结构，表示由<strong>同一类型的元素按顺序排列</strong>的有限集合。线性表中的元素有顺序关系，可以通过顺序号访问。它是最常用的结构之一，常用于实现数据的顺序存储和查找操作。</p><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><p>一个线性表 $( L )$ 可以定义为一个具有相同类型的元素集合，其中第一个元素为 $( a_1 )$，第二个元素为 $( a_2 )$，依次排列，直到第 $( n )$ 个元素 $( a_n )$。线性表的长度是元素的个数，当长度为 0 时，称其为空表。</p><p>在数学上可以表示为：<br>$[ L &#x3D; { a_1, a_2, \dots, a_n } ]$</p><h2 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h2><p>线性表的基本操作主要包括以下几个：</p><ol><li><p><strong>初始化</strong>（Initialization）</p><ul><li>创建一个空的线性表。</li></ul></li><li><p><strong>插入</strong>（Insert）</p><ul><li>将一个新元素插入到线性表的指定位置。插入时，需要将插入位置后的所有元素向后移动。</li></ul></li><li><p><strong>删除</strong>（Delete）</p><ul><li>删除线性表中的指定位置的元素。删除时，需要将删除位置后的所有元素向前移动。</li></ul></li><li><p><strong>查找</strong>（Find&#x2F;Search）</p><ul><li>根据元素的值查找其在表中的位置，或根据位置查找对应的元素值。</li></ul></li><li><p><strong>更新</strong>（Update）</p><ul><li>修改线性表中指定位置的元素值。</li></ul></li><li><p><strong>遍历</strong>（Traverse）</p><ul><li>顺序访问线性表中的每一个元素，通常用于打印或处理每个元素。</li></ul></li><li><p><strong>获取长度</strong>（Length）</p><ul><li>获取线性表中元素的个数。</li></ul></li></ol><h2 id="线性表的实现方式"><a href="#线性表的实现方式" class="headerlink" title="线性表的实现方式"></a>线性表的实现方式</h2><p>线性表的实现通常有两种存储结构：</p><ul><li><strong>顺序存储结构</strong>：使用数组存储元素，适合顺序访问，但插入和删除操作的效率较低。</li><li><strong>链式存储结构</strong>：使用链表存储元素，适合频繁的插入和删除操作，常见的链表类型包括单链表、循环链表和双向链表。</li></ul><h3 id="1-顺序表的实现"><a href="#1-顺序表的实现" class="headerlink" title="1. 顺序表的实现"></a>1. 顺序表的实现</h3><p>顺序表使用数组实现，其特点是可以直接通过索引访问元素，效率高，但插入和删除需要移动元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqList</span>() : <span class="built_in">length</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt; length || length &gt;= MAX_SIZE) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = length; i &gt; pos; --i) data[i] = data[i - <span class="number">1</span>];</span><br><span class="line">        data[pos] = value;</span><br><span class="line">        length++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt;= length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt; length - <span class="number">1</span>; ++i) data[i] = data[i + <span class="number">1</span>];</span><br><span class="line">        length--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">            <span class="keyword">if</span> (data[i] == value) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) std::cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-单链表的实现"><a href="#2-单链表的实现" class="headerlink" title="2. 单链表的实现"></a>2. 单链表的实现</h3><p>单链表由节点构成，适合频繁的插入和删除操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SinglyLinkedList</span>() : <span class="built_in">head</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(value);</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node *prev = <span class="literal">nullptr</span>, *curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr &amp;&amp; curr-&gt;data != value) &#123;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!curr) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prev) prev-&gt;next = curr-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> head = curr-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> curr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">find</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;data == value) <span class="keyword">return</span> curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            std::cout &lt;&lt; curr-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-循环链表的实现"><a href="#3-循环链表的实现" class="headerlink" title="3. 循环链表的实现"></a>3. 循环链表的实现</h3><p>循环链表的最后一个节点指向第一个节点，形成一个循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    CNode* next;</span><br><span class="line">    <span class="built_in">CNode</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CNode* tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircularLinkedList</span>() : <span class="built_in">tail</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        CNode* newNode = <span class="keyword">new</span> <span class="built_in">CNode</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (!tail) &#123;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            tail-&gt;next = tail;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode-&gt;next = tail-&gt;next;</span><br><span class="line">            tail-&gt;next = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tail) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        CNode *curr = tail-&gt;next, *prev = tail;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;data == value) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curr == tail) tail = (tail-&gt;next == tail) ? <span class="literal">nullptr</span> : prev;</span><br><span class="line">                prev-&gt;next = curr-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> curr;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (curr != tail-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">CNode* <span class="title">find</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tail) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        CNode* curr = tail-&gt;next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;data == value) <span class="keyword">return</span> curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (curr != tail-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tail) <span class="keyword">return</span>;</span><br><span class="line">        CNode* curr = tail-&gt;next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; curr-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (curr != tail-&gt;next);</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-双向链表的实现"><a href="#4-双向链表的实现" class="headerlink" title="4. 双向链表的实现"></a>4. 双向链表的实现</h3><p>双向链表每个节点有前驱和后继指针，方便双向遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    DNode* prev;</span><br><span class="line">    DNode* next;</span><br><span class="line">    <span class="built_in">DNode</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DNode* head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DoublyLinkedList</span>() : <span class="built_in">head</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        DNode* newNode = <span class="keyword">new</span> <span class="built_in">DNode</span>(value);</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        <span class="keyword">if</span> (head) head-&gt;prev = newNode;</span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        DNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr &amp;&amp; curr-&gt;data != value) curr = curr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!curr) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;prev) curr-&gt;prev-&gt;next = curr-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> head = curr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;next) curr-&gt;next-&gt;prev = curr-&gt;prev;</span><br><span class="line">        <span class="keyword">delete</span> curr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DNode* <span class="title">find</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        DNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;data == value) <span class="keyword">return</span> curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            std::cout &lt;&lt; curr-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些代码分别实现了顺序表、单链表、循环链表和双向链表的数据结构及其基本操作，适合考试和项目中的线性表应用。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="数据结构" scheme="https://blog.whff521.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="线性表" scheme="https://blog.whff521.xyz/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>CCSP2024 赛后回忆</title>
    <link href="https://blog.whff521.xyz/2024/10/23/CCSP2024-%E8%B5%9B%E5%90%8E%E5%9B%9E%E5%BF%86/"/>
    <id>https://blog.whff521.xyz/2024/10/23/CCSP2024-%E8%B5%9B%E5%90%8E%E5%9B%9E%E5%BF%86/</id>
    <published>2024-10-23T13:00:17.000Z</published>
    <updated>2024-10-24T13:51:37.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CCSP2024-赛后回忆"><a href="#CCSP2024-赛后回忆" class="headerlink" title="CCSP2024 赛后回忆"></a>CCSP2024 赛后回忆</h1><p>这次是在浙江金华的浙江师范大学，虽然说这里可能有一点点偏僻，但是店铺什么的基本都有，奶茶店，肯德基什么的甚至开在了校内。</p><p>这应该是我大学最后一次参加国家级的赛事了吧。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="I-O-任务调度队列"><a href="#I-O-任务调度队列" class="headerlink" title="I&#x2F;O 任务调度队列"></a>I&#x2F;O 任务调度队列</h3><p>按来的时间排个序，奇数放第一个队列，偶数放第二个队列，保证每个任务等待的时间最小就可以了，签到题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t[mxlen];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;t[i];</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">sort</span>(t+<span class="number">1</span>,t+n+<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t[i]&gt;=ans1)&#123;</span><br><span class="line">                    ans1 = t[i]+<span class="number">10</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    ans1 += <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(t[i]&gt;=ans2)&#123;</span><br><span class="line">                    ans2 = t[i]+<span class="number">10</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> ans2 +=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans1&gt;ans2) <span class="built_in">swap</span>(ans1,ans2);</span><br><span class="line">        cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数树"><a href="#数树" class="headerlink" title="数树"></a>数树</h3><p>模拟题？直接按照他说的把功能都写了就行了，记录一下每个节点的父节点是什么。一开始只用了一位数组来记录点和父节点断开，改来改去只有45分。后来突然想到他可能和好多节点都断开，直接用vector存一下就过了。</p><p>第二天听颁奖典礼上讲题解说的是分快树，LCT做。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> pre_ans;</span><br><span class="line"><span class="type">int</span> w[mxlen];</span><br><span class="line"><span class="type">int</span> father[mxlen];</span><br><span class="line"><span class="type">int</span> now_root = <span class="number">1</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; broken[mxlen];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[mxlen];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_relation</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;broken[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(broken[u][i]==v) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_father</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    father[u] = fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check_relation</span>(u,g[u][i])) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">find_father</span>(g[u][i],u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pre_ans) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">return</span> v^pre_ans;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs_weight</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check_relation</span>(u,g[u][i])) <span class="keyword">continue</span>;</span><br><span class="line">        ans+=<span class="built_in">dfs_weight</span>(g[u][i],u,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(w[u]&gt;x) ans++;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_heaviest</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = w[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check_relation</span>(u,g[u][i])) <span class="keyword">continue</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,<span class="built_in">find_heaviest</span>(g[u][i],u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">find_minw_minindex</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    node tmp = &#123;w[u],u&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check_relation</span>(u,g[u][i])) <span class="keyword">continue</span>;</span><br><span class="line">        node son = <span class="built_in">find_minw_minindex</span>(g[u][i],u);</span><br><span class="line">        <span class="keyword">if</span>(son.weight&lt;tmp.weight)&#123;</span><br><span class="line">            tmp.weight = son.weight;</span><br><span class="line">            tmp.index = son.index;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(son.weight==tmp.weight)&#123;</span><br><span class="line">            <span class="keyword">if</span>(son.index&lt;tmp.index)&#123;</span><br><span class="line">                tmp.weight = son.weight;</span><br><span class="line">                tmp.index = son.index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u,x;</span><br><span class="line">    <span class="comment">// ask how many points&#x27; weight more than v in u subtree</span></span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;x;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        x = <span class="built_in">change</span>(x);</span><br><span class="line">        pre_ans = <span class="built_in">dfs_weight</span>(u,father[u],x);</span><br><span class="line">        cout&lt;&lt;pre_ans&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;x;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        x = <span class="built_in">change</span>(x);</span><br><span class="line">        w[u] = x;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;x;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        x = <span class="built_in">change</span>(x);</span><br><span class="line">        n++;</span><br><span class="line">        g[n].<span class="built_in">push_back</span>(u);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(n);</span><br><span class="line">        father[n] = u;</span><br><span class="line">        w[n] = x;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        broken[u].<span class="built_in">push_back</span>(father[u]);</span><br><span class="line">        broken[father[u]].<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="built_in">find_father</span>(u,<span class="number">-1</span>);</span><br><span class="line">        pre_ans = <span class="built_in">find_heaviest</span>(u,father[u]);</span><br><span class="line">        cout&lt;&lt;pre_ans&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">5</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        node temp = <span class="built_in">find_minw_minindex</span>(u,father[u]);</span><br><span class="line">        pre_ans = temp.index;</span><br><span class="line">        cout&lt;&lt;pre_ans&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">6</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        <span class="built_in">find_father</span>(u,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">            g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;w[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">find_father</span>(now_root,<span class="number">-1</span>);</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        pre_ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            cin&gt;&gt;op;</span><br><span class="line">            <span class="built_in">solve</span>(op);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="贝壳统计（shell）"><a href="#贝壳统计（shell）" class="headerlink" title="贝壳统计（shell）"></a>贝壳统计（shell）</h3><p>这题。。。。80分带修莫队板子题。后面插入元素的改了半天都会超时，不懂怎么改。只拿了80分。</p><p>一开始直接暴力做能拿40分。我看这1e5的数据，两维数组都开不了，也没办法记忆化，就想起来了之前看过的快慢指针，我拿两个指针来回记录时间应该会小一点，很遗憾还是40分。我看着我写的<code>pre_l--</code>和<code>pre_r++</code>越看越熟悉，，，这不就是莫队吗？？？？！！！还好这比赛让带U盘，然后我点开里面的模版（赛前都没看过，不知道从哪里下的了都），直接目录直达带修莫队，ubuntu里复制pdf里代码到vscode里缩进都没了，我也没管，粘过来改改变量名称直接就拿了80分。</p><p>第二天题解讲的是线段树什么的维护增加位置的个数，把添加的数改为负数，还没插入的为负数不用管，好像有点道理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e5</span>+<span class="number">1e4</span>+<span class="number">15</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[mxlen*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> block = <span class="number">2589</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span>&#123;</span><br><span class="line">    <span class="type">int</span> id,l,r,t;</span><br><span class="line">&#125;q[mxlen];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Modify</span>&#123;</span><br><span class="line">    <span class="type">int</span> pos,col,lst;</span><br><span class="line">&#125;c[mxlen];</span><br><span class="line"><span class="type">int</span> cnt[mxlen];</span><br><span class="line"><span class="type">int</span> bi[mxlen];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Query &amp;a, <span class="type">const</span> Query &amp;b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> al = bi[a.l], ar = bi[a.r];</span><br><span class="line"><span class="type">int</span> bl = bi[b.l], br = bi[b.r];</span><br><span class="line"><span class="keyword">if</span>(al != bl)<span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line"><span class="keyword">if</span>(ar != br)<span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line"><span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[x] == <span class="number">0</span>)res ++ ;</span><br><span class="line">cnt[x] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">cnt[x] -- ;</span><br><span class="line"><span class="keyword">if</span>(cnt[x] == <span class="number">0</span>)res -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mq = <span class="number">0</span>,mc = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans[mxlen];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> res)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(res&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">res=-res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(res&gt;<span class="number">9</span>)</span><br><span class="line"><span class="built_in">write</span>(res/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(res%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modui</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">    bi[i] = (i - <span class="number">1</span>) / block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + mq, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> k = <span class="number">1</span>, i = <span class="number">0</span>, j = <span class="number">1</span>, t = <span class="number">0</span>, res = <span class="number">0</span>; k &lt;= mq; ++ k)&#123;</span><br><span class="line">        <span class="type">int</span> id = q[k].id, l = q[k].l, r = q[k].r, tim = q[k].t;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; r)res += ++ cnt[a[ ++ i]] == <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; r)res -= -- cnt[a[i -- ]] == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; l)res -= -- cnt[a[j ++ ]] == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &gt; l)res += ++ cnt[a[ -- j]] == <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//再处理y轴</span></span><br><span class="line">    <span class="keyword">while</span>(t &lt; tim)&#123;</span><br><span class="line">    t ++ ;</span><br><span class="line">    <span class="keyword">if</span>(c[t].pos &gt;= j &amp;&amp; c[t].pos &lt;= i)&#123;</span><br><span class="line">    <span class="built_in">del</span>(a[c[t].pos], res);</span><br><span class="line">    <span class="built_in">add</span>(c[t].col, res);</span><br><span class="line">    <span class="comment">//res -= !--cnt[w[c[t].pos]] - !cnt[c[t].col]++;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[c[t].pos], c[t].col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t &gt; tim)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c[t].pos &gt;= j &amp;&amp; c[t].pos &lt;= i)&#123;</span><br><span class="line">    <span class="built_in">del</span>(a[c[t].pos], res);</span><br><span class="line">    <span class="built_in">add</span>(c[t].col, res);</span><br><span class="line">    <span class="comment">//res -= !--cnt[w[c[t].pos]] - !cnt[c[t].col]++;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[c[t].pos], c[t].col);</span><br><span class="line">    t -- ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[id] = res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=mq;i++)&#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i]), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_large</span><span class="params">(<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> L,R;</span><br><span class="line">        cin&gt;&gt;L&gt;&gt;R;</span><br><span class="line">        q[++mq] = (Query)&#123;mq,L,R,mc&#125;;        </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> P,V;</span><br><span class="line">        cin&gt;&gt;P&gt;&gt;V;</span><br><span class="line">        c[++mc] = (Modify)&#123;P,V&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">modui</span>();</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        mq = <span class="number">0</span>;</span><br><span class="line">        mc = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> P,V;</span><br><span class="line">        cin&gt;&gt;P&gt;&gt;V;</span><br><span class="line">        n++;</span><br><span class="line">       a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+P,V);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1e4</span>)&#123;</span><br><span class="line">        <span class="built_in">solve_large</span>(op);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> L,R;</span><br><span class="line">        cin&gt;&gt;L&gt;&gt;R;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=L;i&lt;=R;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[a[i]])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                vis[a[i]]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> P,V;</span><br><span class="line">        cin&gt;&gt;P&gt;&gt;V;</span><br><span class="line">        a[P] = V;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> P,V;</span><br><span class="line">        cin&gt;&gt;P&gt;&gt;V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        a.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            a.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            cin&gt;&gt;op;</span><br><span class="line">            <span class="built_in">solve</span>(op);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">1e4</span>&amp;&amp;op!=<span class="number">3</span>) <span class="built_in">modui</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>后两题真的折磨，光输入都差不多写了100多行，然而就只拿到了10分，这里就不贴代码了。我觉得要是平时写过系统相关的代码应该很快能写出来，我看有人很快就写完了。我调了半天真的有点崩溃了，看了看排行榜感觉再努力也进不了金牌了，还是早早收场就提前出来了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后是拿了290分，差十分银。这次可以说是大意失荆州——骄兵必败了。六点半的时候还排在银奖队伍中前部位，因为七点后就封傍了，我觉得就算有人后面写出来后两题也不至于把我退到铜吧（请不要学我。。。）。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;CCSP2024-赛后回忆&quot;&gt;&lt;a href=&quot;#CCSP2024-赛后回忆&quot; class=&quot;headerlink&quot; title=&quot;CCSP2024 赛后回忆&quot;&gt;&lt;/a&gt;CCSP2024</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="CCSP" scheme="https://blog.whff521.xyz/tags/CCSP/"/>
    
  </entry>
  
  <entry>
    <title>HDU 4870 概率DP</title>
    <link href="https://blog.whff521.xyz/2024/10/15/HDU-4870-%E6%A6%82%E7%8E%87DP/"/>
    <id>https://blog.whff521.xyz/2024/10/15/HDU-4870-%E6%A6%82%E7%8E%87DP/</id>
    <published>2024-10-15T07:39:36.000Z</published>
    <updated>2024-10-15T07:57:54.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HDU-4870-概率DP"><a href="#HDU-4870-概率DP" class="headerlink" title="HDU 4870 概率DP"></a>HDU 4870 概率DP</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=4870">Problem Link</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>新账号打rank，rank从0开始，打到1000分结束。每场rank增加50的概率为p，否则rank-100。新人用两个信号去打，每次用rank值低的账号，问任意一个账号达到rank1000分，新人要打的期望场数。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p><a href="https://www.cnblogs.com/philo-zhou/p/11330699.html">参考博客</a></p><p>将分数离散为赢了加1分，输了减2分。用<code>dp[i]</code>表示从i-1分到i分需要打的期望场数。</p><p>每次比赛有两种情况，一是p概率赢了加1分，二是(1-p)概率输了减2分。</p><p><code>dp[i]=1*p+(1-p)(1+dp[i-2]+dp[i-1]+dp[i])</code></p><p>期望等于所有情况乘以概率的和。</p><ul><li>一场就赢了，则是<code>1*p</code></li><li>一场输了，则需要<code>(1+dp[i-2]+dp[i-1]+dp[i])</code>场才能赢回来。其中1是输了这场，然后从<code>i-3</code>打到<code>i-2</code>,从<code>i-2</code>打到<code>i-1</code>，从<code>i-1</code>打到<code>i</code>分。</li></ul><p>化简得</p><p><code>dp[i]=(1+(1-p)*(dp[i-2]+dp[i-1]))/p</code></p><p><code>dp[1] = 1/p, dp[2] = 1/p/p</code></p><p>注意，因为最低分是0分，所以计算<code>dp[1]</code>和<code>dp[2]</code>的时候公式里填0补充。</p><p>用<code>tot</code>记录每一分需要的场数，因为有两个账号，且每次都是用分数低的，所以最后一定是一个账号1000分，另一个账号950分。我们计算两个账号都是1000分需要的场数，即<code>tot*2</code>，然后减去一个950分到1000分的期望场数(<code>dp[20]</code>)，即是答案。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">25</span>;</span><br><span class="line"><span class="type">double</span> dp[mxlen];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> p;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;p)!=EOF)&#123;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>/p;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>/p/p;</span><br><span class="line">        <span class="type">double</span> tot = dp[<span class="number">1</span>]+dp[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">20</span>;i++)&#123;</span><br><span class="line">            dp[i] = (<span class="number">1</span>+(<span class="number">1</span>-p)*(dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]))/p;</span><br><span class="line">            tot += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>,<span class="number">2</span>*tot-dp[<span class="number">20</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;HDU-4870-概率DP&quot;&gt;&lt;a href=&quot;#HDU-4870-概率DP&quot; class=&quot;headerlink&quot; title=&quot;HDU 4870 概率DP&quot;&gt;&lt;/a&gt;HDU 4870 概率DP&lt;/h1&gt;&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="算法题" scheme="https://blog.whff521.xyz/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="DP" scheme="https://blog.whff521.xyz/tags/DP/"/>
    
  </entry>
  
</feed>
