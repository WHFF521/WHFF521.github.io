<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AiRomance</title>
  <icon>https://blog.whff521.xyz/images/101.ico</icon>
  <subtitle>爱裸漫三三</subtitle>
  <link href="https://blog.whff521.xyz/atom.xml" rel="self"/>
  <link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
  <link href="https://blog.whff521.xyz/"/>
  <updated>2024-11-14T09:32:00.792Z</updated>
  <id>https://blog.whff521.xyz/</id>
  
  <author>
    <name>AiRomance</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序</title>
    <link href="https://blog.whff521.xyz/2024/10/31/%E6%8E%92%E5%BA%8F/"/>
    <id>https://blog.whff521.xyz/2024/10/31/%E6%8E%92%E5%BA%8F/</id>
    <published>2024-10-31T01:38:09.000Z</published>
    <updated>2024-11-14T09:32:00.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>在数据结构中，<strong>排序</strong>（Sorting）指的是将一个数据集合中的元素按指定顺序重新排列的过程。排序是计算机科学的基本操作之一，对数据处理和分析具有重要作用。排序的结果通常是按从小到大（升序）或从大到小（降序）排列的有序序列。</p><h2 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h2><ol><li><p><strong>内部排序和外部排序</strong>：</p><ul><li><strong>内部排序</strong>：数据量较小，能够将所有待排序的记录一次性加载到内存中完成排序。</li><li><strong>外部排序</strong>：数据量较大，无法一次加载到内存中，需要借助外存（如硬盘）分批次处理并排序。</li></ul></li><li><p><strong>稳定性</strong>：</p><ul><li><strong>稳定排序</strong>：若两个相等的元素在排序前后的相对位置不变，则排序算法是稳定的。例如，若记录有相同的键值，稳定排序会保持它们的初始顺序。</li><li><strong>不稳定排序</strong>：可能会改变相等元素的相对位置。</li></ul></li><li><p><strong>时间复杂度</strong>：排序算法的时间复杂度通常以 $O(n^2)$ 或 $O(n \log n)$ 为主，决定了其在不同规模数据上的效率。</p></li><li><p><strong>空间复杂度</strong>：算法在排序过程中额外占用的存储空间。部分排序算法只需少量辅助空间（如原地排序），而有些则需要较多的辅助空间。</p></li><li><p><strong>排序算法的适用场景</strong>：根据数据量、数据特性（如是否近似有序）以及稳定性要求，选择合适的排序算法。</p></li></ol><h2 id="常见的排序算法及其特性"><a href="#常见的排序算法及其特性" class="headerlink" title="常见的排序算法及其特性"></a>常见的排序算法及其特性</h2><h3 id="1-冒泡排序（Bubble-Sort）："><a href="#1-冒泡排序（Bubble-Sort）：" class="headerlink" title="1. 冒泡排序（Bubble Sort）："></a>1. <strong>冒泡排序（Bubble Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：通过重复遍历待排序的序列，依次比较相邻元素，将较大或较小的元素向后交换。</li><li><strong>时间复杂度</strong>：$O(n^2)$</li><li><strong>特点</strong>：简单但效率低，适用于数据量小的情况。</li><li><strong>稳定性</strong>：稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">bool</span> swapped = <span class="literal">false</span>; <span class="comment">// 用于检测是否发生交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 arr[j] 和 arr[j + 1]</span></span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果在一轮遍历中没有发生交换，说明数组已排序</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bubbleSort</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-选择排序（Selection-Sort）："><a href="#2-选择排序（Selection-Sort）：" class="headerlink" title="2. 选择排序（Selection Sort）："></a>2. <strong>选择排序（Selection Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：每次从未排序部分选择最小（或最大）元素，放在已排序部分的末尾。</li><li><strong>时间复杂度</strong>：$O(n^2)$</li><li><strong>特点</strong>：减少了交换次数，但依然不适合大型数据。</li><li><strong>稳定性</strong>：不稳定</li></ul><h3 id="3-插入排序（Insertion-Sort）："><a href="#3-插入排序（Insertion-Sort）：" class="headerlink" title="3. 插入排序（Insertion Sort）："></a>3. <strong>插入排序（Insertion Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：将待排序数据分成已排序和未排序两部分，逐个将未排序元素插入已排序部分的正确位置。</li><li><strong>时间复杂度</strong>：$O(n^2)$</li><li><strong>特点</strong>：适用于小规模或近乎有序的序列。</li><li><strong>稳定性</strong>：稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> key = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前元素插入到已排序部分</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">insertionSort</span>(arr, n);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-归并排序（Merge-Sort）："><a href="#4-归并排序（Merge-Sort）：" class="headerlink" title="4. 归并排序（Merge Sort）："></a>4. <strong>归并排序（Merge Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：采用分治法，将数据分成子序列分别排序，再将有序子序列合并为完整序列。</li><li><strong>时间复杂度</strong>：$O(n \log n)$</li><li><strong>特点</strong>：效率高，适用于大型数据集，但需要额外存储空间。</li><li><strong>稳定性</strong>：稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = right - mid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时数组</span></span><br><span class="line">    <span class="type">int</span>* leftArr = <span class="keyword">new</span> <span class="type">int</span>[n1];</span><br><span class="line">    <span class="type">int</span>* rightArr = <span class="keyword">new</span> <span class="type">int</span>[n2];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝数据到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">        leftArr[i] = arr[left + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n2; j++)</span><br><span class="line">        rightArr[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并临时数组到原数组</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArr[i] &lt;= rightArr[j]) &#123;</span><br><span class="line">            arr[k] = leftArr[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = rightArr[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝剩余元素（如果有）</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = leftArr[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = rightArr[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放临时数组</span></span><br><span class="line">    <span class="keyword">delete</span>[] leftArr;</span><br><span class="line">    <span class="keyword">delete</span>[] rightArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归排序左右两部分</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, left, mid);</span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并排序后的两部分</span></span><br><span class="line">        <span class="built_in">merge</span>(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-快速排序（Quick-Sort）："><a href="#5-快速排序（Quick-Sort）：" class="headerlink" title="5. 快速排序（Quick Sort）："></a>5. <strong>快速排序（Quick Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：同样采用分治法，通过选择一个基准元素将数组分为两部分，再对每部分递归排序。</li><li><strong>时间复杂度</strong>：平均 $O(n \log n)$，最差 $O(n^2)$</li><li><strong>特点</strong>：通常比其他排序算法快，适合大型数据集，但对有序数组性能不佳。</li><li><strong>稳定性</strong>：不稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high]; <span class="comment">// 选择最后一个元素作为枢轴</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;       <span class="comment">// i 是较小元素的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt; high; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123; </span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]); <span class="comment">// 将较小的元素交换到前面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[high]); <span class="comment">// 将枢轴放到正确位置</span></span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;                <span class="comment">// 返回枢轴的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high); <span class="comment">// 获取分区索引</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>); <span class="comment">// 递归排序左半部分</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high); <span class="comment">// 递归排序右半部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-堆排序（Heap-Sort）："><a href="#6-堆排序（Heap-Sort）：" class="headerlink" title="6. 堆排序（Heap Sort）："></a>6. <strong>堆排序（Heap Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：利用堆这种数据结构进行排序，将数组构建成最大堆或最小堆，逐步取出堆顶元素排序。</li><li><strong>时间复杂度</strong>：$O(n \log n)$</li><li><strong>特点</strong>：时间复杂度稳定，但不适合小规模数据。</li><li><strong>稳定性</strong>：不稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点 i 及其子树调整为最大堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;         <span class="comment">// 将当前节点 i 设为最大值</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;    <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;   <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大值不是当前节点，则交换并递归调整</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主堆排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐一提取元素，重建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]); <span class="comment">// 将堆顶元素移到数组末尾</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);         <span class="comment">// 对剩余的元素重新进行堆化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">heapSort</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="7-希尔排序（Shell-Sort）："><a href="#7-希尔排序（Shell-Sort）：" class="headerlink" title="7. 希尔排序（Shell Sort）："></a>7. <strong>希尔排序（Shell Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：插入排序的改进版，逐步将数据分组并进行插入排序，最后整体排序。</li><li><strong>时间复杂度</strong>：介于 $O(n)$ 和 $O(n^2)$ 之间，具体取决于增量序列。</li><li><strong>特点</strong>：相对高效，尤其在数据量较大时。</li><li><strong>稳定性</strong>：不稳定</li></ul><h3 id="8-计数排序（Counting-Sort）："><a href="#8-计数排序（Counting-Sort）：" class="headerlink" title="8. 计数排序（Counting Sort）："></a>8. <strong>计数排序（Counting Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：适合数据范围较小的整数序列，通过统计数据出现的次数进行排序。</li><li><strong>时间复杂度</strong>：$O(n + k)$，其中 $k$ 为数值范围。</li><li><strong>特点</strong>：非常高效，但仅适用于特定场景。</li><li><strong>稳定性</strong>：稳定</li></ul><h3 id="9-基数排序（Radix-Sort）："><a href="#9-基数排序（Radix-Sort）：" class="headerlink" title="9. 基数排序（Radix Sort）："></a>9. <strong>基数排序（Radix Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：按数位或字符位置逐步排序，适合整数或字符串等定长数据。</li><li><strong>时间复杂度</strong>：$O(d \times (n + k))$，其中 $d$ 是位数，$k$ 为基数。</li><li><strong>特点</strong>：适用于数值或字符数据，效率高。</li><li><strong>稳定性</strong>：稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组中最大元素的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数排序，用于按特定位数对数组排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> exp)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* output = <span class="keyword">new</span> <span class="type">int</span>[n]; <span class="comment">// 输出数组</span></span><br><span class="line">    <span class="type">int</span> count[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;      <span class="comment">// 计数数组（基数范围为 0 到 9）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计在当前位数出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count[(arr[i] / exp) % <span class="number">10</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算累积和，更新 count 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建输出数组，按当前位数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> index = (arr[i] / exp) % <span class="number">10</span>;</span><br><span class="line">        output[count[index] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        count[index]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将排序好的数据拷贝回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = output[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基数排序的主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="built_in">getMax</span>(arr, n); <span class="comment">// 获取最大元素以确定最高位数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每一位数进行计数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> exp = <span class="number">1</span>; max / exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">countSort</span>(arr, n, exp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">170</span>, <span class="number">45</span>, <span class="number">75</span>, <span class="number">90</span>, <span class="number">802</span>, <span class="number">24</span>, <span class="number">2</span>, <span class="number">66</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">radixSort</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>代码说明:</li></ul><ol><li><code>getMax</code> 函数用于找到数组中的最大值，确定排序过程中最高的位数。</li><li><code>countSort</code> 函数实现了针对当前位数的计数排序。<code>exp</code> 表示当前处理的位数（例如，个位、十位等），通过 <code>arr[i] / exp % 10</code> 提取该位上的数字。</li><li><code>radixSort</code> 函数调用 <code>countSort</code>，从最低位开始对数组进行多轮排序，直到最高位。<br>基数排序的时间复杂度为 $O(d \cdot (n + k))$，其中 $d$ 是数字的最大位数，$n$ 是数组长度，$k$ 是基数（通常为10）。在处理整数的情况下，它通常被认为是线性时间排序算法。</li></ol><h3 id="10-桶排序（Bucket-Sort）："><a href="#10-桶排序（Bucket-Sort）：" class="headerlink" title="10. 桶排序（Bucket Sort）："></a>10. <strong>桶排序（Bucket Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：将数据分到不同的桶中，然后对每个桶进行排序，最后合并桶。</li><li><strong>时间复杂度</strong>：平均 $O(n + k)$</li><li><strong>特点</strong>：适合数据分布均匀的情况。</li><li><strong>稳定性</strong>：稳定（取决于桶内排序方法）</li></ul><h2 id="选择排序算法的依据"><a href="#选择排序算法的依据" class="headerlink" title="选择排序算法的依据"></a>选择排序算法的依据</h2><p>根据数据特性和需求，选择排序算法时一般考虑以下因素：</p><ul><li><strong>数据规模</strong>：数据规模小可以选择简单算法（如插入、选择、冒泡），规模较大可以考虑快速排序或归并排序。</li><li><strong>数据特性</strong>：若数据接近有序，选择插入排序；对于整数范围较小的数据，可以选择计数排序。</li><li><strong>稳定性要求</strong>：需要稳定的排序算法可以选择归并排序、计数排序、基数排序等。</li><li><strong>空间要求</strong>：对空间要求较高的场景可优先考虑堆排序或快速排序（可原地排序）。</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="数据结构" scheme="https://blog.whff521.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="排序" scheme="https://blog.whff521.xyz/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://blog.whff521.xyz/2024/10/31/%E5%9B%BE/"/>
    <id>https://blog.whff521.xyz/2024/10/31/%E5%9B%BE/</id>
    <published>2024-10-31T00:44:38.000Z</published>
    <updated>2024-10-31T01:27:38.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p><strong>图（Graph）</strong> 是一种用于表示关系的非线性数据结构，由<strong>顶点（节点，Vertices/Nodes）</strong>和<strong>边（Edges）</strong>组成，表示顶点之间的关系。图的概念适用于很多场景，比如社交网络（用户和好友关系）、地图（城市和路线）等。</p><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><ol><li><strong>顶点（Vertex）</strong>：图中的基本单位，表示实体或对象。</li><li><strong>边（Edge）</strong>：连接两个顶点的线，表示它们之间的关系或路径。</li><li><strong>有向图（Directed Graph）</strong>：边有方向的图，边表示从一个顶点到另一个顶点的单向关系。</li><li><strong>无向图（Undirected Graph）</strong>：边没有方向的图，边表示顶点之间的双向关系。</li><li><strong>加权图（Weighted Graph）</strong>：每条边上都有一个权重或费用，用于表示顶点之间的距离或成本。</li><li><strong>邻接</strong>：如果两个顶点之间有直接边相连，则称它们是邻接的。</li><li><strong>路径（Path）</strong>：从一个顶点到另一个顶点的一条顶点序列，其中相邻顶点之间都有边相连。</li><li><strong>环（Cycle）</strong>：从一个顶点出发经过若干边回到该顶点的路径。</li><li><strong>连通图（Connected Graph）</strong>：在无向图中，任何两个顶点之间都可以找到路径的图。</li></ol><h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><ul><li><strong>邻接矩阵（Adjacency Matrix）</strong>：用二维数组表示顶点之间是否相连。</li><li><strong>邻接表（Adjacency List）</strong>：用链表或数组表示每个顶点相邻的顶点。</li></ul><p>以下是使用邻接矩阵和邻接表表示图的简洁 C++ 代码示例。</p><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><p>邻接矩阵使用二维数组表示图，其中 <code>matrix[i][j] = 1</code> 表示顶点 <code>i</code> 和 <code>j</code> 之间有边，<code>0</code> 表示没有边。适合稠密图（边较多）的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphMatrix</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; matrix;</span><br><span class="line">    <span class="type">int</span> numVertices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GraphMatrix</span>(<span class="type">int</span> vertices) &#123;</span><br><span class="line">        numVertices = vertices;</span><br><span class="line">        matrix.<span class="built_in">resize</span>(vertices, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(vertices, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> src, <span class="type">int</span> dest)</span> </span>&#123;</span><br><span class="line">        matrix[src][dest] = <span class="number">1</span>;</span><br><span class="line">        matrix[dest][src] = <span class="number">1</span>;  <span class="comment">// 如果是无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; row : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> val : row)</span><br><span class="line">                cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">GraphMatrix <span class="title">graph</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    graph.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h3><p>邻接表使用链表或向量数组来存储图，每个顶点有一个链表（或向量）表示其相邻顶点，适合稀疏图（边较少）的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjList;</span><br><span class="line">    <span class="type">int</span> numVertices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GraphList</span>(<span class="type">int</span> vertices) &#123;</span><br><span class="line">        numVertices = vertices;</span><br><span class="line">        adjList.<span class="built_in">resize</span>(vertices);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> src, <span class="type">int</span> dest)</span> </span>&#123;</span><br><span class="line">        adjList[src].<span class="built_in">push_back</span>(dest);</span><br><span class="line">        adjList[dest].<span class="built_in">push_back</span>(src);  <span class="comment">// 如果是无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[i])</span><br><span class="line">                cout &lt;&lt; neighbor &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">GraphList <span class="title">graph</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    graph.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><strong>邻接矩阵</strong>：适合用于边较多的图，空间复杂度为 (O(V^2))。</li><li><strong>邻接表</strong>：适合用于边较少的图，空间复杂度为 (O(V + E))，更节省空间。</li></ul><h2 id="图的遍历操作"><a href="#图的遍历操作" class="headerlink" title="图的遍历操作"></a>图的遍历操作</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边（无向图）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList, <span class="type">int</span> src, <span class="type">int</span> dest)</span> </span>&#123;</span><br><span class="line">    adjList[src].<span class="built_in">push_back</span>(dest);</span><br><span class="line">    adjList[dest].<span class="built_in">push_back</span>(src);  <span class="comment">// 无向图</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先搜索（DFS）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> start, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    cout &lt;&lt; start &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[start]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(neighbor, adjList, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广度优先搜索（BFS）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> start, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> v = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> numVertices = <span class="number">5</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjList</span>(numVertices);  <span class="comment">// 邻接表表示图</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    <span class="built_in">addEdge</span>(adjList, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">addEdge</span>(adjList, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">addEdge</span>(adjList, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">addEdge</span>(adjList, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">addEdge</span>(adjList, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先搜索</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;DFS starting from vertex 0: &quot;</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(numVertices, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">0</span>, adjList, visited);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广度优先搜索</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BFS starting from vertex 0: &quot;</span>;</span><br><span class="line">    <span class="built_in">fill</span>(visited.<span class="built_in">begin</span>(), visited.<span class="built_in">end</span>(), <span class="literal">false</span>);  <span class="comment">// 重置访问标记</span></span><br><span class="line">    <span class="built_in">BFS</span>(<span class="number">0</span>, adjList, visited);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明：</p><ol><li><strong>邻接表的创建</strong>：用二维 <code>vector</code> 表示邻接表，其中 <code>adjList[i]</code> 存储顶点 <code>i</code> 的所有相邻顶点。</li><li><strong><code>addEdge</code></strong>：在邻接表中添加一条边。由于是无向图，所以需要添加双向连接。</li><li><strong>DFS</strong>：递归遍历所有相邻的未访问顶点，打印访问顺序。</li><li><strong>BFS</strong>：使用队列逐层遍历，打印访问顺序。</li><li><strong><code>visited</code></strong>：在 DFS 和 BFS 中用于标记访问过的顶点。</li></ol><h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DFS starting from vertex 0: 0 1 2 3 4 </span><br><span class="line">BFS starting from vertex 0: 0 1 2 3 4 </span><br></pre></td></tr></table></figure><ul><li><strong>DFS</strong> 先沿着一条路径深入，再回溯。</li><li><strong>BFS</strong> 逐层遍历，适合用于无权图中的最短路径查找。</li></ul><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>最小生成树（Minimum Spanning Tree，MST）。它用于找到一个无向加权连通图中连接所有顶点的最小代价子图。生成树的边数为 (V - 1)（其中 (V) 是顶点数），且没有环。生成树的总权重最小，即最小生成树。</p><h3 id="最小生成树的两个主要算法"><a href="#最小生成树的两个主要算法" class="headerlink" title="最小生成树的两个主要算法"></a>最小生成树的两个主要算法</h3><ol><li><p><strong>Kruskal 算法</strong>：</p><ul><li>基于“贪心算法”思想。</li><li>按权重从小到大排序所有边，并按顺序选择最小权重的边，只要它不形成环。</li><li>常用“并查集”来检测环。</li><li><strong>时间复杂度</strong>：(O(E \log E))，其中 (E) 是边数。</li></ul></li><li><p><strong>Prim 算法</strong>：</p><ul><li>也是基于“贪心算法”。</li><li>从任意一个顶点开始，将该顶点加入 MST，之后重复选择与已加入 MST 的顶点相邻的权重最小的边。</li><li>常用优先队列（最小堆）来优化边的选择。</li><li><strong>时间复杂度</strong>：(O(E \log V))。</li></ul></li></ol><h3 id="Kruskal-算法的实现（C-代码示例）"><a href="#Kruskal-算法的实现（C-代码示例）" class="headerlink" title="Kruskal 算法的实现（C++ 代码示例）"></a>Kruskal 算法的实现（C++ 代码示例）</h3><p>Kruskal 算法适合边较少的稀疏图，因为它的效率主要取决于边的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> src, dest, weight;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; other.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent, rank;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        rank.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[u] != u)</span><br><span class="line">            parent[u] = <span class="built_in">find</span>(parent[u]);  <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> parent[u];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootU = <span class="built_in">find</span>(u);</span><br><span class="line">        <span class="type">int</span> rootV = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (rootU == rootV)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// u 和 v 已经连接在一起</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootU] &gt; rank[rootV]) &#123;</span><br><span class="line">            parent[rootV] = rootU;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootU] &lt; rank[rootV]) &#123;</span><br><span class="line">            parent[rootU] = rootV;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootV] = rootU;</span><br><span class="line">            ++rank[rootU];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskalMST</span><span class="params">(<span class="type">int</span> V, vector&lt;Edge&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());  <span class="comment">// 按权重排序边</span></span><br><span class="line">    <span class="function">UnionFind <span class="title">uf</span><span class="params">(V)</span></span>;</span><br><span class="line">    <span class="type">int</span> mstWeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : edges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uf.<span class="built_in">unionSets</span>(edge.src, edge.dest)) &#123;  <span class="comment">// 无环则加入 MST</span></span><br><span class="line">            mstWeight += edge.weight;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Edge (&quot;</span> &lt;&lt; edge.src &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; edge.dest &lt;&lt; <span class="string">&quot;) with weight &quot;</span> &lt;&lt; edge.weight &lt;&lt; <span class="string">&quot; added to MST\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mstWeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">4</span>;  <span class="comment">// 顶点数</span></span><br><span class="line">    vector&lt;Edge&gt; edges = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Minimum Spanning Tree Weight: &quot;</span> &lt;&lt; <span class="built_in">kruskalMST</span>(V, edges) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Prim-算法的实现（C-代码示例）"><a href="#Prim-算法的实现（C-代码示例）" class="headerlink" title="Prim 算法的实现（C++ 代码示例）"></a>Prim 算法的实现（C++ 代码示例）</h3><p>Prim 算法适合边较多的稠密图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;  <span class="comment">// &#123;权重, 顶点&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">primMST</span><span class="params">(<span class="type">int</span> V, vector&lt;vector&lt;pii&gt;&gt;&amp; adjList)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">inMST</span><span class="params">(V, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;</span><br><span class="line">    <span class="type">int</span> mstWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从第 0 个顶点开始</span></span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [weight, u] = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inMST[u]) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        inMST[u] = <span class="literal">true</span>;</span><br><span class="line">        mstWeight += weight;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; u &lt;&lt; <span class="string">&quot; added to MST with edge weight &quot;</span> &lt;&lt; weight &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [neighborWeight, v] : adjList[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!inMST[v]) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;neighborWeight, v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mstWeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">4</span>;</span><br><span class="line">    vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">adjList</span>(V);</span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">10</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">6</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">5</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    adjList[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">10</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    adjList[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">15</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">6</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    adjList[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">5</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    adjList[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">15</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    adjList[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Minimum Spanning Tree Weight: &quot;</span> &lt;&lt; <span class="built_in">primMST</span>(V, adjList) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ul><li><strong>Kruskal 算法</strong>：<ul><li>使用 <code>UnionFind</code> 数据结构来管理连接和检测环。</li><li>按权重排序边，并依次检查，若边不会形成环，则将其加入 MST。</li></ul></li><li><strong>Prim 算法</strong>：<ul><li>从一个起始顶点出发，使用优先队列（最小堆）记录与已加入顶点相邻的最小边。</li><li>每次从优先队列中取出权重最小的边，将其对应的顶点加入 MST。</li></ul></li></ul><h3 id="输出示例-1"><a href="#输出示例-1" class="headerlink" title="输出示例"></a>输出示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Edge (2 - 3) with weight 4 added to MST</span><br><span class="line">Edge (0 - 3) with weight 5 added to MST</span><br><span class="line">Edge (0 - 1) with weight 10 added to MST</span><br><span class="line">Minimum Spanning Tree Weight: 19</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>Kruskal 算法</strong>：适合边较少的图，按边排序后添加到 MST。</li><li><strong>Prim 算法</strong>：适合边较多的图，优先从已连接的顶点选择最小的边。</li></ul><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>最短路径算法用于在加权图中查找从起点到终点的最短距离（权重和最小）路径。</p><h3 id="最短路径算法的主要方法"><a href="#最短路径算法的主要方法" class="headerlink" title="最短路径算法的主要方法"></a>最短路径算法的主要方法</h3><p><strong>Dijkstra 算法</strong>：</p><ul><li>适用于边权非负的图。</li><li>使用“贪心算法”思想，每次选择距离起点最近的顶点并更新它的邻接顶点。</li><li>利用优先队列（最小堆）实现效率更高的版本。</li><li><strong>时间复杂度</strong>：(O(E \log V))，其中 (E) 是边数，(V) 是顶点数。</li></ul><h3 id="Dijkstra-算法的实现（C-代码示例）"><a href="#Dijkstra-算法的实现（C-代码示例）" class="headerlink" title="Dijkstra 算法的实现（C++ 代码示例）"></a>Dijkstra 算法的实现（C++ 代码示例）</h3><p>Dijkstra 算法适用于边权为非负的图，特别适合用于单源最短路径问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;  <span class="comment">// &#123;距离, 顶点&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dijkstra算法求最短路径</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> V, vector&lt;vector&lt;pii&gt;&gt;&amp; adjList, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(V, numeric_limits&lt;<span class="type">int</span>&gt;::max())</span></span>;  <span class="comment">// 距离数组初始化为无穷大</span></span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;  <span class="comment">// 最小堆</span></span><br><span class="line"></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, start&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = pq.<span class="built_in">top</span>().second;</span><br><span class="line">        <span class="type">int</span> d = pq.<span class="built_in">top</span>().first;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (d &gt; dist[u]) <span class="keyword">continue</span>;  <span class="comment">// 跳过不需要更新的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [weight, v] : adjList[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[u] + weight &lt; dist[v]) &#123;  <span class="comment">// 如果找到更短路径</span></span><br><span class="line">                dist[v] = dist[u] + weight;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dist[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">5</span>;</span><br><span class="line">    vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">adjList</span>(V);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">10</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    adjList[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    adjList[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">8</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">5</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    adjList[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">4</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 起点</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; distances = <span class="built_in">dijkstra</span>(V, adjList, start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最短路径</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Shortest distances from vertex &quot;</span> &lt;&lt; start &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; distances[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><ul><li>使用最小堆实现贪心选择每次最短路径的顶点。</li><li>每次从堆中提取距离最小的顶点，检查其邻接顶点并更新距离。</li><li>时间复杂度 (O(E \log V)) 主要取决于堆操作。</li></ul><h3 id="SPFA（Shortest-Path-Faster-Algorithm）算法"><a href="#SPFA（Shortest-Path-Faster-Algorithm）算法" class="headerlink" title="SPFA（Shortest Path Faster Algorithm）算法"></a><strong>SPFA（Shortest Path Faster Algorithm）算法</strong></h3><ul><li><strong>原理</strong>：SPFA 算法是 Bellman-Ford 的改进版，利用队列来加速松弛过程。SPFA 仅对需要更新的节点进行处理，不必在每一轮松弛时遍历所有边。</li><li><strong>适用场景</strong>：通常在大部分边为正、且负权边较少的图中，SPFA 表现非常好。</li><li><strong>时间复杂度</strong>：最坏情况下为 (O(V \times E))，但在实际应用中通常远优于 Bellman-Ford。平均复杂度接近 (O(E))。</li></ul><h2 id="SPFA-算法实现示例："><a href="#SPFA-算法实现示例：" class="headerlink" title="SPFA 算法实现示例："></a><strong>SPFA 算法实现示例：</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> dest, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> V, vector&lt;vector&lt;Edge&gt;&gt;&amp; adjList, <span class="type">int</span> start, vector&lt;<span class="type">int</span>&gt;&amp; dist)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">inQueue</span><span class="params">(V, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(V, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dist.<span class="built_in">assign</span>(V, numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    inQueue[start] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        inQueue[u] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : adjList[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = edge.dest;</span><br><span class="line">            <span class="type">int</span> weight = edge.weight;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dist[u] != numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>() &amp;&amp; dist[u] + weight &lt; dist[v]) &#123;</span><br><span class="line">                dist[v] = dist[u] + weight;</span><br><span class="line">                <span class="keyword">if</span> (!inQueue[v]) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    inQueue[v] = <span class="literal">true</span>;</span><br><span class="line">                    count[v]++;</span><br><span class="line">                    <span class="keyword">if</span> (count[v] &gt; V - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 检测到负权环</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 没有负权环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">5</span>;</span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">adjList</span>(V);</span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">10</span>&#125;);</span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    adjList[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    adjList[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">8</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    adjList[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">4</span>&#125;);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dist;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SPFA</span>(V, adjList, start, dist)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Shortest distances from vertex &quot;</span> &lt;&lt; start &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; dist[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Graph contains a negative weight cycle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>拓扑排序（Topological Sorting）用于有向无环图（DAG）中，对图中的节点进行线性排序，以满足每个有向边 ( u \rightarrow v ) 中节点 ( u ) 必须排在节点 ( v ) 之前的要求。拓扑排序常用于解决依赖关系问题，比如任务调度、编译依赖等。</p><h3 id="拓扑排序的基本原理"><a href="#拓扑排序的基本原理" class="headerlink" title="拓扑排序的基本原理"></a>拓扑排序的基本原理</h3><ol><li><p><strong>前提条件</strong>：</p><ul><li>拓扑排序只能在 <strong>有向无环图（DAG）</strong> 上实现，因为如果有环存在，就无法对节点进行线性排序。</li></ul></li><li><p><strong>拓扑排序方法</strong>：</p><ul><li>拓扑排序的实现通常有两种方法：<strong>DFS</strong> 和 <strong>Kahn 算法（BFS）</strong>。</li></ul></li><li><p><strong>主要步骤</strong>：</p><ul><li><strong>DFS法</strong>：对每个未访问的节点进行 DFS 遍历，当遍历到没有后续节点时，将该节点记录下来。这样会得到一个逆序的排序结果。</li><li><strong>Kahn 算法（BFS）</strong>：利用入度的概念，将入度为 0 的节点依次加入队列，处理该节点后将其指向的节点入度减一，并将新入度为 0 的节点加入队列，直至队列为空。</li></ul></li></ol><h3 id="拓扑排序的两种实现"><a href="#拓扑排序的两种实现" class="headerlink" title="拓扑排序的两种实现"></a>拓扑排序的两种实现</h3><h4 id="方法一：DFS-法"><a href="#方法一：DFS-法" class="headerlink" title="方法一：DFS 法"></a>方法一：DFS 法</h4><p>DFS 法适合用递归的方式实现。</p><p><strong>代码实现</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topologicalSortDFS</span><span class="params">(<span class="type">int</span> v, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList, vector&lt;<span class="type">bool</span>&gt;&amp; visited, stack&lt;<span class="type">int</span>&gt;&amp; topoStack)</span> </span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有邻接节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            <span class="built_in">topologicalSortDFS</span>(neighbor, adjList, visited, topoStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点处理完毕，加入栈中</span></span><br><span class="line">    topoStack.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topologicalSort</span><span class="params">(<span class="type">int</span> V, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(V, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; topoStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有节点，进行 DFS</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="built_in">topologicalSortDFS</span>(i, adjList, visited, topoStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出拓扑排序结果</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Topological Sort (DFS): &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!topoStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; topoStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        topoStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">6</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjList</span>(V);</span><br><span class="line">    adjList[<span class="number">5</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    adjList[<span class="number">5</span>].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    adjList[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    adjList[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    adjList[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">topologicalSort</span>(V, adjList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Topological Sort (DFS): 5 4 2 3 1 0</span><br></pre></td></tr></table></figure><h4 id="方法二：Kahn-算法（BFS-法）"><a href="#方法二：Kahn-算法（BFS-法）" class="headerlink" title="方法二：Kahn 算法（BFS 法）"></a>方法二：Kahn 算法（BFS 法）</h4><p>Kahn 算法通过入度（in-degree）来实现拓扑排序：</p><ol><li>计算每个节点的入度，将入度为 0 的节点加入队列。</li><li>依次从队列中取出节点，输出其编号。</li><li>将该节点指向的所有节点的入度减 1，如果入度变为 0，则将该节点加入队列。</li><li>直到队列为空，最终的输出顺序即为拓扑排序结果。</li></ol><p><strong>代码实现</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topologicalSortKahn</span><span class="params">(<span class="type">int</span> V, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(V, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个节点的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[i]) &#123;</span><br><span class="line">            inDegree[neighbor]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将入度为 0 的节点加入队列</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kahn&#x27;s algorithm</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Topological Sort (Kahn&#x27;s Algorithm): &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有邻接节点，将其入度减 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[u]) &#123;</span><br><span class="line">            inDegree[neighbor]--;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[neighbor] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">6</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjList</span>(V);</span><br><span class="line">    adjList[<span class="number">5</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    adjList[<span class="number">5</span>].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    adjList[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    adjList[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    adjList[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">topologicalSortKahn</span>(V, adjList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Topological Sort (Kahn&#x27;s Algorithm): 4 5 0 2 3 1</span><br></pre></td></tr></table></figure><h3 id="拓扑排序方法总结"><a href="#拓扑排序方法总结" class="headerlink" title="拓扑排序方法总结"></a>拓扑排序方法总结</h3><div class="table-container"><table><thead><tr><th>方法</th><th>主要步骤</th><th>复杂度</th><th>优缺点</th></tr></thead><tbody><tr><td>DFS 法</td><td>DFS 遍历节点，将节点按逆序入栈</td><td>(O(V + E))</td><td>适合递归实现，空间开销较少</td></tr><tr><td>Kahn 算法（BFS 法）</td><td>计算入度，队列处理入度为 0 的节点</td><td>(O(V + E))</td><td>不适合递归实现，但逻辑较直观</td></tr></tbody></table></div><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>有环图无法拓扑排序</strong>：如果在 Kahn 算法中，无法输出所有节点，则说明存在环；在 DFS 法中若检测到回到已访问节点则说明有环。</li></ul><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>关键路径算法（Critical Path Method, CPM）主要用于 <strong>有向无环图（DAG）</strong> 中的 <strong>任务调度问题</strong>，帮助确定任务的最长路径（即关键路径）以及项目的最短完成时间。关键路径中的任务没有时间余地，一旦延迟会导致项目整体延误。</p><h3 id="关键路径的基本原理"><a href="#关键路径的基本原理" class="headerlink" title="关键路径的基本原理"></a>关键路径的基本原理</h3><ol><li><p><strong>事件的最早开始时间（earliest start, ES）</strong>：</p><ul><li>从起点向终点计算，在满足所有前序任务完成的情况下，每个任务可以开始的最早时间。</li></ul></li><li><p><strong>事件的最晚开始时间（latest start, LS）</strong>：</p><ul><li>从终点向起点反向计算，在不延迟项目总工期的前提下，每个任务可以推迟到的最晚开始时间。</li></ul></li><li><p><strong>计算方法</strong>：</p><ul><li>通过 <strong>正向遍历</strong> 和 <strong>反向遍历</strong>，分别计算每个任务的最早和最晚完成时间。</li><li><strong>关键路径</strong>是从起点到终点的最长路径（即时间最长的路径），这条路径上的所有任务都为关键任务，任何一个任务的延迟都会影响整个项目的工期。</li></ul></li></ol><h3 id="关键路径的实现（C-代码）"><a href="#关键路径的实现（C-代码）" class="headerlink" title="关键路径的实现（C++ 代码）"></a>关键路径的实现（C++ 代码）</h3><p>假设任务的关系以有向无环图的邻接表形式给出，图中每个节点表示一个任务，边表示任务依赖，边的权重表示任务所需时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> dest, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topologicalSort</span><span class="params">(<span class="type">int</span> v, vector&lt;vector&lt;Edge&gt;&gt;&amp; adjList, vector&lt;<span class="type">bool</span>&gt;&amp; visited, stack&lt;<span class="type">int</span>&gt;&amp; topoStack)</span> </span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : adjList[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[edge.dest]) &#123;</span><br><span class="line">            <span class="built_in">topologicalSort</span>(edge.dest, adjList, visited, topoStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    topoStack.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键路径算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">criticalPath</span><span class="params">(<span class="type">int</span> V, vector&lt;vector&lt;Edge&gt;&gt;&amp; adjList)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">earliest</span><span class="params">(V, <span class="number">0</span>)</span></span>;  <span class="comment">// 存储最早开始时间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">latest</span><span class="params">(V, numeric_limits&lt;<span class="type">int</span>&gt;::max())</span></span>;  <span class="comment">// 存储最晚开始时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 拓扑排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(V, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; topoStack;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="built_in">topologicalSort</span>(i, adjList, visited, topoStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 正向计算最早开始时间（earliest start time）</span></span><br><span class="line">    <span class="keyword">while</span> (!topoStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = topoStack.<span class="built_in">top</span>();</span><br><span class="line">        topoStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : adjList[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = edge.dest;</span><br><span class="line">            earliest[v] = <span class="built_in">max</span>(earliest[v], earliest[u] + edge.weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 反向计算最晚开始时间（latest start time）</span></span><br><span class="line">    <span class="type">int</span> projectDuration = *<span class="built_in">max_element</span>(earliest.<span class="built_in">begin</span>(), earliest.<span class="built_in">end</span>());  <span class="comment">// 项目总工期</span></span><br><span class="line">    <span class="built_in">fill</span>(latest.<span class="built_in">begin</span>(), latest.<span class="built_in">end</span>(), projectDuration);  <span class="comment">// 初始化最晚时间为项目总工期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = V - <span class="number">1</span>; u &gt;= <span class="number">0</span>; u--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : adjList[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = edge.dest;</span><br><span class="line">            latest[u] = <span class="built_in">min</span>(latest[u], latest[v] - edge.weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 找到关键路径</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Critical Path: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : adjList[i]) &#123;</span><br><span class="line">            <span class="type">int</span> j = edge.dest;</span><br><span class="line">            <span class="keyword">if</span> (earliest[i] == latest[i] &amp;&amp; earliest[i] + edge.weight == earliest[j]) &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;End&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> projectDuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">6</span>;</span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">adjList</span>(V);</span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    adjList[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    adjList[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    adjList[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">5</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    adjList[<span class="number">4</span>].<span class="built_in">push_back</span>(&#123;<span class="number">5</span>, <span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> projectDuration = <span class="built_in">criticalPath</span>(V, adjList);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Project Duration: &quot;</span> &lt;&lt; projectDuration &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释-2"><a href="#代码解释-2" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><p><strong>拓扑排序</strong>：</p><ul><li>由于关键路径算法应用于有向无环图（DAG），首先对图进行拓扑排序，便于按依赖顺序处理任务。</li><li><code>topologicalSort</code> 函数使用递归 DFS 实现拓扑排序。</li></ul></li><li><p><strong>正向遍历计算最早开始时间</strong>：</p><ul><li>从拓扑排序后的起点开始，根据前序任务的最早完成时间计算每个任务的最早开始时间。</li></ul></li><li><p><strong>反向遍历计算最晚开始时间</strong>：</p><ul><li>从终点倒着计算，尽量推迟任务时间（保证不影响总工期），计算每个任务的最晚开始时间。</li><li>使用 <code>fill</code> 将 <code>latest</code> 数组初始化为总工期，这样可以方便地更新最晚开始时间。</li></ul></li><li><p><strong>关键路径</strong>：</p><ul><li>关键路径上的任务满足 <code>earliest[i] == latest[i]</code>，即任务的最早开始时间等于最晚开始时间。通过检查每条边的权重和关键任务条件，确定关键路径并输出。</li></ul></li></ol><h3 id="输出示例-2"><a href="#输出示例-2" class="headerlink" title="输出示例"></a>输出示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Critical Path: 0 -&gt; 1 -&gt; 3 -&gt; 5 -&gt; End</span><br><span class="line">Project Duration: 8</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>关键路径</strong> 是整个项目的最长路径。沿关键路径的所有任务必须按时完成，以免延误项目。</li><li>关键路径算法利用 <strong>拓扑排序</strong> 来确保按依赖关系遍历任务。</li></ul><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;图&quot;&gt;&lt;a href=&quot;#图&quot; class=&quot;headerlink&quot; title=&quot;图&quot;&gt;&lt;/a&gt;图&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;图（Graph）&lt;/strong&gt;</summary>
        
      
    
    
    
    <category term="数据结构" scheme="https://blog.whff521.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="图" scheme="https://blog.whff521.xyz/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://blog.whff521.xyz/2024/10/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://blog.whff521.xyz/2024/10/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2024-10-30T14:25:58.000Z</published>
    <updated>2024-10-30T15:07:17.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p><strong>并查集</strong>（Disjoint Set Union, DSU）是一种数据结构，用于处理<strong>不相交集合</strong>（disjoint sets）的合并（union）和查询（find）操作。并查集特别适用于动态连通性问题，例如判断两个元素是否在同一个集合中或合并两个集合。广泛应用在图论算法中，比如 Kruskal 最小生成树算法。</p><h3 id="并查集的概念"><a href="#并查集的概念" class="headerlink" title="并查集的概念"></a>并查集的概念</h3><p>并查集主要支持两个操作：</p><ol><li><strong>查找（Find）</strong>：确定元素所属的集合。通常返回集合的“代表元素”。</li><li><strong>合并（Union）</strong>：将两个集合合并成一个集合。</li></ol><p>并查集使用<strong>树结构</strong>来表示集合，每个集合中的元素都指向一个根节点，根节点代表该集合。为优化效率，通常使用以下两种技术：</p><ul><li><strong>路径压缩（Path Compression）</strong>：在查找操作中，将树的高度降低，使得查找的时间复杂度接近常数。</li><li><strong>按秩合并（Union by Rank）</strong>：在合并操作中，将较小的树合并到较大的树上，避免树变得过于深。</li></ul><h3 id="并查集的性质"><a href="#并查集的性质" class="headerlink" title="并查集的性质"></a>并查集的性质</h3><ol><li><strong>时间复杂度</strong>：使用路径压缩和按秩合并的并查集可以将单次操作的平均时间复杂度优化到几乎为常数，接近 $O(\alpha(n))$ ，其中 $(\alpha)$ 是阿克曼函数的逆，非常接近常数。</li><li><strong>空间复杂度</strong>：并查集使用 (O(n)) 的空间，其中 (n) 为元素个数。</li></ol><h3 id="并查集的-C-实现"><a href="#并查集的-C-实现" class="headerlink" title="并查集的 C++ 实现"></a>并查集的 C++ 实现</h3><p>以下是并查集的标准实现代码，包含路径压缩和按秩合并优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisjointSet</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;  <span class="comment">// 存储每个节点的父节点</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rank;    <span class="comment">// 存储树的高度（秩）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="built_in">DisjointSet</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        rank.<span class="built_in">resize</span>(n, <span class="number">0</span>);  <span class="comment">// 初始秩为 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;  <span class="comment">// 每个节点的父节点初始化为自己</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找操作，带路径压缩</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = <span class="built_in">find</span>(parent[x]);  <span class="comment">// 递归查找并路径压缩</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并操作，按秩合并</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">            <span class="comment">// 将秩低的树合并到秩高的树上</span></span><br><span class="line">            <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">                parent[rootY] = rootX;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">                parent[rootX] = rootY;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootY] = rootX;</span><br><span class="line">                rank[rootX]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查两个元素是否在同一个集合中</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">DisjointSet <span class="title">ds</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 创建包含10个元素的并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并一些集合</span></span><br><span class="line">    ds.<span class="built_in">unionSets</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    ds.<span class="built_in">unionSets</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    ds.<span class="built_in">unionSets</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    ds.<span class="built_in">unionSets</span>(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询集合连接情况</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is 1 connected to 3? &quot;</span> &lt;&lt; (ds.<span class="built_in">isConnected</span>(<span class="number">1</span>, <span class="number">3</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is 1 connected to 4? &quot;</span> &lt;&lt; (ds.<span class="built_in">isConnected</span>(<span class="number">1</span>, <span class="number">4</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并更多集合</span></span><br><span class="line">    ds.<span class="built_in">unionSets</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is 1 connected to 5 after union? &quot;</span> &lt;&lt; (ds.<span class="built_in">isConnected</span>(<span class="number">1</span>, <span class="number">5</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><p><strong>初始化</strong>：</p><ul><li><code>parent</code> 数组存储每个节点的父节点，初始时每个节点的父节点是自己，表示每个元素独立的集合。</li><li><code>rank</code> 数组存储每个集合的秩，初始为 <code>0</code>。</li></ul></li><li><p><strong>查找操作 <code>find</code></strong>：</p><ul><li>通过递归查找，找到元素所属集合的根节点，并进行路径压缩，将路径上的所有节点直接连接到根节点。</li><li>路径压缩可以减少后续查找操作的时间复杂度。</li></ul></li><li><p><strong>合并操作 <code>unionSets</code></strong>：</p><ul><li>先找到两个元素所属集合的根节点，通过秩大小决定合并方向。</li><li>将低秩的集合合并到高秩集合上，以保持树的高度较低；如果秩相同，将任意一个根连接到另一个根，同时增加连接根的秩。</li></ul></li><li><p><strong>连接检查 <code>isConnected</code></strong>：</p><ul><li>检查两个元素是否属于同一集合，如果根节点相同则属于同一集合。</li></ul></li></ol><h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h3><p>假设输入是如上代码中的操作，输出将如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Is 1 connected to 3? Yes</span><br><span class="line">Is 1 connected to 4? No</span><br><span class="line">Is 1 connected to 5 after union? Yes</span><br></pre></td></tr></table></figure><p>通过路径压缩和按秩合并优化后的并查集，能够高效地支持合并和查找操作。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;并查集&lt;/strong&gt;（Disjoint Set Union,</summary>
        
      
    
    
    
    <category term="数据结构" scheme="https://blog.whff521.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="并查集" scheme="https://blog.whff521.xyz/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="https://blog.whff521.xyz/2024/10/30/%E6%A0%91/"/>
    <id>https://blog.whff521.xyz/2024/10/30/%E6%A0%91/</id>
    <published>2024-10-30T09:00:01.000Z</published>
    <updated>2024-10-30T14:23:54.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>在数据结构中，<strong>树</strong>（Tree）是一种分层的非线性数据结构，它由节点（node）和边（edge）组成，并且具有以下性质：</p><h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><ol><li><strong>节点和边</strong>：树包含一组节点，通过边连接，节点之间呈现出层级关系。</li><li><strong>根节点</strong>：树的起始节点称为根节点（root），通常位于树的顶端。</li><li><strong>父节点和子节点</strong>：每个节点可以连接其他节点，称为子节点（children）；连接它们的节点称为父节点（parent）。</li><li><strong>叶子节点</strong>：没有子节点的节点称为叶子节点（leaf）。</li><li><strong>层级</strong>：树的每一层从根节点开始，按层级关系排列。</li><li><strong>路径</strong>：节点之间的路径由节点和边组成，从根节点到某个特定节点的路径是节点之间的唯一路径。</li></ol><h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2><ol><li><strong>唯一根节点</strong>：树中只有一个根节点，没有父节点。</li><li><strong>节点数量关系</strong>：有 ( n ) 个节点的树，边的数量为 ( n - 1 )。</li><li><strong>层次性</strong>：树具有层次结构，自上而下逐级分层。</li><li><strong>无回路性</strong>：树中不存在回路，任何两个节点之间只有唯一一条路径。</li><li><strong>连通性</strong>：树是一个连通的无向图，从根节点可以到达所有节点。</li></ol><h2 id="特殊类型的树"><a href="#特殊类型的树" class="headerlink" title="特殊类型的树"></a>特殊类型的树</h2><ul><li><strong>二叉树</strong>：每个节点最多只有两个子节点的树。</li><li><strong>完全二叉树</strong>：除最后一层外，所有层的节点数都达到最大值，且最后一层节点从左到右连续排列。</li><li><strong>平衡二叉树</strong>：任意节点的左右子树高度差不超过一定值（如 AVL 树）。</li><li><strong>二叉搜索树（BST）</strong>：左子节点的值小于根节点，右子节点的值大于根节点，便于快速查找。</li></ul><p>好的，这里是考试大纲所涉及的二叉树和树的基本概念、性质和C++的实现示例：</p><h2 id="二叉树的概念、性质和实现"><a href="#二叉树的概念、性质和实现" class="headerlink" title="二叉树的概念、性质和实现"></a>二叉树的概念、性质和实现</h2><p><strong>二叉树</strong>是每个节点最多有两个子节点的树结构。每个节点的子节点通常被称为左子节点和右子节点。</p><p><strong>性质</strong>：</p><ol><li>二叉树的第 (i) 层最多有 (2^{i-1}) 个节点。</li><li>高度为 (h) 的二叉树最多有 (2^h - 1) 个节点。</li><li>完全二叉树和满二叉树是特殊的二叉树。</li></ol><p><strong>实现</strong>（链式存储）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点示例</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;val) root-&gt;left = <span class="built_in">insert</span>(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;right = <span class="built_in">insert</span>(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="二叉树的顺序存储结构和链式存储结构"><a href="#二叉树的顺序存储结构和链式存储结构" class="headerlink" title="二叉树的顺序存储结构和链式存储结构"></a>二叉树的顺序存储结构和链式存储结构</h2><p><strong>顺序存储结构</strong>：顺序存储通常使用数组存储完全二叉树。第 (i) 个节点的左子节点在 (2i+1)，右子节点在 (2i+2)。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> binaryTree[<span class="number">100</span>];  <span class="comment">// 顺序存储二叉树的数组表示</span></span><br></pre></td></tr></table></figure></p><p><strong>链式存储结构</strong>：链式存储用指针实现更灵活，适用于非完全二叉树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p><strong>前序遍历</strong>、<strong>中序遍历</strong>、<strong>后序遍历</strong>和<strong>层序遍历</strong>是常见的二叉树遍历方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历 (根 -&gt; 左 -&gt; 右)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历 (左 -&gt; 根 -&gt; 右)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">        cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历 (左 -&gt; 右 -&gt; 根)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="built_in">postorder</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">postorder</span>(root-&gt;right);</span><br><span class="line">        cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树和森林的存储结构、遍历"><a href="#树和森林的存储结构、遍历" class="headerlink" title="树和森林的存储结构、遍历"></a>树和森林的存储结构、遍历</h2><p><strong>树的存储</strong>：一般用链式结构存储树（多叉树），每个节点指向多个子节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    vector&lt;TreeNode*&gt; children;  <span class="comment">// 每个节点可以有多个子节点</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>森林的概念</strong>：森林是一组互不相交的树的集合。常用递归将森林表示为一棵树，每棵树的根节点作为链式存储的下一节点。</p><p><strong>遍历森林</strong>：可以通过先序、后序等遍历方式实现，每个子树递归遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverseForest</span><span class="params">(<span class="type">const</span> vector&lt;TreeNode*&gt;&amp; forest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode* tree : forest) &#123;</span><br><span class="line">        <span class="built_in">preorder</span>(tree);  <span class="comment">// 遍历每棵树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆与优先队列"><a href="#堆与优先队列" class="headerlink" title="堆与优先队列"></a>堆与优先队列</h2><p><strong>堆</strong>是一种特殊的二叉树，是完全二叉树的一种。堆有两种常见的类型：<strong>最大堆</strong>和<strong>最小堆</strong>。</p><ul><li><strong>最大堆</strong>：每个父节点的值都大于等于其子节点的值，根节点是堆中最大的元素。</li><li><strong>最小堆</strong>：每个父节点的值都小于等于其子节点的值，根节点是堆中最小的元素。</li></ul><h3 id="堆的性质"><a href="#堆的性质" class="headerlink" title="堆的性质"></a>堆的性质</h3><ol><li><strong>完全二叉树</strong>：堆使用完全二叉树的结构，因此适合用数组表示。</li><li><strong>节点关系</strong>：在堆的数组表示中，对于第 <code>i</code> 个节点：<ul><li>父节点位置为 <code>(i-1)/2</code>。</li><li>左子节点位置为 <code>2i+1</code>。</li><li>右子节点位置为 <code>2i+2</code>。</li></ul></li></ol><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p><strong>优先队列</strong>是一种基于堆的数据结构，可以快速访问和删除优先级最高（或最低）的元素。在 C++ 中，标准库提供了 <code>priority_queue</code>，其默认实现为最大堆。</p><h4 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h4><p>以下是一个最大堆的简单实现，包括插入和删除最大值的操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">heapifyUp</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> parent = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (heap[index] &gt; heap[parent]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(heap[index], heap[parent]);</span><br><span class="line">                index = parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">heapifyDown</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = heap.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; size) &#123;</span><br><span class="line">            <span class="type">int</span> leftChild = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> rightChild = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> largerChild = leftChild;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rightChild &lt; size &amp;&amp; heap[rightChild] &gt; heap[leftChild]) &#123;</span><br><span class="line">                largerChild = rightChild;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (heap[index] &lt; heap[largerChild]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(heap[index], heap[largerChild]);</span><br><span class="line">                index = largerChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        heap.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="built_in">heapifyUp</span>(heap.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> maxVal = heap[<span class="number">0</span>];</span><br><span class="line">        heap[<span class="number">0</span>] = heap.<span class="built_in">back</span>();</span><br><span class="line">        heap.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">heapifyDown</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> maxVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MaxHeap heap;</span><br><span class="line">    heap.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    heap.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    heap.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Extracted Max: &quot;</span> &lt;&lt; heap.<span class="built_in">extractMax</span>() &lt;&lt; endl;  <span class="comment">// 输出 20</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Extracted Max: &quot;</span> &lt;&lt; heap.<span class="built_in">extractMax</span>() &lt;&lt; endl;  <span class="comment">// 输出 15</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Extracted Max: &quot;</span> &lt;&lt; heap.<span class="built_in">extractMax</span>() &lt;&lt; endl;  <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优先队列的实现（C-标准库）"><a href="#优先队列的实现（C-标准库）" class="headerlink" title="优先队列的实现（C++ 标准库）"></a>优先队列的实现（C++ 标准库）</h4><p>C++ STL 提供了 <code>priority_queue</code>，默认是最大堆，但可以通过传递自定义比较器来实现最小堆。</p><p>好的，以下是一个直接实现的<strong>优先队列</strong>，不依赖 C++ 标准模板库（STL）。我们将使用<strong>最大堆</strong>的方式来实现优先队列，可以快速地获取最大值并进行插入和删除操作。最小堆的实现方式类似，只需调整比较逻辑。</p><h4 id="基于最大堆的优先队列实现"><a href="#基于最大堆的优先队列实现" class="headerlink" title="基于最大堆的优先队列实现"></a>基于最大堆的优先队列实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heap; <span class="comment">// 使用数组来表示堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上浮操作，用于插入元素后调整堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">heapifyUp</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> parent = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (heap[index] &gt; heap[parent]) &#123; <span class="comment">// 如果当前节点大于父节点，交换位置</span></span><br><span class="line">                <span class="built_in">swap</span>(heap[index], heap[parent]);</span><br><span class="line">                index = parent; <span class="comment">// 更新当前节点为父节点位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉操作，用于删除元素后调整堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">heapifyDown</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = heap.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; size) &#123; <span class="comment">// 只需检查左子节点存在的情况</span></span><br><span class="line">            <span class="type">int</span> leftChild = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> rightChild = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> largerChild = leftChild;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到较大的子节点</span></span><br><span class="line">            <span class="keyword">if</span> (rightChild &lt; size &amp;&amp; heap[rightChild] &gt; heap[leftChild]) &#123;</span><br><span class="line">                largerChild = rightChild;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前节点小于较大的子节点，交换</span></span><br><span class="line">            <span class="keyword">if</span> (heap[index] &lt; heap[largerChild]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(heap[index], heap[largerChild]);</span><br><span class="line">                index = largerChild; <span class="comment">// 更新当前节点为交换后的子节点位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        heap.<span class="built_in">push_back</span>(val);  <span class="comment">// 添加到堆的末尾</span></span><br><span class="line">        <span class="built_in">heapifyUp</span>(heap.<span class="built_in">size</span>() - <span class="number">1</span>); <span class="comment">// 调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;PriorityQueue is empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除最大元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;PriorityQueue is empty&quot;</span>);</span><br><span class="line">        heap[<span class="number">0</span>] = heap.<span class="built_in">back</span>();  <span class="comment">// 将最后一个元素移到堆顶</span></span><br><span class="line">        heap.<span class="built_in">pop_back</span>();  <span class="comment">// 删除最后一个元素</span></span><br><span class="line">        <span class="built_in">heapifyDown</span>(<span class="number">0</span>); <span class="comment">// 调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PriorityQueue pq;</span><br><span class="line"></span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Top Element: &quot;</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; endl;  <span class="comment">// 输出 20</span></span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Top Element after pop: &quot;</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; endl;  <span class="comment">// 输出 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释</p><ol><li><p><strong><code>push</code> 方法</strong>：将新元素插入堆的末尾，之后调用 <code>heapifyUp</code> 进行上浮调整，保证堆的最大性质。</p></li><li><p><strong><code>top</code> 方法</strong>：返回堆顶元素，即优先级最高的元素（最大值）。</p></li><li><p><strong><code>pop</code> 方法</strong>：删除堆顶元素，将堆的最后一个元素移到堆顶，并调用 <code>heapifyDown</code> 进行下沉调整，保证堆的最大性质。</p></li><li><p><strong><code>heapifyUp</code> 和 <code>heapifyDown</code> 方法</strong>：维护堆的性质，分别用于元素插入和删除后的调整操作。</p></li></ol><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p><strong>二叉排序树</strong>（Binary Search Tree, BST）是一种特殊的二叉树，用于快速查找、插入和删除操作。BST 在很多应用中用于构建集合和字典。</p><h3 id="二叉排序树的概念"><a href="#二叉排序树的概念" class="headerlink" title="二叉排序树的概念"></a>二叉排序树的概念</h3><ul><li><strong>二叉排序树</strong>是一种有序的二叉树。对于 BST 中的每个节点 <code>N</code>，满足以下性质：<ol><li><strong>左子树</strong>所有节点的值小于 <code>N</code> 节点的值。</li><li><strong>右子树</strong>所有节点的值大于 <code>N</code> 节点的值。</li><li>左右子树也是二叉排序树。</li></ol></li></ul><h3 id="二叉排序树的性质"><a href="#二叉排序树的性质" class="headerlink" title="二叉排序树的性质"></a>二叉排序树的性质</h3><ol><li><strong>查找、插入和删除操作</strong>的时间复杂度平均为 <code>O(log n)</code>，最坏情况下为 <code>O(n)</code>，当 BST 退化为链表（即每个节点只有一个子节点）时会达到最坏情况。</li><li><strong>中序遍历</strong>可以得到一个升序的序列。</li><li>二叉排序树不允许有重复的节点。</li></ol><h3 id="二叉排序树的简洁-C-实现"><a href="#二叉排序树的简洁-C-实现" class="headerlink" title="二叉排序树的简洁 C++ 实现"></a>二叉排序树的简洁 C++ 实现</h3><p>以下是一个简单的 C++ 实现，包括插入、查找和删除操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);  <span class="comment">// 空节点，创建新节点</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; root-&gt;val)</span><br><span class="line">            root-&gt;left = <span class="built_in">insert</span>(root-&gt;left, val);  <span class="comment">// 插入左子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val)</span><br><span class="line">            root-&gt;right = <span class="built_in">insert</span>(root-&gt;right, val); <span class="comment">// 插入右子树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 空节点表示未找到</span></span><br><span class="line">        <span class="keyword">if</span> (val == root-&gt;val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">search</span>(root-&gt;left, val);  <span class="comment">// 在左子树中查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">search</span>(root-&gt;right, val); <span class="comment">// 在右子树中查找</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">remove</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; root-&gt;val)</span><br><span class="line">            root-&gt;left = <span class="built_in">remove</span>(root-&gt;left, val);  <span class="comment">// 删除左子树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val)</span><br><span class="line">            root-&gt;right = <span class="built_in">remove</span>(root-&gt;right, val); <span class="comment">// 删除右子树节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 找到要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (!root-&gt;left) &#123;</span><br><span class="line">                TreeNode* rightChild = root-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> rightChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;right) &#123;</span><br><span class="line">                TreeNode* leftChild = root-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> leftChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 有两个子节点</span></span><br><span class="line">                TreeNode* minNode = <span class="built_in">getMin</span>(root-&gt;right);</span><br><span class="line">                root-&gt;val = minNode-&gt;val;  <span class="comment">// 用右子树中的最小节点替换当前节点</span></span><br><span class="line">                root-&gt;right = <span class="built_in">remove</span>(root-&gt;right, minNode-&gt;val); <span class="comment">// 删除右子树中的最小节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小节点</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">getMin</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root-&gt;left) root = root-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历（输出树中节点的值）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">            cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BinarySearchTree bst;</span><br><span class="line">    TreeNode* root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    root = bst.<span class="built_in">insert</span>(root, <span class="number">50</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(root, <span class="number">30</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(root, <span class="number">20</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(root, <span class="number">40</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(root, <span class="number">70</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(root, <span class="number">60</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(root, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历（输出有序序列）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Inorder traversal: &quot;</span>;</span><br><span class="line">    bst.<span class="built_in">inorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找节点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Search for 40: &quot;</span> &lt;&lt; (bst.<span class="built_in">search</span>(root, <span class="number">40</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not found&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    root = bst.<span class="built_in">remove</span>(root, <span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Inorder traversal after deleting 20: &quot;</span>;</span><br><span class="line">    bst.<span class="built_in">inorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释</p><ol><li><strong>插入节点</strong>：递归地找到正确的插入位置，将节点添加到左子树或右子树。</li><li><strong>查找节点</strong>：根据值在左子树或右子树中递归查找。</li><li><strong>删除节点</strong>：<ul><li>如果要删除的节点没有子节点，直接删除。</li><li>如果只有一个子节点，用子节点替换当前节点。</li><li>如果有两个子节点，用右子树中最小的节点替换当前节点，然后删除替换节点。</li></ul></li><li><strong>中序遍历</strong>：按照左子树 -&gt; 根节点 -&gt; 右子树的顺序遍历节点，输出排序后的值。</li></ol><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><strong>平衡二叉树</strong>（Balanced Binary Tree）是一种改进的二叉搜索树，它保证树的高度保持平衡，从而避免最坏情况下退化为链表。常见的平衡二叉树包括 <strong>AVL树</strong> 和 <strong>红黑树</strong>。这里以 <strong>AVL树</strong> 为例，来介绍平衡二叉树的概念、性质以及实现。</p><h3 id="平衡二叉树的概念和性质"><a href="#平衡二叉树的概念和性质" class="headerlink" title="平衡二叉树的概念和性质"></a>平衡二叉树的概念和性质</h3><ol><li><p><strong>平衡因子</strong>：每个节点的左子树和右子树的高度差不超过1，称为平衡二叉树。具体来说，对于 AVL 树，任一节点的平衡因子（左子树高度减去右子树高度的差）只能是 -1、0 或 1。</p></li><li><p><strong>自平衡</strong>：在插入或删除节点后，AVL 树会通过旋转操作（如单旋转、双旋转）来恢复平衡。</p></li><li><p><strong>查找、插入和删除操作的时间复杂度</strong>为 (O(\log n))，这是因为 AVL 树总是保持平衡，树的高度始终为 (O(\log n))。</p></li></ol><h3 id="AVL-树的旋转操作"><a href="#AVL-树的旋转操作" class="headerlink" title="AVL 树的旋转操作"></a>AVL 树的旋转操作</h3><ul><li><strong>左旋</strong>：右子树高度大于左子树时，将右子节点旋转为根节点。</li><li><strong>右旋</strong>：左子树高度大于右子树时，将左子节点旋转为根节点。</li><li><strong>双旋转</strong>：当插入节点破坏平衡因子后，先进行一次左旋或右旋，再进行一次右旋或左旋。</li></ul><h3 id="AVL-树的简洁-C-实现"><a href="#AVL-树的简洁-C-实现" class="headerlink" title="AVL 树的简洁 C++ 实现"></a>AVL 树的简洁 C++ 实现</h3><p>以下是一个包含插入操作的简单 AVL 树实现代码。插入操作后会进行平衡调整。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">height</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取节点高度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node ? node-&gt;height : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getBalance</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node ? <span class="built_in">getHeight</span>(node-&gt;left) - <span class="built_in">getHeight</span>(node-&gt;right) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右旋</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">rightRotate</span><span class="params">(TreeNode* y)</span> </span>&#123;</span><br><span class="line">        TreeNode* x = y-&gt;left;</span><br><span class="line">        TreeNode* T2 = x-&gt;right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旋转</span></span><br><span class="line">        x-&gt;right = y;</span><br><span class="line">        y-&gt;left = T2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新高度</span></span><br><span class="line">        y-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(y-&gt;left), <span class="built_in">getHeight</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        x-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(x-&gt;left), <span class="built_in">getHeight</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左旋</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">leftRotate</span><span class="params">(TreeNode* x)</span> </span>&#123;</span><br><span class="line">        TreeNode* y = x-&gt;right;</span><br><span class="line">        TreeNode* T2 = y-&gt;left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旋转</span></span><br><span class="line">        y-&gt;left = x;</span><br><span class="line">        x-&gt;right = T2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新高度</span></span><br><span class="line">        x-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(x-&gt;left), <span class="built_in">getHeight</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        y-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(y-&gt;left), <span class="built_in">getHeight</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点并保持平衡</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode* node, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入到左子树或右子树</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; node-&gt;val) node-&gt;left = <span class="built_in">insert</span>(node-&gt;left, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node-&gt;val) node-&gt;right = <span class="built_in">insert</span>(node-&gt;right, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> node; <span class="comment">// 不允许插入重复值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前节点高度</span></span><br><span class="line">        node-&gt;height = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">getHeight</span>(node-&gt;left), <span class="built_in">getHeight</span>(node-&gt;right));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查平衡因子并旋转</span></span><br><span class="line">        <span class="type">int</span> balance = <span class="built_in">getBalance</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左左情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; val &lt; node-&gt;left-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右右情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; val &gt; node-&gt;right-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; val &gt; node-&gt;left-&gt;val) &#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">leftRotate</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右左情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; val &lt; node-&gt;right-&gt;val) &#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">rightRotate</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历输出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">            cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AVLTree avl;</span><br><span class="line">    TreeNode* root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    root = avl.<span class="built_in">insert</span>(root, <span class="number">10</span>);</span><br><span class="line">    root = avl.<span class="built_in">insert</span>(root, <span class="number">20</span>);</span><br><span class="line">    root = avl.<span class="built_in">insert</span>(root, <span class="number">30</span>);</span><br><span class="line">    root = avl.<span class="built_in">insert</span>(root, <span class="number">40</span>);</span><br><span class="line">    root = avl.<span class="built_in">insert</span>(root, <span class="number">50</span>);</span><br><span class="line">    root = avl.<span class="built_in">insert</span>(root, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出中序遍历</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Inorder traversal of AVL tree: &quot;</span>;</span><br><span class="line">    avl.<span class="built_in">inorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释</p><ol><li><strong>getHeight 和 getBalance</strong>：用于计算节点的高度和平衡因子。</li><li><strong>右旋和左旋操作</strong>：用于在失衡时恢复平衡。</li><li><strong>insert 操作</strong>：按二叉搜索树的规则插入新节点，并在每次插入后检查平衡性并进行必要的旋转操作。</li><li><strong>inorder 遍历</strong>：用于输出 AVL 树中节点的值，验证树结构的正确性。</li></ol><h2 id="哈夫曼-Huffman-树和哈夫曼编码"><a href="#哈夫曼-Huffman-树和哈夫曼编码" class="headerlink" title="哈夫曼(Huffman)树和哈夫曼编码"></a>哈夫曼(Huffman)树和哈夫曼编码</h2><p><strong>哈夫曼树</strong>（Huffman Tree）和<strong>哈夫曼编码</strong>（Huffman Coding）是数据压缩领域的重要概念。它们通过使用变长编码表对频率较高的数据分配较短的编码，从而有效地减少数据的存储空间。</p><h3 id="哈夫曼树的概念"><a href="#哈夫曼树的概念" class="headerlink" title="哈夫曼树的概念"></a>哈夫曼树的概念</h3><ul><li><strong>哈夫曼树</strong>是一种带权路径长度最短的二叉树，用于实现最优前缀编码。通常用于无损数据压缩。</li><li>在哈夫曼树中，频率较高的字符会被分配较短的编码，而频率较低的字符会被分配较长的编码，从而使整体编码长度最小化。</li></ul><h3 id="哈夫曼编码的概念"><a href="#哈夫曼编码的概念" class="headerlink" title="哈夫曼编码的概念"></a>哈夫曼编码的概念</h3><ul><li><strong>哈夫曼编码</strong>是一种基于哈夫曼树的前缀编码。每个字符用一串二进制数字表示，且不同字符的编码无公共前缀（前缀编码），避免了编码歧义。</li><li>在构建哈夫曼树后，从根到每个叶节点的路径形成该节点的编码，左子树为 <code>0</code>，右子树为 <code>1</code>。</li></ul><h3 id="哈夫曼树的性质"><a href="#哈夫曼树的性质" class="headerlink" title="哈夫曼树的性质"></a>哈夫曼树的性质</h3><ol><li><strong>最优编码</strong>：哈夫曼编码是无损压缩的最优编码方式之一，可有效减少存储空间。</li><li><strong>前缀编码</strong>：无公共前缀，避免编码歧义。</li><li><strong>构造复杂度</strong>：哈夫曼树构建过程的时间复杂度为 (O(n \log n))，其中 (n) 是字符的种类数。</li></ol><p><strong>无公共前缀</strong>的意思是，在一个编码系统中，任何一个字符的编码都不是另一个字符编码的开头部分（前缀）。在这种情况下，解码时不会有歧义，因为每个编码是唯一且独立的。</p><p>在哈夫曼编码中，这种“无公共前缀”性质被称为<strong>前缀码</strong>（Prefix Code）。具体来说：</p><ul><li>例如，如果字符 A 的编码是 <code>0</code>，字符 B 的编码是 <code>10</code>，字符 C 的编码是 <code>110</code>，字符 D 的编码是 <code>111</code>，那么这些编码没有公共前缀，因为：<ul><li><code>0</code> 不会是其他编码（<code>10</code>, <code>110</code>, <code>111</code>）的前缀。</li><li><code>10</code> 也不会是 <code>110</code> 或 <code>111</code> 的前缀。</li></ul></li></ul><p>这样可以确保<strong>唯一解码</strong>，即每当我们解码时，遇到编码 <code>0</code> 时立即知道是 A，遇到 <code>10</code> 时就是 B，以此类推。</p><h3 id="哈夫曼树和哈夫曼编码的C-实现"><a href="#哈夫曼树和哈夫曼编码的C-实现" class="headerlink" title="哈夫曼树和哈夫曼编码的C++实现"></a>哈夫曼树和哈夫曼编码的C++实现</h3><p>以下是一个简洁的C++实现，使用最小堆来构建哈夫曼树，并生成哈夫曼编码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义哈夫曼树的节点结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> ch;              <span class="comment">// 字符</span></span><br><span class="line">    <span class="type">int</span> freq;             <span class="comment">// 字符频率</span></span><br><span class="line">    HuffmanNode* left;    <span class="comment">// 左子节点</span></span><br><span class="line">    HuffmanNode* right;   <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">HuffmanNode</span>(<span class="type">char</span> c, <span class="type">int</span> f) : <span class="built_in">ch</span>(c), <span class="built_in">freq</span>(f), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数，用于优先队列（最小堆）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(HuffmanNode* a, HuffmanNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;freq &gt; b-&gt;freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成哈夫曼编码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateCodes</span><span class="params">(HuffmanNode* root, string code, unordered_map&lt;<span class="type">char</span>, string&gt;&amp; huffmanCode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到达叶节点，保存字符及其对应编码</span></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        huffmanCode[root-&gt;ch] = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">generateCodes</span>(root-&gt;left, code + <span class="string">&quot;0&quot;</span>, huffmanCode);</span><br><span class="line">    <span class="built_in">generateCodes</span>(root-&gt;right, code + <span class="string">&quot;1&quot;</span>, huffmanCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放哈夫曼树内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeTree</span><span class="params">(HuffmanNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">freeTree</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">freeTree</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建哈夫曼树并生成编码</span></span><br><span class="line"><span class="function">unordered_map&lt;<span class="type">char</span>, string&gt; <span class="title">buildHuffmanTree</span><span class="params">(<span class="type">const</span> unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; freq)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用最小堆来构建哈夫曼树</span></span><br><span class="line">    priority_queue&lt;HuffmanNode*, vector&lt;HuffmanNode*&gt;, Compare&gt; minHeap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化每个字符的节点并加入优先队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : freq) &#123;</span><br><span class="line">        minHeap.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">HuffmanNode</span>(pair.first, pair.second));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并节点，构建哈夫曼树</span></span><br><span class="line">    <span class="keyword">while</span> (minHeap.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        HuffmanNode* left = minHeap.<span class="built_in">top</span>(); minHeap.<span class="built_in">pop</span>();</span><br><span class="line">        HuffmanNode* right = minHeap.<span class="built_in">top</span>(); minHeap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建新的内部节点，频率为左右子节点频率之和</span></span><br><span class="line">        HuffmanNode* sum = <span class="keyword">new</span> <span class="built_in">HuffmanNode</span>(<span class="string">&#x27;\0&#x27;</span>, left-&gt;freq + right-&gt;freq);</span><br><span class="line">        sum-&gt;left = left;</span><br><span class="line">        sum-&gt;right = right;</span><br><span class="line">        minHeap.<span class="built_in">push</span>(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成哈夫曼编码</span></span><br><span class="line">    HuffmanNode* root = minHeap.<span class="built_in">top</span>();</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, string&gt; huffmanCode;</span><br><span class="line">    <span class="built_in">generateCodes</span>(root, <span class="string">&quot;&quot;</span>, huffmanCode);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">freeTree</span>(root);  <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">return</span> huffmanCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义字符频率</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; freq = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&#x27;b&#x27;</span>, <span class="number">9</span>&#125;, &#123;<span class="string">&#x27;c&#x27;</span>, <span class="number">12</span>&#125;, &#123;<span class="string">&#x27;d&#x27;</span>, <span class="number">13</span>&#125;, &#123;<span class="string">&#x27;e&#x27;</span>, <span class="number">16</span>&#125;, &#123;<span class="string">&#x27;f&#x27;</span>, <span class="number">45</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建哈夫曼树并生成编码</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, string&gt; huffmanCode = <span class="built_in">buildHuffmanTree</span>(freq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出编码</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Huffman Codes:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : huffmanCode) &#123;</span><br><span class="line">        cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><strong>HuffmanNode</strong>：定义哈夫曼树的节点结构体，包含字符、频率及左右子节点。</li><li><strong>Compare 函数对象</strong>：用于最小堆比较，以频率为基础构建最小堆。</li><li><strong>buildHuffmanTree</strong>：构建哈夫曼树，通过合并最小频率的节点，最终形成一棵树。</li><li><strong>generateCodes</strong>：递归生成编码，通过树的路径生成每个字符的二进制编码。</li><li><strong>main 函数</strong>：定义字符频率，调用 <code>buildHuffmanTree</code> 构建哈夫曼树并生成编码，最后输出编码结果。</li></ol><h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h3><p>假设频率表为 <code>&#123;&#39;a&#39;: 5, &#39;b&#39;: 9, &#39;c&#39;: 12, &#39;d&#39;: 13, &#39;e&#39;: 16, &#39;f&#39;: 45&#125;</code>，输出结果可能如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Huffman Codes:</span><br><span class="line">a : 1100</span><br><span class="line">b : 1101</span><br><span class="line">c : 100</span><br><span class="line">d : 101</span><br><span class="line">e : 111</span><br><span class="line">f : 0</span><br></pre></td></tr></table></figure></p><p>代码说明</p><p>通过哈夫曼编码，字符 ‘f’ 频率最高，编码最短，而频率较低的字符 ‘a’ 和 ‘b’ 编码更长，从而达到压缩效果。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="数据结构" scheme="https://blog.whff521.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="树" scheme="https://blog.whff521.xyz/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="https://blog.whff521.xyz/2024/10/30/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://blog.whff521.xyz/2024/10/30/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2024-10-30T07:46:43.000Z</published>
    <updated>2024-10-30T07:53:16.055Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表（Hash Table）是一种用于存储键值对的数据结构，可以通过哈希函数快速地根据键找到对应的值。哈希表的查找、插入和删除操作在平均情况下具有 <code>O(1)</code> 的时间复杂度，非常高效。</p><h2 id="1-哈希表的基本概念"><a href="#1-哈希表的基本概念" class="headerlink" title="1. 哈希表的基本概念"></a>1. 哈希表的基本概念</h2><p>哈希表的核心思想是将键通过一个<strong>哈希函数</strong>（Hash Function）映射到一个哈希表的索引位置上。若两个键映射到同一位置（即出现<strong>哈希冲突</strong>），则需要解决冲突以保证数据存储的正确性。</p><h3 id="哈希表的术语"><a href="#哈希表的术语" class="headerlink" title="哈希表的术语"></a>哈希表的术语</h3><ul><li><strong>哈希函数</strong>：将键映射到表中某个位置的函数。</li><li><strong>哈希冲突</strong>：两个不同的键被映射到同一个位置。</li><li><strong>装载因子</strong>：表中已填充元素的数量与哈希表大小的比值。较高的装载因子会增加冲突发生的可能性。</li></ul><h2 id="2-哈希表的实现方式"><a href="#2-哈希表的实现方式" class="headerlink" title="2. 哈希表的实现方式"></a>2. 哈希表的实现方式</h2><p>哈希表的常用实现方式主要有两种：</p><ol><li><strong>开放寻址法</strong>：在发生冲突时，通过寻找其他空闲位置来存储元素。常见的开放寻址方法包括线性探测、二次探测和双重哈希。</li><li><strong>链地址法（拉链法）</strong>：在每个哈希表位置存储一个链表，在发生冲突时将新元素插入到链表中。</li></ol><h2 id="3-哈希表的-C-实现"><a href="#3-哈希表的-C-实现" class="headerlink" title="3. 哈希表的 C++ 实现"></a>3. 哈希表的 C++ 实现</h2><h3 id="使用链地址法（拉链法）的-C-实现"><a href="#使用链地址法（拉链法）的-C-实现" class="headerlink" title="使用链地址法（拉链法）的 C++ 实现"></a>使用链地址法（拉链法）的 C++ 实现</h3><p>我们可以使用一个数组加链表的结构来实现哈希表。每个数组元素是一个链表，用于解决哈希冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; table;  <span class="comment">// 哈希表的数组，每个位置是一个链表</span></span><br><span class="line">    <span class="type">int</span> size;                 <span class="comment">// 哈希表的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数：简单取模法</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunction</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HashTable</span>(<span class="type">int</span> s) : <span class="built_in">size</span>(s) &#123;</span><br><span class="line">        table.<span class="built_in">resize</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line">        table[index].<span class="built_in">push_back</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line">        table[index].<span class="built_in">remove</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : table[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element == key) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示哈希表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : table[i]) &#123;</span><br><span class="line">                cout &lt;&lt; element &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">HashTable <span class="title">hashTable</span><span class="params">(<span class="number">7</span>)</span></span>; <span class="comment">// 创建大小为 7 的哈希表</span></span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hash Table:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Searching for 15: &quot;</span> &lt;&lt; (hashTable.<span class="built_in">search</span>(<span class="number">15</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">remove</span>(<span class="number">15</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After removing 15:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul><li><strong>哈希函数</strong>：这里我们用简单的取模方法，将键值对映射到表中的某个位置。<code>hashFunction(int key)</code> 通过 <code>key % size</code> 计算索引。</li><li><strong>插入操作</strong>：将元素插入到哈希表中指定索引的链表中。</li><li><strong>删除操作</strong>：从哈希表中指定索引的链表中删除目标元素。</li><li><strong>查找操作</strong>：检查目标元素是否在哈希表的某个位置的链表中。</li></ul><h3 id="开放寻址法的几种探测方法"><a href="#开放寻址法的几种探测方法" class="headerlink" title="开放寻址法的几种探测方法"></a>开放寻址法的几种探测方法</h3><ol><li><strong>线性探测</strong>（Linear Probing）：冲突时按固定步长（通常为 1）查找下一个空位。</li><li><strong>二次探测</strong>（Quadratic Probing）：冲突时按二次方步长查找下一个空位，步长逐渐增加以避免簇现象。</li><li><strong>双重哈希</strong>（Double Hashing）：使用两个哈希函数，当冲突发生时，通过第二个哈希函数计算步长。</li></ol><p>下面我们以<strong>线性探测法</strong>为例，展示开放寻址法的实现。</p><h3 id="使用开放寻址法的哈希表-C-实现"><a href="#使用开放寻址法的哈希表-C-实现" class="headerlink" title="使用开放寻址法的哈希表 C++ 实现"></a>使用开放寻址法的哈希表 C++ 实现</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul><li>使用一个数组保存元素，初始值为 -1 或 <code>nullptr</code> 表示该位置空闲。</li><li>插入元素时，如果计算出的索引位置被占用，则按探测策略查找下一个位置。</li><li>删除元素时，采用标记（例如 <code>-2</code>）表示“删除状态”，这样在查找时不会打断探测链。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenAddressHashTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; table; <span class="comment">// 哈希表数组</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数：简单取模</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunction</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OpenAddressHashTable</span>(<span class="type">int</span> s) : <span class="built_in">size</span>(s) &#123;</span><br><span class="line">        table.<span class="built_in">resize</span>(size, <span class="number">-1</span>); <span class="comment">// -1 表示空闲位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线性探测</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> probeIndex = (index + i) % size;  <span class="comment">// 线性探测</span></span><br><span class="line">            <span class="keyword">if</span> (table[probeIndex] == <span class="number">-1</span> || table[probeIndex] == <span class="number">-2</span>) &#123; <span class="comment">// 找到空闲或已删除位置</span></span><br><span class="line">                table[probeIndex] = key;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 哈希表已满</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线性探测</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> probeIndex = (index + i) % size;</span><br><span class="line">            <span class="keyword">if</span> (table[probeIndex] == key) &#123;  <span class="comment">// 找到目标元素</span></span><br><span class="line">                table[probeIndex] = <span class="number">-2</span>; <span class="comment">// -2 标记删除状态</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (table[probeIndex] == <span class="number">-1</span>) &#123;  <span class="comment">// 没找到且遇到空闲位置，停止查找</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线性探测</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> probeIndex = (index + i) % size;</span><br><span class="line">            <span class="keyword">if</span> (table[probeIndex] == key) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">// 找到目标元素</span></span><br><span class="line">            <span class="keyword">if</span> (table[probeIndex] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 找到空闲位置，停止查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示哈希表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; table[i] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (table[i] == <span class="number">-2</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: [Deleted]&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: [Empty]&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">OpenAddressHashTable <span class="title">hashTable</span><span class="params">(<span class="number">7</span>)</span></span>; <span class="comment">// 创建大小为 7 的哈希表</span></span><br><span class="line"></span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hash Table:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Searching for 15: &quot;</span> &lt;&lt; (hashTable.<span class="built_in">search</span>(<span class="number">15</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">remove</span>(<span class="number">15</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After removing 15:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><ul><li><strong>哈希函数</strong>：使用 <code>key % size</code> 计算元素的初始索引位置。</li><li><strong>线性探测</strong>：在发生冲突时，通过逐次递增索引来查找下一个空闲位置，直到找到空位或返回失败。</li><li><strong>删除标记</strong>：删除元素时，将该位置标记为 <code>-2</code>（表示已删除），防止探测链的中断。<code>-1</code> 表示空闲位置。</li><li><strong>查找与删除</strong>：查找元素时遇到 <code>-1</code> 即可停止查找，遇到 <code>-2</code> 则继续探测链。</li></ul><h3 id="其他探测方法简述"><a href="#其他探测方法简述" class="headerlink" title="其他探测方法简述"></a>其他探测方法简述</h3><ol><li><strong>二次探测</strong>：冲突时探测间隔为 $( i^2 )$ （如 <code>index + i^2</code>）。这样可以避免线性探测中的“主簇”问题，但可能引入新的探测区域。</li><li><strong>双重哈希</strong>：冲突时通过第二个哈希函数计算步长，跳跃性地寻找位置，减少了探测链的聚集现象。</li></ol><p>开放寻址法通常比链地址法更节省空间，但当装载因子过高时，开放寻址法的性能下降更明显。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;哈希表（Hash Table）是一种用于存储键值对的数据结构，可以通过哈希函数快速地根据键找到对应的值。哈希表的查找、插入和删除操作在平均情况下具有 &lt;code&gt;O(1)&lt;/code&gt; 的时间复杂度，非常高效。&lt;/p&gt;
&lt;h2 id=&quot;1-哈希表的基本概念&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="数据结构" scheme="https://blog.whff521.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="哈希表" scheme="https://blog.whff521.xyz/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
</feed>
