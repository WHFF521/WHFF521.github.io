<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>yolov5_obb的兼容性改进</title>
      <link href="/2025/08/04/yolov5-obb%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E6%94%B9%E8%BF%9B/"/>
      <url>/2025/08/04/yolov5-obb%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E6%94%B9%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="yolov5-obb的兼容性改进"><a href="#yolov5-obb的兼容性改进" class="headerlink" title="yolov5_obb的兼容性改进"></a>yolov5_obb的兼容性改进</h1><p>最近在学习yolo的旋转框检测，选用了yolov5_obb进行测试，结果代码由于各种问题跑不起来。我将里面用到的废弃函数进行了更改，以便能用用新环境进行运行。</p><p>我将修改完的代码上传到了我的<a href="https://github.com/WHFF521/yolov5_obb_compatible">Github</a>仓库里。</p><h2 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h2><h3 id="utils-nms-rotated-nms-rotated-wrapper-py"><a href="#utils-nms-rotated-nms-rotated-wrapper-py" class="headerlink" title="utils/nms_rotated/nms_rotated_wrapper.py"></a>utils/nms_rotated/nms_rotated_wrapper.py</h3><p>运行的时候会显示<code>too_small</code>和<code>inds</code>这两个变量和<code>ori_inds</code>不在同一个设备上，需要添加代码将两个变量移动到<code>ori_inds</code>所在的设备上。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ori_inds = torch.arange(dets_th.size(<span class="number">0</span>)) <span class="comment"># 0 ~ n-1</span></span><br><span class="line"><span class="comment"># add this</span></span><br><span class="line">too_small = too_small.to(ori_inds.device)</span><br><span class="line"><span class="comment"># add end</span></span><br><span class="line">ori_inds = ori_inds[~too_small]</span><br><span class="line">dets_th = dets_th[~too_small] <span class="comment"># (n_filter, 5)</span></span><br><span class="line">scores = scores[~too_small]</span><br><span class="line"></span><br><span class="line">inds = nms_rotated_ext.nms_rotated(dets_th, scores, iou_thr)</span><br><span class="line"><span class="comment"># add this</span></span><br><span class="line">inds = inds.to(ori_inds.device)</span><br><span class="line"><span class="comment"># add end</span></span><br><span class="line">inds = ori_inds[inds]</span><br></pre></td></tr></table></figure><h3 id="utils-nms-rotated-src-poly-nms-cuda-cu"><a href="#utils-nms-rotated-src-poly-nms-cuda-cu" class="headerlink" title="utils/nms_rotated/src/poly_nms_cuda.cu"></a>utils/nms_rotated/src/poly_nms_cuda.cu</h3><p>THC库已经被弃用，我们需要用ATen库进行更换</p><p>这里我是根据<a href="https://blog.51cto.com/u_16213569/11875401">这个博客</a>进行更改的</p><p>删除<code>#include &lt;THC/THC.h&gt;</code>头文件，把所有的<code>THCudaCheck(cudaGetLastError());</code>替换成 <code>AT_CUDA_CHECK(cudaGetLastError());</code></p><p>对每个.cu文件中调用<code>THCCeilDiv(x,y)</code>的地方，都把这个函数换成 <code>(x+y-1)/y</code>的形式，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const int col_blocks = THCCeilDiv(n_polys, threadsPerBlock);</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> col_blocks = (n_polys+threadsPerBlock<span class="number">-1</span>) / threadsPerBlock;</span><br></pre></td></tr></table></figure><p>添加头文件<code>#include &lt;ATen/cuda/ThrustAllocator.h&gt;</code></p><p>注释掉<code>THCState *state = at::globalContext().lazyInitCUDA();</code></p><p>修改<code>THCudaMalloc</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mask_dev = (unsigned long long*) THCudaMalloc(state, boxes_num * col_blocks * sizeof(unsigned long long));</span></span><br><span class="line">mask_dev = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*) c10::cuda::CUDACachingAllocator::<span class="built_in">raw_alloc</span>(boxes_num * col_blocks * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>));</span><br></pre></td></tr></table></figure><p>替换<code>THCudaFree</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// THCudaFree(state, mask_dev);</span></span><br><span class="line">c10::cuda::CUDACachingAllocator::<span class="built_in">raw_delete</span>(mask_dev);</span><br></pre></td></tr></table></figure><p>将<code>THCudaCheck</code>替换成<code>C10_CUDA_CHECK</code></p><p>将<code>AT_CHECK</code>替换为<code>TORCH_CHECK</code></p><h3 id="utils-datasets-py"><a href="#utils-datasets-py" class="headerlink" title="utils/datasets.py"></a>utils/datasets.py</h3><p>将所有的<code>np.int</code>改写为<code>int</code></p><h3 id="utils-general-py"><a href="#utils-general-py" class="headerlink" title="utils/general.py"></a>utils/general.py</h3><p><code>torch.load</code>函数添加<code>weights_only=False</code>参数</p><h3 id="utils-loss-py"><a href="#utils-loss-py" class="headerlink" title="utils/loss.py"></a>utils/loss.py</h3><p>这个文件会报错说数据类型转换错误。需要先将变量转换为long，注意这里不是原地转换，需要用赋值的形式进行转换。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># indices.append((b, a, gj.clamp_(0, feature_wh[1] - 1), gi.clamp_(0, feature_wh[0] - 1)))  # image, anchor, grid indices</span></span><br><span class="line">gi = gi.clamp(<span class="number">0</span>, feature_wh[<span class="number">0</span>] - <span class="number">1</span>).long()</span><br><span class="line">gj = gj.clamp(<span class="number">0</span>, feature_wh[<span class="number">1</span>] - <span class="number">1</span>).long()</span><br><span class="line">indices.append((b, a, gj, gi))  <span class="comment"># image, anchor, grid indices</span></span><br></pre></td></tr></table></figure><h3 id="utils-plots-py"><a href="#utils-plots-py" class="headerlink" title="utils/plots.py"></a>utils/plots.py</h3><p><code>self.font.getsize</code>函数已经被废弃。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># w, h = self.font.getsize(label)  # text width, height</span></span><br><span class="line">bbox = self.font.getbbox(label)</span><br><span class="line">w, h = bbox[<span class="number">2</span>] - bbox[<span class="number">0</span>], bbox[<span class="number">3</span>] - bbox[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="models-experimental-py"><a href="#models-experimental-py" class="headerlink" title="models/experimental.py"></a>models/experimental.py</h3><p><code>torch.load</code>函数添加<code>weights_only=False</code>参数</p><h3 id="train-py"><a href="#train-py" class="headerlink" title="train.py"></a>train.py</h3><p><code>torch.load</code>函数添加<code>weights_only=False</code>参数, 注释掉下面两行防止更新numpy。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># check_git_status()</span></span><br><span class="line"><span class="comment"># check_requirements(exclude=[&#x27;thop&#x27;])</span></span><br></pre></td></tr></table></figure><h3 id="编译C-代码"><a href="#编译C-代码" class="headerlink" title="编译C++代码"></a>编译C++代码</h3><p>原作者用C++写了一些函数，需要编译后才能使用。但是我按照他写的命令缺一直报错说<code>ModuleNotFoundError: No module named &#39;torch&#39;</code>，显然我的环境里是有torch的，但是编译的时候报错说没有。</p><p>非常玄学的是，我确实有一个环境能够通过<code>python setup.py develop</code>命令来进行编译的，我记得当时我安装了一个pycocotools库之后就可以了。但是过了一天，我想从头到尾再创建一个新的虚拟环境过一遍的时候发现又不能编译了，我查了一下pycocotools仅仅是python对coco数据集做的小工具，应该不是我编译成功的关键要素。我也尝试过<code>sudo apt install python-dev</code>安装编译工具，但是没有用。我导出pip requirement和conda list并且仔细对比了一下发现里面的东西都是一样的。我寻找了很多网页都没有发现是怎么回事，有一些人和我一样遇到了一样的问题，但是都没有解决方案。</p><p>我觉得可能是代码与新环境不匹配的问题。我在和chatgpt讨论如何更改代码的时候，他提到了一个新的执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py build_ext --inplace</span><br></pre></td></tr></table></figure><p>我发现这个命令能够成功编译，而且运行训练任务测试能够完美运行。我不知道这算不算解决了问题，我不知道解决问题的原因和答案，换了一个命令就成功了。</p><p>PS：封面图来源：<a href="https://x.com/amanekanatach/status/1950904282275791316?s=46">天音かなた💫ホロライブ</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yolo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kaggle 离线使用YOLOv5——Global Wheat Detection</title>
      <link href="/2025/07/22/Kaggle-%E7%A6%BB%E7%BA%BF%E4%BD%BF%E7%94%A8YOLOv5%E2%80%94%E2%80%94Global-Wheat-Detection/"/>
      <url>/2025/07/22/Kaggle-%E7%A6%BB%E7%BA%BF%E4%BD%BF%E7%94%A8YOLOv5%E2%80%94%E2%80%94Global-Wheat-Detection/</url>
      
        <content type="html"><![CDATA[<h1 id="Kaggle-离线使用YOLOv5——Global-Wheat-Detection"><a href="#Kaggle-离线使用YOLOv5——Global-Wheat-Detection" class="headerlink" title="Kaggle 离线使用YOLOv5——Global Wheat Detection"></a>Kaggle 离线使用YOLOv5——Global Wheat Detection</h1><p>Kaggle上很多比赛都要求代码在离线（offline）状态下运行的，虽然notebook的运行环境已经自带了很多深度学习和神经网络的包，但是要运行GitHub上下载的YOLOv5模型还差一些包和环境需求导致不能直接运行。而且离线状态下也不允许使用<code>git</code>命令克隆仓库。</p><p>那我直接上传最终<code>submission.csv</code>不就行了？很遗憾不行的。因为最终分数会扩大测试数据重新测试你代码运行的结果，这其实也是为什么要offline的原因，防止有人利用网络将扩大的数据集传出来以致于不公平。</p><p>我本来是想用<a href="https://www.kaggle.com/competitions/global-wheat-detection">Global Wheat Detection</a>练习一下YOLOv5的使用，但是因为离线环境确实困扰了我几天的时间。我对Kaggle的notebook到底是怎么运作的并不清楚，而且网上鲜有这样的教程。网络上搜不到答案只有两种情况：一是这真的很难，没有人能做出来（我的问题当然不是这种情况）；<strong>二是答案很简单，不值得出教程（事实确实是这样）</strong>。不过还是在此记录一下我是怎么实现的吧</p><h2 id="Notebook环境说明"><a href="#Notebook环境说明" class="headerlink" title="Notebook环境说明"></a>Notebook环境说明</h2><p>Kaggle的Notebook实际上是一个<code>.ipynb</code>编辑器，支持code和markdown两种语言进行编写，我们可以分段编写和运行代码。因为notebook能持续保持运行状态，可以一块一块地执行代码，且前面的执行结果和变量依然有效。</p><p>设置可以更改运行是否使用GPU，这里需要注意，要在代码运行之前就进行选择，因为更换GPU不是热加载，而是直接更换一个新的运行环境，之前运行的环境会丢失。</p><p>右边<code>sidebar</code>（如果没有在<code>view</code>里点击<code>show sidebar</code>）可以加载数据集。如果你是在比赛的<code>code</code>页面点击的<code>new notebook</code>，那么可以看到<code>input</code>自动加载了这场比赛的数据集。</p><p>可以自行添加数据到<code>input</code>里面，有两种方式：一是从网站已有的数据进行添加，比如其他比赛的数据集，或者是你自己其他notebook上的产出文件（Output）；二是从自己电脑上传压缩包文件，上传的时候会询问是model还是dataset，其实还是第一种方式加载数据，你上传的文件会先保存到网站上，然后再加载。你上传的压缩文件会自动解压到当前环境的<code>input</code>目录下。</p><p>注意，所有notebook都有两个路径可以使用，一是<code>/kaggle/input/</code>,这个是存放所有准备使用的文件的，这个文件夹只读，不能更改；二是<code>/kaggle/working/</code>，这个文件夹是你代码所有产出保存文件的地址，这个文件夹没有只读的限制，可以随意更改，但是有上限20GB的要求。在运行<code>Save&amp;Run All(Commit)</code>保存这个版本的Version的时候，Kaggle会自动从头到尾运行代码，而且保存这个notebook的<code>/kaggle/working/</code>下的所有文件。当你在新notebook里面，可以添加这个notebook的output，会保存在新notebook的<code>/kaggle/input/</code>的文件夹下。</p><p>建议先将所有文件复制到<code>working</code>文件夹下在进行其他操作，处理数据会比较方便。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>因为是边试错边完成的，所以步骤有些冗余。</p><p>我一共创建了三个notebook和一个dataset。notebook分别是<code>YOLOv5&amp;Dependences</code>,<code>WheatDetectOffineTrain</code>和<code>WheatDetectOfflineDetect</code>。一个数据集是<code>ArialTTF</code>,其实就是Arial字体文件。</p><p>这里强调一下，模型的训练和检测建议分成两个notebook来写，因为提交之后会运行你的代码，如果重新训练的话会花费大量的时间才能得到分数。</p><h3 id="ArialTTF"><a href="#ArialTTF" class="headerlink" title="ArialTTF"></a>ArialTTF</h3><p>先说一下这个数据集吧，这是在用YOLOv5训练的时候报错发现的，它说没有Arial字体文件。因为YOLOv5训练结束后会展示一些图片，上面会画框和标注标签，需要字体文件。Arial应该是最基本的英文字体文件了，然而Kaggle环境里并没有，所以需要在input加上这个字体文件，下面会提到怎么处理这个字体文件。</p><p>创建方法很简单，在notebook编辑页面点击上传input，选择dataset，上传在网上下载好的字体文件即可。</p><h3 id="YOLOv5-amp-Dependences"><a href="#YOLOv5-amp-Dependences" class="headerlink" title="YOLOv5&amp;Dependences"></a>YOLOv5&amp;Dependences</h3><p>这个notebook可以连接网络。其实只有最后提交的notebook offline就行。。。。。。。。。。。。。。。。。</p><p>WTF，WTF，WTF。。。。。。</p><p>所以我为什么要写三个notebook，我为什么要在train的时候也离线了。。。</p><p>我真的是写到这里的时候才意识到这个问题。</p><p>因为当前这个<code>YOLOv5&amp;Dependences</code> notebook主要解决的是离线notebook不能使用git,pip命令进行在线操作的问题。我想的是在这里下载好YOLOv5和依赖包之后，在<code>WheatDetectOffineTrain</code>里面作为input进行加载就可以离线使用YOLOv5了。</p><p>实际上<code>WheatDetectOffineTrain</code>完全可以联网下载和安装依赖，所以这个notebook完全没有存在的必要。</p><p>我终于明白discussion里面有人说的你需要创建两个notebook，一个用来训练，一个用来检测是什么意思了。并不是需要，而是“只”需要两个。</p><p>不过还是记录一下这个notebook的代码吧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!git clone https://github.com/ultralytics/yolov5</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash"><span class="built_in">cd</span> yolov5</span></span><br><span class="line">!pip download -r requirements.txt -d dependences</span><br><span class="line">!mkdir -p weights</span><br><span class="line">!wget -P weights https://github.com/ultralytics/yolov5/releases/download/v7.0/yolov5s.pt</span><br></pre></td></tr></table></figure><p>因为预训练文件是在线加载的，所以也得提前下载。。。</p><h3 id="WheatDetectOffineTrain"><a href="#WheatDetectOffineTrain" class="headerlink" title="WheatDetectOffineTrain"></a>WheatDetectOffineTrain</h3><p>好，接下来记录一下这个“离线”训练的notebook。</p><p>首先要先添加input，将上面两个加载进来。</p><p>然后安装依赖：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install --no-index --find-links=/kaggle/input/yolov5-dependences/yolov5/dependences -r /kaggle/input/yolov5-dependences/yolov5/requirements.txt</span><br></pre></td></tr></table></figure></p><p>这里运行完后会看见报错：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR: pip&#x27;s dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.</span><br><span class="line">torchaudio 2.6.0+cu124 requires torch==2.6.0, but you have torch 2.7.1 which is incompatible.</span><br><span class="line">fastai 2.7.19 requires torch&lt;2.7,&gt;=1.10, but you have torch 2.7.1 which is incompatible.</span><br></pre></td></tr></table></figure><br>好像是因为本地torch版本太高了，不过不用理会，代码能正常运行。</p><p>创建数据集文件夹<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.makedirs(<span class="string">&#x27;/kaggle/working/wheat&#x27;</span>, exist_ok=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><p>将标签转换成YOLO格式：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># set path</span></span><br><span class="line">csv_path = <span class="string">r&#x27;/kaggle/input/global-wheat-detection/train.csv&#x27;</span></span><br><span class="line">image_dir = <span class="string">r&#x27;/kaggle/input/global-wheat-detection/train&#x27;</span></span><br><span class="line">label_output_dir = <span class="string">r&#x27;/kaggle/working/wheat/labels&#x27;</span></span><br><span class="line"></span><br><span class="line">os.makedirs(label_output_dir,exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(csv_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析 bbox 字符串为 float 类型的 [x, y, w, h]</span></span><br><span class="line">df[[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;h&#x27;</span>]] = df[<span class="string">&#x27;bbox&#x27;</span>].apply(<span class="keyword">lambda</span> x: <span class="built_in">eval</span>(x)).apply(pd.Series)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_bbox_to_yolo</span>(<span class="params">size,box</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    size: (width,height)</span></span><br><span class="line"><span class="string">    box: (x_min, y_min, width, height)</span></span><br><span class="line"><span class="string">    return: normalized (x_center, y_center, width, height)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dw, dh = <span class="number">1.</span> / size[<span class="number">0</span>], <span class="number">1.</span> / size[<span class="number">1</span>]</span><br><span class="line">    x_center = (box[<span class="number">0</span>] + box[<span class="number">2</span>] / <span class="number">2.0</span>) * dw</span><br><span class="line">    y_center = (box[<span class="number">1</span>] + box[<span class="number">3</span>] / <span class="number">2.0</span>) * dh</span><br><span class="line">    w = box[<span class="number">2</span>] * dw</span><br><span class="line">    h = box[<span class="number">3</span>] * dh</span><br><span class="line">    <span class="keyword">return</span> x_center, y_center, w, h</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> image_id, group <span class="keyword">in</span> tqdm(df.groupby(<span class="string">&#x27;image_id&#x27;</span>), desc=<span class="string">&quot;Generating labels&quot;</span>):</span><br><span class="line">    image_path = os.path.join(image_dir,image_id + <span class="string">&#x27;.jpg&#x27;</span>)</span><br><span class="line">    label_path = os.path.join(label_output_dir, image_id + <span class="string">&#x27;.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(image_path):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">with</span> Image.<span class="built_in">open</span>(image_path) <span class="keyword">as</span> img:</span><br><span class="line">        img_w, img_h = img.size</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(label_path,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> _, row <span class="keyword">in</span> group.iterrows():</span><br><span class="line">            x_center, y_center, w, h = convert_bbox_to_yolo((img_w, img_h), (row[<span class="string">&#x27;x&#x27;</span>], row[<span class="string">&#x27;y&#x27;</span>], row[<span class="string">&#x27;w&#x27;</span>], row[<span class="string">&#x27;h&#x27;</span>]))</span><br><span class="line">            f.write(<span class="string">f&quot;0 <span class="subst">&#123;x_center:<span class="number">.6</span>f&#125;</span> <span class="subst">&#123;y_center:<span class="number">.6</span>f&#125;</span> <span class="subst">&#123;w:<span class="number">.6</span>f&#125;</span> <span class="subst">&#123;h:<span class="number">.6</span>f&#125;</span>\n&quot;</span>)</span><br></pre></td></tr></table></figure></p><p>输出：<code>Generating labels: 100%|██████████| 3373/3373 [00:23&lt;00:00, 144.72it/s]</code></p><p>整理图像文件夹，符合YOLO要求，划分训练集验证集。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line">image_dir = Path(<span class="string">r&#x27;/kaggle/input/global-wheat-detection/train&#x27;</span>)</span><br><span class="line">label_dir = Path(<span class="string">r&#x27;/kaggle/working/wheat/labels&#x27;</span>)</span><br><span class="line">output_base = Path(<span class="string">r&#x27;/kaggle/working/wheat/yolo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">os.makedirs(output_base,exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">train_ratio = <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line">output_images_train = output_base / <span class="string">&#x27;images/train&#x27;</span></span><br><span class="line">output_images_val = output_base / <span class="string">&#x27;images/val&#x27;</span></span><br><span class="line">output_labels_train = output_base / <span class="string">&#x27;labels/train&#x27;</span></span><br><span class="line">output_labels_val = output_base / <span class="string">&#x27;labels/val&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建目标文件夹</span></span><br><span class="line"><span class="keyword">for</span> path <span class="keyword">in</span> [output_images_train, output_images_val, output_labels_train, output_labels_val]:</span><br><span class="line">    os.makedirs(path, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">image_files = <span class="built_in">list</span>(image_dir.glob(<span class="string">&#x27;*.jpg&#x27;</span>))</span><br><span class="line"><span class="comment"># stem is to remove .jpg</span></span><br><span class="line">image_ids = [img.stem <span class="keyword">for</span> img <span class="keyword">in</span> image_files] </span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">42</span>)</span><br><span class="line">random.shuffle(image_ids)</span><br><span class="line"></span><br><span class="line">split_index = <span class="built_in">int</span>(<span class="built_in">len</span>(image_ids) * train_ratio)</span><br><span class="line">train_ids = image_ids[:split_index]</span><br><span class="line">val_ids = image_ids[split_index:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_files</span>(<span class="params">image_ids, image_dst, label_dst</span>):</span><br><span class="line">    <span class="keyword">for</span> image_id <span class="keyword">in</span> image_ids:</span><br><span class="line">        src_img = image_dir / <span class="string">f&quot;<span class="subst">&#123;image_id&#125;</span>.jpg&quot;</span></span><br><span class="line">        dst_img = image_dst / <span class="string">f&quot;<span class="subst">&#123;image_id&#125;</span>.jpg&quot;</span></span><br><span class="line">        shutil.copy2(src_img,dst_img)</span><br><span class="line"></span><br><span class="line">        src_label = label_dir / <span class="string">f&quot;<span class="subst">&#123;image_id&#125;</span>.txt&quot;</span></span><br><span class="line">        dst_label = label_dst / <span class="string">f&quot;<span class="subst">&#123;image_id&#125;</span>.txt&quot;</span></span><br><span class="line">        <span class="keyword">if</span> src_label.exists():</span><br><span class="line">            shutil.copy2(src_label, dst_label)</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            dst_label.write_text(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">copy_files(train_ids, output_images_train,output_labels_train)</span><br><span class="line">copy_files(val_ids, output_images_val,output_labels_val)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;✅ 划分完成：<span class="subst">&#123;<span class="built_in">len</span>(train_ids)&#125;</span> 张用于训练，<span class="subst">&#123;<span class="built_in">len</span>(val_ids)&#125;</span> 张用于验证。&quot;</span>)</span><br></pre></td></tr></table></figure></p><p>输出：<code>✅ 划分完成：2737 张用于训练，685 张用于验证。</code></p><p><strong>注意：没有框的图片也需要一个对应的空txt文件</strong></p><p>编写yaml文件：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yaml_content = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">path: /kaggle/working/wheat/yolo</span></span><br><span class="line"><span class="string">train: images/train</span></span><br><span class="line"><span class="string">val: images/val</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nc: 1</span></span><br><span class="line"><span class="string">names: [&#x27;wheat&#x27;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;wheat.yaml&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(yaml_content)</span><br></pre></td></tr></table></figure></p><p>将YOLOv5拷贝到working文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!cp -r /kaggle/input/yolov5-dependences/yolov5 /kaggle/working/yolov5</span><br></pre></td></tr></table></figure><p>因为YOLOv5在运行的时候wandb会联网进行git检查，然而当前是offline的，会造成无法运行的情况。这里使用了chatgpt教我的“猴子戏法”，将执行检查的函数无效化：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;/kaggle/working/yolov5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> utils.general <span class="keyword">as</span> general</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dummy_check_git_info</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;unknown&#x27;</span></span><br><span class="line"></span><br><span class="line">general.check_git_info = dummy_check_git_info</span><br></pre></td></tr></table></figure><p>安装字体文件,我们只需要将字体文件移动到yolo会寻找字体的地方即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!mkdir -p /root/.config/Ultralytics/</span><br><span class="line">!cp /kaggle/input/arialttf/Arial.ttf /root/.config/Ultralytics/Arial.ttf</span><br></pre></td></tr></table></figure><p>执行训练命令，这里先进入到YOLO文件夹下，简化命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash"><span class="built_in">cd</span> /kaggle/working/yolov5/</span></span><br><span class="line">!python train.py --img 640 --batch 16 --epochs 50 --data /kaggle/working/wheat.yaml --weights weights/yolov5s.pt --name wheat_yolov5</span><br></pre></td></tr></table></figure></p><p>到此就可以了，执行<code>Save &amp; Run All(commit)</code>等待训练完成后就可以进行检测了。我并没有进行图片增强，增加数据集的操作而直接训练的，所以最后检测结果会有一点低。</p><h3 id="WheatDetectOfflineDetect"><a href="#WheatDetectOfflineDetect" class="headerlink" title="WheatDetectOfflineDetect"></a>WheatDetectOfflineDetect</h3><p>提前加载字体文件，<code>YOLOv5&amp;Dependences</code>和<code>WheatDetectOffineTrain</code>的output。</p><p>突然意识到<code>YOLOv5&amp;Dependences</code>也还是有一点存在的必要的，检测文件也需要安装环境，虽然说在训练文件里也可以下载。</p><p>安装依赖：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install --no-index --find-links=/kaggle/input/yolov5-dependences/yolov5/dependences -r /kaggle/input/yolov5-dependences/yolov5/requirements.txt</span><br></pre></td></tr></table></figure></p><p>拷贝训练后的YOLOv5文件夹：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!cp -r /kaggle/input/wheatdetectoffinetrain/yolov5 /kaggle/working/yolov5</span><br></pre></td></tr></table></figure><br>这时yolov5项目文件夹里是有训练后的<code>runs</code>文件夹的。</p><p>安装字体：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!mkdir -p /root/.config/Ultralytics/</span><br><span class="line">!cp /kaggle/input/arialttf/Arial.ttf /root/.config/Ultralytics/Arial.ttf</span><br></pre></td></tr></table></figure></p><p>转换工作目录：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash"><span class="built_in">cd</span> /kaggle/working/yolov5/</span></span><br></pre></td></tr></table></figure></p><p>检测命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!python detect.py --weights runs/train/wheat_yolov5/weights/best.pt --source /kaggle/input/global-wheat-detection/test --img 640 --conf 0.25 --save-txt --save-conf --project runs/predict --name wheat_test</span><br></pre></td></tr></table></figure></p><p>这里说明一下，<code>--conf</code>是保留置信度，<code>--save-txt</code>是保存为txt文件。</p><p>转换yolo输出并生成<code>submission.csv</code>文件:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 路径配置</span></span><br><span class="line">test_images_dir = Path(<span class="string">r&#x27;/kaggle/input/global-wheat-detection/test&#x27;</span>)</span><br><span class="line">pred_labels_dir = Path(<span class="string">r&#x27;/kaggle/working/yolov5/runs/predict/wheat_test/labels&#x27;</span>)</span><br><span class="line">submission_path = <span class="string">&#x27;/kaggle/working/submission.csv&#x27;</span></span><br><span class="line"></span><br><span class="line">results = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> image_path <span class="keyword">in</span> test_images_dir.glob(<span class="string">&#x27;*.jpg&#x27;</span>):</span><br><span class="line">    image_id = image_path.stem</span><br><span class="line">    label_path = pred_labels_dir / <span class="string">f&quot;<span class="subst">&#123;image_id&#125;</span>.txt&quot;</span></span><br><span class="line"></span><br><span class="line">    prediction_string = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> label_path.exists():</span><br><span class="line">        <span class="keyword">with</span> Image.<span class="built_in">open</span>(image_path) <span class="keyword">as</span> im:</span><br><span class="line">            img_w, img_h = im.size</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(label_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                parts = line.strip().split()</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(parts) == <span class="number">6</span>:</span><br><span class="line">                    cls, x_center, y_center, width, height, conf = <span class="built_in">map</span>(<span class="built_in">float</span>, parts)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 转回左上角坐标</span></span><br><span class="line">                    x_min = (x_center - width / <span class="number">2</span>) * img_w</span><br><span class="line">                    y_min = (y_center - height / <span class="number">2</span>) * img_h</span><br><span class="line">                    box_w = width * img_w</span><br><span class="line">                    box_h = height * img_h</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 拼接字符串：confidence x y w h</span></span><br><span class="line">                    prediction_string += <span class="string">f&quot;<span class="subst">&#123;conf:<span class="number">.4</span>f&#125;</span> <span class="subst">&#123;x_min:<span class="number">.1</span>f&#125;</span> <span class="subst">&#123;y_min:<span class="number">.1</span>f&#125;</span> <span class="subst">&#123;box_w:<span class="number">.1</span>f&#125;</span> <span class="subst">&#123;box_h:<span class="number">.1</span>f&#125;</span> &quot;</span></span><br><span class="line"></span><br><span class="line">    results.append(&#123;</span><br><span class="line">        <span class="string">&quot;image_id&quot;</span>: image_id,</span><br><span class="line">        <span class="string">&quot;PredictionString&quot;</span>: prediction_string.strip()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存为 CSV</span></span><br><span class="line">df = pd.DataFrame(results)</span><br><span class="line">df.to_csv(submission_path, index=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;✅ 已保存提交文件: <span class="subst">&#123;submission_path&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>最终分数如下：<br><img src="https://images.whff521.top/Screenshot%202025-07-22%20at%2015.00.49.png" alt="分数"></p><p>分数和榜单上还差很多。经过几天的搜索关于目标检测竞赛的信息和查看别人的解决方案，我认为直接使用YOLO可能是一个非常坏的选择。</p><p>PS：封面图来源：<a href="https://x.com/nakiriayame/status/1946793366399918121?s=46">百鬼あやめ😈ホロライブ2期生</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yolo </tag>
            
            <tag> Kaggle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLOv5使用方法</title>
      <link href="/2025/07/21/YOLOv5%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2025/07/21/YOLOv5%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="YOLOv5使用方法"><a href="#YOLOv5使用方法" class="headerlink" title="YOLOv5使用方法"></a>YOLOv5使用方法</h1><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>YOLOv5 使用的数据集遵循的是 <strong>YOLO格式（YOLO annotation format）</strong>。以下是 YOLOv5 所需数据集的完整规范：</p><hr><h4 id="✅-1-目录结构"><a href="#✅-1-目录结构" class="headerlink" title="✅ 1. 目录结构"></a>✅ 1. <strong>目录结构</strong></h4><p>YOLOv5 通常的数据集结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dataset/</span><br><span class="line">├── images/</span><br><span class="line">│   ├── train/</span><br><span class="line">│   │   ├── img1.jpg</span><br><span class="line">│   │   ├── img2.jpg</span><br><span class="line">│   ├── val/</span><br><span class="line">│   │   ├── img3.jpg</span><br><span class="line">│   │   ├── img4.jpg</span><br><span class="line">│</span><br><span class="line">├── labels/</span><br><span class="line">│   ├── train/</span><br><span class="line">│   │   ├── img1.txt</span><br><span class="line">│   │   ├── img2.txt</span><br><span class="line">│   ├── val/</span><br><span class="line">│   │   ├── img3.txt</span><br><span class="line">│   │   ├── img4.txt</span><br><span class="line">│</span><br><span class="line">└── data.yaml</span><br></pre></td></tr></table></figure><hr><h4 id="✅-2-标签文件格式（-txt）"><a href="#✅-2-标签文件格式（-txt）" class="headerlink" title="✅ 2. 标签文件格式（.txt）"></a>✅ 2. <strong>标签文件格式（<code>.txt</code>）</strong></h4><p>每张图像对应一个 <code>.txt</code> 文件，命名相同，内容如下格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;class_id&gt; &lt;x_center&gt; &lt;y_center&gt; &lt;width&gt; &lt;height&gt;</span><br></pre></td></tr></table></figure><h5 id="坐标说明："><a href="#坐标说明：" class="headerlink" title="坐标说明："></a>坐标说明：</h5><ul><li><code>class_id</code>：整数，表示目标所属的类别，从0开始。</li><li><code>x_center</code>、<code>y_center</code>：目标中心的相对位置（范围是0~1，相对于图像宽度和高度）。</li><li><code>width</code>、<code>height</code>：目标框的相对宽度和高度（范围0~1）。</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0.5 0.5 0.2 0.3</span><br></pre></td></tr></table></figure><p>表示第0类物体，其边界框中心在图像正中间，宽20%，高30%。</p><hr><h4 id="✅-3-data-yaml-文件格式"><a href="#✅-3-data-yaml-文件格式" class="headerlink" title="✅ 3. data.yaml 文件格式"></a>✅ 3. <strong><code>data.yaml</code> 文件格式</strong></h4><p>用于配置训练集、验证集、类别名等信息。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># path: ./dataset</span></span><br><span class="line"><span class="attr">train:</span> <span class="string">images/train</span></span><br><span class="line"><span class="attr">val:</span> <span class="string">images/val</span></span><br><span class="line"><span class="comment"># test: ./dataset/images/test</span></span><br><span class="line"><span class="attr">nc:</span> <span class="number">3</span>  <span class="comment"># 类别数量</span></span><br><span class="line"><span class="attr">names:</span> [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;person&#x27;</span>]  <span class="comment"># 类别名称列表</span></span><br></pre></td></tr></table></figure><p>注释代表非必须字段，<code>path</code>指定后后面的路径只需写相对路径</p><hr><h4 id="✅-4-图片格式"><a href="#✅-4-图片格式" class="headerlink" title="✅ 4. 图片格式"></a>✅ 4. <strong>图片格式</strong></h4><ul><li>支持常见格式：<code>.jpg</code>, <code>.jpeg</code>, <code>.png</code></li><li>图片尺寸不必统一，但建议大小适中（训练时可自动resize）</li></ul><hr><h4 id="✅-5-常见注意事项"><a href="#✅-5-常见注意事项" class="headerlink" title="✅ 5. 常见注意事项"></a>✅ 5. <strong>常见注意事项</strong></h4><ul><li>标签文件中坐标必须是 <strong>归一化格式</strong>，即相对于图像宽高，范围在 <code>[0, 1]</code>。</li><li>每一行为一个标注框，<strong>没有标注的图像也必须有空的 <code>.txt</code> 文件</strong>。</li><li><code>images/train</code> 和 <code>labels/train</code> 中的文件名必须一一对应。</li></ul><hr><h4 id="✅-示例"><a href="#✅-示例" class="headerlink" title="✅ 示例"></a>✅ 示例</h4><p>假设有一张图像 <code>dog.jpg</code> 尺寸为 <code>800x600</code>，目标狗的位置是：</p><ul><li>左上角 <code>(x1=200, y1=150)</code></li><li>右下角 <code>(x2=600, y2=450)</code></li></ul><p>则：</p><ul><li><code>x_center = (200+600)/2 / 800 = 0.5</code></li><li><code>y_center = (150+450)/2 / 600 = 0.5</code></li><li><code>width = (600 - 200) / 800 = 0.5</code></li><li><code>height = (450 - 150) / 600 = 0.5</code></li></ul><p>标签行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 0.5 0.5 0.5 0.5</span><br></pre></td></tr></table></figure><p>（假设“狗”的 <code>class_id=1</code>）</p><h2 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h2><p>YOLOv5 的配置文件主要包括以下几类，它们用于配置模型结构、训练过程、数据集路径等。下面是各类配置文件的说明：</p><hr><h4 id="🗂-1-data-yaml-—-数据集配置文件（训练-验证-测试路径-类别信息）"><a href="#🗂-1-data-yaml-—-数据集配置文件（训练-验证-测试路径-类别信息）" class="headerlink" title="🗂 1. data.yaml — 数据集配置文件（训练/验证/测试路径 + 类别信息）"></a>🗂 1. <code>data.yaml</code> — 数据集配置文件（<strong>训练/验证/测试路径 + 类别信息</strong>）</h4><p>位置：你自己创建或放在 <code>data/</code> 目录中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">../dataset</span>                 <span class="comment"># 数据集根路径（可选）</span></span><br><span class="line"><span class="attr">train:</span> <span class="string">images/train</span>              <span class="comment"># 训练图片路径（相对 path 或绝对路径）</span></span><br><span class="line"><span class="attr">val:</span> <span class="string">images/val</span>                  <span class="comment"># 验证图片路径</span></span><br><span class="line"><span class="attr">test:</span> <span class="string">images/test</span>                <span class="comment"># （可选）测试图片路径</span></span><br><span class="line"></span><br><span class="line"><span class="attr">nc:</span> <span class="number">3</span>                            <span class="comment"># 类别数量</span></span><br><span class="line"><span class="attr">names:</span> [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;person&#x27;</span>]  <span class="comment"># 类别名称列表</span></span><br></pre></td></tr></table></figure><hr><h4 id="📐-2-yaml-—-模型结构配置文件（模型架构与参数设置）"><a href="#📐-2-yaml-—-模型结构配置文件（模型架构与参数设置）" class="headerlink" title="📐 2. *.yaml — 模型结构配置文件（模型架构与参数设置）"></a>📐 2. <code>*.yaml</code> — 模型结构配置文件（<strong>模型架构与参数设置</strong>）</h4><p>位置：<code>models/</code> 目录下，常见如 <code>yolov5s.yaml</code>、<code>yolov5m.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yolov5s.yaml 示例</span></span><br><span class="line"><span class="attr">nc:</span> <span class="number">80</span>  <span class="comment"># 类别数，会在训练时被 data.yaml 中的 nc 覆盖</span></span><br><span class="line"><span class="attr">depth_multiple:</span> <span class="number">0.33</span>  <span class="comment"># 网络深度系数（层数缩放）</span></span><br><span class="line"><span class="attr">width_multiple:</span> <span class="number">0.50</span>  <span class="comment"># 通道宽度系数（通道数缩放）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">anchors:</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">10</span>,<span class="number">13</span>, <span class="number">16</span>,<span class="number">30</span>, <span class="number">33</span>,<span class="number">23</span>]  <span class="comment"># P3</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">30</span>,<span class="number">61</span>, <span class="number">62</span>,<span class="number">45</span>, <span class="number">59</span>,<span class="number">119</span>] <span class="comment"># P4</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">116</span>,<span class="number">90</span>, <span class="number">156</span>,<span class="number">198</span>, <span class="number">373</span>,<span class="number">326</span>] <span class="comment"># P5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">backbone:</span></span><br><span class="line">  [[<span class="number">-1</span>, <span class="number">1</span>, <span class="string">Focus</span>, [<span class="number">64</span>, <span class="number">3</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, <span class="string">Conv</span>, [<span class="number">128</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">   <span class="string">...</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">head:</span></span><br><span class="line">  [[<span class="number">-1</span>, <span class="number">1</span>, <span class="string">Detect</span>, [<span class="string">nc</span>, <span class="string">anchors</span>]]]</span><br></pre></td></tr></table></figure><blockquote><p>✅ 训练时，使用的是你自己选择的模型结构文件（通过 <code>--cfg</code> 或 <code>--weights</code> 推断出）。</p></blockquote><hr><h4 id="⚙️-3-hyp-yaml-—-超参数配置文件（学习率、增强、损失函数等超参数）"><a href="#⚙️-3-hyp-yaml-—-超参数配置文件（学习率、增强、损失函数等超参数）" class="headerlink" title="⚙️ 3. hyp.yaml — 超参数配置文件（学习率、增强、损失函数等超参数）"></a>⚙️ 3. <code>hyp.yaml</code> — 超参数配置文件（<strong>学习率、增强、损失函数等超参数</strong>）</h4><p>位置：默认在 <code>data/hyps/</code> 目录下，如 <code>hyp.scratch-low.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lr0:</span> <span class="number">0.01</span>           <span class="comment"># 初始学习率</span></span><br><span class="line"><span class="attr">lrf:</span> <span class="number">0.01</span>           <span class="comment"># 最终学习率 (final LR = lr0 * lrf)</span></span><br><span class="line"><span class="attr">momentum:</span> <span class="number">0.937</span>     <span class="comment"># SGD动量</span></span><br><span class="line"><span class="attr">weight_decay:</span> <span class="number">0.0005</span></span><br><span class="line"><span class="attr">warmup_epochs:</span> <span class="number">3.0</span>  <span class="comment"># 预热轮数</span></span><br><span class="line"><span class="attr">hsv_h:</span> <span class="number">0.015</span>        <span class="comment"># 色调增强</span></span><br><span class="line"><span class="attr">hsv_s:</span> <span class="number">0.7</span>          <span class="comment"># 饱和度增强</span></span><br><span class="line"><span class="attr">fl_gamma:</span> <span class="number">0.0</span>       <span class="comment"># Focal Loss gamma</span></span><br></pre></td></tr></table></figure><blockquote><p>你可以通过 <code>--hyp</code> 参数指定这个文件，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py --hyp data/hyps/hyp.scratch-low.yaml</span><br></pre></td></tr></table></figure></blockquote><hr><h4 id="✅-小结：三大核心配置文件说明表"><a href="#✅-小结：三大核心配置文件说明表" class="headerlink" title="✅ 小结：三大核心配置文件说明表"></a>✅ 小结：三大核心配置文件说明表</h4><div class="table-container"><table><thead><tr><th>配置文件</th><th>作用</th><th>常见位置</th></tr></thead><tbody><tr><td><code>data.yaml</code></td><td>指定训练/验证/测试集和类别信息</td><td>你项目目录 / <code>data/</code></td></tr><tr><td><code>*.yaml</code></td><td>定义模型结构（yolov5s 等）</td><td><code>models/</code></td></tr><tr><td><code>hyp.yaml</code></td><td>设置训练超参数（增强、LR 等）</td><td><code>data/hyps/</code></td></tr></tbody></table></div><hr><h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><h3 id="执行指令说明"><a href="#执行指令说明" class="headerlink" title="执行指令说明"></a>执行指令说明</h3><p>一般训练运行命令行命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py --img 640 --batch 16 --epochs 50 --data wheat.yaml --weights yolov5s.pt --name wheat_yolov5</span><br></pre></td></tr></table></figure></p><hr><h4 id="📂-模型与数据相关参数"><a href="#📂-模型与数据相关参数" class="headerlink" title="📂 模型与数据相关参数"></a>📂 模型与数据相关参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--weights</code></td><td><code>str</code></td><td><code>yolov5s.pt</code></td><td>初始权重路径，可为官方模型或自定义训练的 <code>.pt</code> 文件。</td></tr><tr><td><code>--cfg</code></td><td><code>str</code></td><td><code>&quot;&quot;</code></td><td>模型结构配置文件（如 <code>yolov5s.yaml</code>）。为空则从 <code>weights</code> 推断。</td></tr><tr><td><code>--data</code></td><td><code>str</code></td><td><code>data/coco128.yaml</code></td><td>数据集配置文件，包含 <code>train</code>, <code>val</code>, <code>nc</code>, <code>names</code> 等字段。</td></tr><tr><td><code>--hyp</code></td><td><code>str</code></td><td><code>data/hyps/hyp.scratch-low.yaml</code></td><td>超参数配置文件，包括学习率、IoU阈值、损失等。</td></tr></tbody></table></div><hr><h4 id="📈-训练控制参数"><a href="#📈-训练控制参数" class="headerlink" title="📈 训练控制参数"></a>📈 训练控制参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--epochs</code></td><td><code>int</code></td><td><code>100</code></td><td>训练总轮数。</td></tr><tr><td><code>--batch-size</code></td><td><code>int</code></td><td><code>16</code></td><td>批大小，所有GPU总和。<code>-1</code> 表示自动推断。</td></tr><tr><td><code>--imgsz</code> / <code>--img</code> / <code>--img-size</code></td><td><code>int</code></td><td><code>640</code></td><td>输入图像尺寸（会缩放为正方形）。</td></tr><tr><td><code>--rect</code></td><td><code>store_true</code></td><td><code>False</code></td><td>是否启用矩形训练（图像按长宽比例分组）。</td></tr><tr><td><code>--multi-scale</code></td><td><code>store_true</code></td><td><code>False</code></td><td>是否在训练中动态改变图像大小（±50%）。</td></tr><tr><td><code>--resume</code></td><td>可选参数</td><td><code>False</code></td><td>是否从最近的断点继续训练。</td></tr><tr><td><code>--freeze</code></td><td><code>List[int]</code></td><td><code>[0]</code></td><td>冻结网络层，示例：<code>--freeze 0 1 2</code> 表示冻结前3层。</td></tr><tr><td><code>--single-cls</code></td><td><code>store_true</code></td><td><code>False</code></td><td>是否将所有类别视为一个类别（适用于单类数据）。</td></tr></tbody></table></div><hr><h4 id="💾-模型保存与验证参数"><a href="#💾-模型保存与验证参数" class="headerlink" title="💾 模型保存与验证参数"></a>💾 模型保存与验证参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--nosave</code></td><td><code>store_true</code></td><td><code>False</code></td><td>是否只保存最后一个模型，不保存中间checkpoint。</td></tr><tr><td><code>--noval</code></td><td><code>store_true</code></td><td><code>False</code></td><td>是否仅在最后一个 epoch 验证模型性能。</td></tr><tr><td><code>--save-period</code></td><td><code>int</code></td><td><code>-1</code></td><td>每间隔 x 个 epoch 保存一次模型。小于1表示禁用。</td></tr></tbody></table></div><hr><h4 id="🧠-超参数进化（进阶功能）"><a href="#🧠-超参数进化（进阶功能）" class="headerlink" title="🧠 超参数进化（进阶功能）"></a>🧠 超参数进化（进阶功能）</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--evolve</code></td><td><code>int</code></td><td>可选，默认<code>300</code></td><td>使用遗传算法自动进化超参数，运行 <code>x</code> 代。</td></tr><tr><td><code>--evolve_population</code></td><td><code>str</code></td><td><code>data/hyps</code></td><td>进化时加载的初始种群超参数路径。</td></tr><tr><td><code>--resume_evolve</code></td><td><code>str</code></td><td><code>None</code></td><td>从先前进化的最后一代恢复。</td></tr></tbody></table></div><hr><h4 id="🧰-运行控制参数"><a href="#🧰-运行控制参数" class="headerlink" title="🧰 运行控制参数"></a>🧰 运行控制参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--device</code></td><td><code>str</code></td><td><code>&quot;&quot;</code></td><td>指定设备：如 <code>0</code>、<code>0,1</code> 或 <code>cpu</code>。</td></tr><tr><td><code>--optimizer</code></td><td><code>str</code></td><td><code>SGD</code></td><td>选择优化器：<code>SGD</code>, <code>Adam</code>, <code>AdamW</code>。</td></tr><tr><td><code>--sync-bn</code></td><td><code>store_true</code></td><td><code>False</code></td><td>启用同步BatchNorm（仅 DDP 模式有效）。</td></tr><tr><td><code>--quad</code></td><td><code>store_true</code></td><td><code>False</code></td><td>启用四元加载器优化（某些GPU加速）。</td></tr><tr><td><code>--cos-lr</code></td><td><code>store_true</code></td><td><code>False</code></td><td>使用余弦学习率调度器。</td></tr><tr><td><code>--label-smoothing</code></td><td><code>float</code></td><td><code>0.0</code></td><td>标签平滑因子（防止过拟合）。</td></tr><tr><td><code>--patience</code></td><td><code>int</code></td><td><code>100</code></td><td>EarlyStopping容忍的无改进epoch数。</td></tr><tr><td><code>--seed</code></td><td><code>int</code></td><td><code>0</code></td><td>设置随机种子，确保结果可复现。</td></tr><tr><td><code>--workers</code></td><td><code>int</code></td><td><code>8</code></td><td>每个进程的数据加载线程数。</td></tr><tr><td><code>--local_rank</code></td><td><code>int</code></td><td><code>-1</code></td><td>DDP 多GPU模式下自动设置，不要手动修改。</td></tr></tbody></table></div><hr><h4 id="📝-日志记录与结果保存"><a href="#📝-日志记录与结果保存" class="headerlink" title="📝 日志记录与结果保存"></a>📝 日志记录与结果保存</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--project</code></td><td><code>str</code></td><td><code>runs/train</code></td><td>保存训练结果的项目目录。</td></tr><tr><td><code>--name</code></td><td><code>str</code></td><td><code>exp</code></td><td>子目录名称。</td></tr><tr><td><code>--exist-ok</code></td><td><code>store_true</code></td><td><code>False</code></td><td>如果目录存在，则不自动增加编号。</td></tr></tbody></table></div><hr><h4 id="☁️-云与缓存相关"><a href="#☁️-云与缓存相关" class="headerlink" title="☁️ 云与缓存相关"></a>☁️ 云与缓存相关</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--bucket</code></td><td><code>str</code></td><td><code>&quot;&quot;</code></td><td>用于 Google Cloud Storage 的 gsutil bucket 路径。</td></tr><tr><td><code>--cache</code></td><td><code>str</code></td><td>可选</td><td><code>ram</code> 或 <code>disk</code>，缓存图像到内存或硬盘以加速训练。</td></tr><tr><td><code>--image-weights</code></td><td><code>store_true</code></td><td><code>False</code></td><td>图像采样根据权重进行（提升少数类样本）。</td></tr></tbody></table></div><hr><h4 id="🔗-W-amp-B-Artifact-日志参数（用于实验追踪）"><a href="#🔗-W-amp-B-Artifact-日志参数（用于实验追踪）" class="headerlink" title="🔗 W\&amp;B / Artifact 日志参数（用于实验追踪）"></a>🔗 W\&amp;B / Artifact 日志参数（用于实验追踪）</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--entity</code></td><td><code>str</code></td><td><code>None</code></td><td>W\&amp;B 实验的团队或个人实体名。</td></tr><tr><td><code>--upload_dataset</code></td><td><code>store_true</code></td><td><code>False</code></td><td>是否上传数据集到 W\&amp;B。可选 <code>&quot;val&quot;</code>。</td></tr><tr><td><code>--bbox_interval</code></td><td><code>int</code></td><td><code>-1</code></td><td>日志中显示检测框图片的间隔 epoch。</td></tr><tr><td><code>--artifact_alias</code></td><td><code>str</code></td><td><code>&quot;latest&quot;</code></td><td>指定使用的 artifact 版本标签。</td></tr></tbody></table></div><hr><h4 id="🧾-NDJSON-日志参数（结构化日志）"><a href="#🧾-NDJSON-日志参数（结构化日志）" class="headerlink" title="🧾 NDJSON 日志参数（结构化日志）"></a>🧾 NDJSON 日志参数（结构化日志）</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--ndjson-console</code></td><td><code>store_true</code></td><td><code>False</code></td><td>在控制台输出 ndjson 格式日志。</td></tr><tr><td><code>--ndjson-file</code></td><td><code>store_true</code></td><td><code>False</code></td><td>将 ndjson 日志输出到文件。</td></tr></tbody></table></div><hr><h2 id="模型推理与验证"><a href="#模型推理与验证" class="headerlink" title="模型推理与验证"></a>模型推理与验证</h2><h3 id="执行指令说明-1"><a href="#执行指令说明-1" class="headerlink" title="执行指令说明"></a>执行指令说明</h3><p>一般目标检测执行命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python detect.py --weights runs/train/wheat_yolov5/weights/best.pt --source /test_image_folder --img 640 --conf 0.25 --save-txt --save-conf --project runs/predict --name wheat_test</span><br></pre></td></tr></table></figure></p><h4 id="🎯-核心推理参数"><a href="#🎯-核心推理参数" class="headerlink" title="🎯 核心推理参数"></a>🎯 核心推理参数</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--weights</code></td><td><code>str/list[str]</code></td><td><code>yolov5s.pt</code></td><td>模型路径（<code>.pt</code> 文件），也可为多个模型或 Triton 服务器地址。</td></tr><tr><td><code>--source</code></td><td><code>str</code></td><td><code>data/images</code></td><td>输入来源：文件、文件夹、URL、glob、摄像头（如 <code>0</code>）或 <code>screen</code>。</td></tr><tr><td><code>--data</code></td><td><code>str</code></td><td><code>data/coco128.yaml</code></td><td>数据集配置文件（可选）。用于加载类别名等信息。</td></tr><tr><td><code>--imgsz</code> / <code>--img</code> / <code>--img-size</code></td><td><code>list[int]</code></td><td><code>[640]</code></td><td>推理图像的尺寸，单个值或 <code>[h, w]</code>。如果只给一个，则会扩展成 <code>[640, 640]</code>。</td></tr><tr><td><code>--conf-thres</code></td><td><code>float</code></td><td><code>0.25</code></td><td>置信度阈值，低于该值的检测框会被过滤。</td></tr><tr><td><code>--iou-thres</code></td><td><code>float</code></td><td><code>0.45</code></td><td>非极大值抑制（NMS）中的 IoU 阈值。</td></tr><tr><td><code>--max-det</code></td><td><code>int</code></td><td><code>1000</code></td><td>每张图片最多保留的目标检测数量。</td></tr><tr><td><code>--device</code></td><td><code>str</code></td><td><code>&quot;&quot;</code></td><td>计算设备，如 <code>&#39;0&#39;</code>, <code>&#39;0,1&#39;</code>, <code>&#39;cpu&#39;</code> 等。</td></tr></tbody></table></div><hr><h4 id="🖼️-可视化与保存选项"><a href="#🖼️-可视化与保存选项" class="headerlink" title="🖼️ 可视化与保存选项"></a>🖼️ 可视化与保存选项</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--view-img</code></td><td><code>bool</code></td><td><code>False</code></td><td>是否显示检测结果图像（本地窗口）。</td></tr><tr><td><code>--save-txt</code></td><td><code>bool</code></td><td><code>False</code></td><td>是否将检测结果保存为 <code>.txt</code> 文件（YOLO格式或Pascal VOC格式）。</td></tr><tr><td><code>--save-format</code></td><td><code>int</code></td><td><code>0</code></td><td>配合 <code>--save-txt</code>：<code>0</code> 为 YOLO 格式，<code>1</code> 为 Pascal VOC 格式。</td></tr><tr><td><code>--save-csv</code></td><td><code>bool</code></td><td><code>False</code></td><td>是否将结果保存为 <code>.csv</code> 文件。</td></tr><tr><td><code>--save-conf</code></td><td><code>bool</code></td><td><code>False</code></td><td>是否将置信度一同保存到 <code>.txt</code> 文件中。</td></tr><tr><td><code>--save-crop</code></td><td><code>bool</code></td><td><code>False</code></td><td>是否保存每个检测框裁剪出的目标图像。</td></tr><tr><td><code>--nosave</code></td><td><code>bool</code></td><td><code>False</code></td><td>不保存任何图像或视频结果，仅在控制台输出。</td></tr><tr><td><code>--project</code></td><td><code>str</code></td><td><code>runs/detect</code></td><td>结果保存根目录。</td></tr><tr><td><code>--name</code></td><td><code>str</code></td><td><code>exp</code></td><td>子目录名称。</td></tr><tr><td><code>--exist-ok</code></td><td><code>bool</code></td><td><code>False</code></td><td>如果目录已存在，不自动创建 <code>exp2</code>, <code>exp3</code>，而是直接覆盖或重用。</td></tr><tr><td><code>--line-thickness</code></td><td><code>int</code></td><td><code>3</code></td><td>检测框的线宽（像素）。</td></tr><tr><td><code>--hide-labels</code></td><td><code>bool</code></td><td><code>False</code></td><td>不在图像上显示类别标签。</td></tr><tr><td><code>--hide-conf</code></td><td><code>bool</code></td><td><code>False</code></td><td>不在图像上显示置信度分数。</td></tr></tbody></table></div><hr><h4 id="📊-检测控制选项"><a href="#📊-检测控制选项" class="headerlink" title="📊 检测控制选项"></a>📊 检测控制选项</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--classes</code></td><td><code>list[int]</code></td><td><code>None</code></td><td>仅检测指定类别，例如 <code>--classes 0 2 3</code>。</td></tr><tr><td><code>--agnostic-nms</code></td><td><code>bool</code></td><td><code>False</code></td><td>使用类别无关的 NMS（所有类别共用抑制逻辑）。</td></tr><tr><td><code>--augment</code></td><td><code>bool</code></td><td><code>False</code></td><td>启用数据增强的推理（略慢但可能更鲁棒）。</td></tr><tr><td><code>--visualize</code></td><td><code>bool</code></td><td><code>False</code></td><td>可视化中间特征图（需模型支持）。</td></tr><tr><td><code>--update</code></td><td><code>bool</code></td><td><code>False</code></td><td>自动更新模型（转换旧格式为新格式）。</td></tr><tr><td><code>--half</code></td><td><code>bool</code></td><td><code>False</code></td><td>使用半精度（FP16）推理，仅限于 <code>CUDA</code>。</td></tr><tr><td><code>--dnn</code></td><td><code>bool</code></td><td><code>False</code></td><td>使用 OpenCV DNN 模式进行 ONNX 推理。</td></tr><tr><td><code>--vid-stride</code></td><td><code>int</code></td><td><code>1</code></td><td>视频推理时的帧跳跃间隔，例如 <code>--vid-stride 5</code> 表示每5帧处理一帧。</td></tr></tbody></table></div><hr><h4 id="✅-示例命令"><a href="#✅-示例命令" class="headerlink" title="✅ 示例命令"></a>✅ 示例命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测单张图片并保存结果</span></span><br><span class="line">python detect.py --weights yolov5s.pt --<span class="built_in">source</span> ./data/images/zidane.jpg --conf-thres 0.3 --save-txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅检测类别 0 和 2，显示结果但不保存图像</span></span><br><span class="line">python detect.py --weights yolov5s.pt --<span class="built_in">source</span> ./data/images --classes 0 2 --view-img --nosave</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对视频推理，每5帧检测一次，保存检测框为 Pascal VOC 格式</span></span><br><span class="line">python detect.py --weights yolov5s.pt --<span class="built_in">source</span> video.mp4 --vid-stride 5 --save-txt --save-format 1</span><br></pre></td></tr></table></figure><h2 id="模型导出与部署"><a href="#模型导出与部署" class="headerlink" title="模型导出与部署"></a>模型导出与部署</h2><h3 id="执行指令说明-2"><a href="#执行指令说明-2" class="headerlink" title="执行指令说明"></a>执行指令说明</h3><p>以下是对每个命令行参数的详细解释：</p><hr><h4 id="🗂️-数据和模型路径配置"><a href="#🗂️-数据和模型路径配置" class="headerlink" title="🗂️ 数据和模型路径配置"></a>🗂️ 数据和模型路径配置</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--data</code></td><td>str</td><td><code>data/coco128.yaml</code></td><td>数据集配置文件路径，主要用于获取类别数等信息</td></tr><tr><td><code>--weights</code></td><td>str/list</td><td><code>yolov5s.pt</code></td><td>训练好的模型权重路径，支持多个模型同时导出</td></tr><tr><td><code>--imgsz</code> / <code>--img</code> / <code>--img-size</code></td><td>int list</td><td><code>[640, 640]</code></td><td>输入图片尺寸 <code>[height, width]</code>，默认是正方形</td></tr><tr><td><code>--batch-size</code></td><td>int</td><td>1</td><td>推理时的 batch size，一般保持为1以防不兼容</td></tr></tbody></table></div><hr><h4 id="⚙️-设备和推理精度"><a href="#⚙️-设备和推理精度" class="headerlink" title="⚙️ 设备和推理精度"></a>⚙️ 设备和推理精度</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--device</code></td><td>str</td><td><code>cpu</code></td><td>运行导出过程所使用的设备，如 <code>0</code>, <code>cpu</code>, <code>0,1</code> 等</td></tr><tr><td><code>--half</code></td><td>flag</td><td>False</td><td>是否使用 FP16 精度导出（仅限支持的平台）</td></tr></tbody></table></div><hr><h4 id="⚙️-导出行为控制"><a href="#⚙️-导出行为控制" class="headerlink" title="⚙️ 导出行为控制"></a>⚙️ 导出行为控制</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--inplace</code></td><td>flag</td><td>False</td><td>是否将 Detect() 的 <code>inplace=True</code>，影响模型输出张量的修改方式</td></tr><tr><td><code>--keras</code></td><td>flag</td><td>False</td><td>TensorFlow 导出时是否使用 Keras 模式（<code>.h5</code>）</td></tr><tr><td><code>--optimize</code></td><td>flag</td><td>False</td><td>TorchScript 优化用于移动端部署（会应用 graph 优化）</td></tr></tbody></table></div><hr><h4 id="🎯-量化和动态轴控制"><a href="#🎯-量化和动态轴控制" class="headerlink" title="🎯 量化和动态轴控制"></a>🎯 量化和动态轴控制</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--int8</code></td><td>flag</td><td>False</td><td>导出 INT8 量化模型（支持 TF、CoreML、OpenVINO）</td></tr><tr><td><code>--per-tensor</code></td><td>flag</td><td>False</td><td>TensorFlow 的 per-tensor 量化方式（默认是 per-channel）</td></tr><tr><td><code>--dynamic</code></td><td>flag</td><td>False</td><td>启用动态输入尺寸（支持 ONNX、TF、TensorRT）</td></tr></tbody></table></div><hr><h4 id="🧠-ONNX-相关"><a href="#🧠-ONNX-相关" class="headerlink" title="🧠 ONNX 相关"></a>🧠 ONNX 相关</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--simplify</code></td><td>flag</td><td>False</td><td>简化 ONNX 模型图（需安装 <code>onnxsim</code>）</td></tr><tr><td><code>--opset</code></td><td>int</td><td>17</td><td>ONNX 的 opset 版本，常见为 11~17</td></tr></tbody></table></div><hr><h4 id="🧠-TensorRT-相关"><a href="#🧠-TensorRT-相关" class="headerlink" title="🧠 TensorRT 相关"></a>🧠 TensorRT 相关</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--engine</code>（由 <code>--include engine</code> 控制）</td><td></td><td></td><td>TensorRT 导出开关</td></tr><tr><td><code>--cache</code></td><td>str</td><td>“”</td><td>TensorRT 的时间 cache 文件路径（加速编译）</td></tr><tr><td><code>--workspace</code></td><td>int</td><td>4</td><td>TensorRT 最大 workspace 大小（单位 GB）</td></tr><tr><td><code>--verbose</code></td><td>flag</td><td>False</td><td>TensorRT 导出时是否打印详细日志</td></tr></tbody></table></div><hr><h4 id="🍏-CoreML-相关"><a href="#🍏-CoreML-相关" class="headerlink" title="🍏 CoreML 相关"></a>🍏 CoreML 相关</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--mlmodel</code></td><td>flag</td><td>False</td><td>导出 CoreML <code>.mlmodel</code> 格式</td></tr><tr><td><code>--int8</code></td><td>flag</td><td>False</td><td>可配合用于量化 CoreML</td></tr></tbody></table></div><hr><h4 id="🧪-TensorFlow-js（TF-js）相关（用于-Web-端）"><a href="#🧪-TensorFlow-js（TF-js）相关（用于-Web-端）" class="headerlink" title="🧪 TensorFlow.js（TF.js）相关（用于 Web 端）"></a>🧪 TensorFlow.js（TF.js）相关（用于 Web 端）</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--nms</code></td><td>flag</td><td>False</td><td>添加非极大抑制 NMS（默认模型中不包含）</td></tr><tr><td><code>--agnostic-nms</code></td><td>flag</td><td>False</td><td>类别无关的 NMS</td></tr><tr><td><code>--topk-per-class</code></td><td>int</td><td>100</td><td>每个类别保留前 K 个检测结果</td></tr><tr><td><code>--topk-all</code></td><td>int</td><td>100</td><td>所有类别一共保留前 K 个检测结果</td></tr><tr><td><code>--iou-thres</code></td><td>float</td><td>0.45</td><td>NMS 的 IoU 阈值</td></tr><tr><td><code>--conf-thres</code></td><td>float</td><td>0.25</td><td>置信度阈值，低于此值的框会被丢弃</td></tr></tbody></table></div><hr><h4 id="🎯-导出格式设置（核心参数）"><a href="#🎯-导出格式设置（核心参数）" class="headerlink" title="🎯 导出格式设置（核心参数）"></a>🎯 导出格式设置（核心参数）</h4><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>--include</code></td><td>list</td><td><code>[&#39;torchscript&#39;]</code></td><td>要导出的格式，可以包含多个：<br> <code>torchscript</code>, <code>onnx</code>, <code>openvino</code>, <code>engine</code>, <code>coreml</code>, <code>saved_model</code>, <code>pb</code>, <code>tflite</code>, <code>edgetpu</code>, <code>tfjs</code>, <code>paddle</code> 等</td></tr></tbody></table></div><hr><h3 id="✅-示例用法"><a href="#✅-示例用法" class="headerlink" title="✅ 示例用法"></a>✅ 示例用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出 ONNX + TorchScript + TensorRT 引擎（使用 GPU）</span></span><br><span class="line">python export.py \</span><br><span class="line">  --weights yolov5s.pt \</span><br><span class="line">  --img 640 \</span><br><span class="line">  --device 0 \</span><br><span class="line">  --include onnx torchscript engine \</span><br><span class="line">  --dynamic \</span><br><span class="line">  --simplify \</span><br><span class="line">  --opset 17</span><br></pre></td></tr></table></figure><hr><p>PS：封面图来源：<a href="https://x.com/nakiriayame/status/1946478772301213900?s=46"><br>百鬼あやめ😈ホロライブ2期生</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yolo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kaggle:  CIFAR-10-Object Recognition in Images</title>
      <link href="/2025/07/19/Kaggle-CIFAR-10-Object-Recognition-in-Images/"/>
      <url>/2025/07/19/Kaggle-CIFAR-10-Object-Recognition-in-Images/</url>
      
        <content type="html"><![CDATA[<h1 id="Kaggle-CIFAR-10-Object-Recognition-in-Images"><a href="#Kaggle-CIFAR-10-Object-Recognition-in-Images" class="headerlink" title="Kaggle:  CIFAR-10-Object Recognition in Images"></a>Kaggle:  CIFAR-10-Object Recognition in Images</h1><p>本文是实现<code>d2l</code>网站代码的总结，<a href="https://zh.d2l.ai/chapter_computer-vision/kaggle-cifar10.html#fig-kaggle-cifar10">教程链接</a></p><p>本文所用环境如下：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python==3.9.23</span><br><span class="line">nvidia-cuda-runtime-cu12==12.9.79</span><br><span class="line">torch==2.7.1+cu118</span><br><span class="line">d2l==1.0.3</span><br></pre></td></tr></table></figure></p><h2 id="📚-数据集介绍"><a href="#📚-数据集介绍" class="headerlink" title="📚 数据集介绍"></a>📚 数据集介绍</h2><p>CIFAR-10 是由加拿大多伦多大学 Alex Krizhevsky 等人收集的图像数据集，包含了 <strong>10 个类别的彩色图片</strong>。这些图片都是从真实世界拍摄的物体中裁剪而来的。</p><h3 id="📏-数据细节："><a href="#📏-数据细节：" class="headerlink" title="📏 数据细节："></a>📏 数据细节：</h3><div class="table-container"><table><thead><tr><th>项目</th><th>描述</th></tr></thead><tbody><tr><td>图片大小</td><td>32x32 像素，RGB（三通道）</td></tr><tr><td>图片数量</td><td>60,000 张图像</td></tr><tr><td>类别数量</td><td>10 个</td></tr><tr><td>训练集</td><td>50,000 张图像</td></tr><tr><td>测试集</td><td>10,000 张图像</td></tr><tr><td>图像格式</td><td><code>.png</code> 图像 + <code>.csv</code> 标签/预测</td></tr></tbody></table></div><h2 id="预测流程"><a href="#预测流程" class="headerlink" title="预测流程"></a>预测流程</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure><h3 id="数据整理"><a href="#数据整理" class="headerlink" title="数据整理"></a>数据整理</h3><p>我是将完整的数据集下载到本地然后直接用全部数据进行训练的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置数据集的存储位置</span></span><br><span class="line">data_dir = <span class="string">&#x27;D:\datasets\cifar-10&#x27;</span> </span><br></pre></td></tr></table></figure><p>文件夹中有<code>trainLabels.csv</code>,里边有<code>id</code>和<code>label</code>两列，分别代表图片名称和标签。</p><p>原教程是直接读取的文件，根据csv文件是用逗号分隔将文件拆成两部分然后转换成字典类型，实际上直接用<code>pandas</code>库就可以直接读取：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_csv_labels</span>(<span class="params">fname</span>):</span><br><span class="line">    df = pd.read_csv(fname)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(<span class="built_in">zip</span>(df[<span class="string">&#x27;id&#x27;</span>], df[<span class="string">&#x27;label&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">labels = read_csv_labels(os.path.join(data_dir,<span class="string">&#x27;trainLabels.csv&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;# training examples:&#x27;</span>, <span class="built_in">len</span>(labels))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;# classes:&#x27;</span>, <span class="built_in">len</span>(<span class="built_in">set</span>(labels.values())))</span><br></pre></td></tr></table></figure><p>这样我们就得到了标签字典，可以直接用<code>labels</code>查看图片的标签。</p><p>教程中为了方便读取图片，将图片的存储位置重新整理了一下，建立<code>train_valid_test</code>文件夹，里面有<code>train</code>,<code>valid</code>,<code>test</code>和<code>train_valid</code>四个文件夹。除了<code>test</code>文件夹，其他文件夹内均按照标签分成10个文件夹，每个图片根据自己的标签放到相应的文件夹里，这样做是为了后面分组的时候每组的标签尽量均匀。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">copyfile</span>(<span class="params">filename, target_dir</span>):</span><br><span class="line">    os.makedirs(target_dir,exist_ok=<span class="literal">True</span>)</span><br><span class="line">    shutil.copy(filename,target_dir)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reorg_train_valid</span>(<span class="params">data_dir, labels, valid_ratio</span>):</span><br><span class="line">    <span class="comment"># The number of examples of the class that has the fewest examples in the</span></span><br><span class="line">    <span class="comment"># training dataset</span></span><br><span class="line">    n = collections.Counter(labels.values()).most_common()[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">    n_valid_per_label = <span class="built_in">max</span>(<span class="number">1</span>,math.floor(n * valid_ratio))</span><br><span class="line">    label_count=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> train_file <span class="keyword">in</span> os.listdir(os.path.join(data_dir,<span class="string">&#x27;train&#x27;</span>)):</span><br><span class="line">        label = labels[train_file.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]]</span><br><span class="line">        fname = os.path.join(data_dir,<span class="string">&#x27;train&#x27;</span>,train_file)</span><br><span class="line">        copyfile(fname,os.path.join(data_dir,<span class="string">&#x27;train_valid_test&#x27;</span>,<span class="string">&#x27;train_valid&#x27;</span>,label))</span><br><span class="line">        <span class="keyword">if</span> label <span class="keyword">not</span> <span class="keyword">in</span> label_count <span class="keyword">or</span> label_count[label] &lt;n_valid_per_label:</span><br><span class="line">            copyfile(fname, os.path.join(data_dir,<span class="string">&#x27;train_valid_test&#x27;</span>,<span class="string">&#x27;valid&#x27;</span>,label))</span><br><span class="line">            label_count[label] = label_count.get(label,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            copyfile(fname, os.path.join(data_dir, <span class="string">&#x27;train_valid_test&#x27;</span>,<span class="string">&#x27;train&#x27;</span>,label))</span><br><span class="line">    <span class="keyword">return</span> n_valid_per_label</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reorg_test</span>(<span class="params">data_dir</span>):</span><br><span class="line">    <span class="keyword">for</span> test_file <span class="keyword">in</span> os.listdir(os.path.join(data_dir,<span class="string">&#x27;test&#x27;</span>)):</span><br><span class="line">        copyfile(os.path.join(data_dir, <span class="string">&#x27;test&#x27;</span>, test_file),</span><br><span class="line">                 os.path.join(data_dir,<span class="string">&#x27;train_valid_test&#x27;</span>,<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;unknown&#x27;</span>))</span><br></pre></td></tr></table></figure><p><code>valid_ratio</code>：验证集占比，如0.1表示验证集500张，训练集4500张</p><p>然后定义一个整合函数，将上面的函数流程统一处理：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reorg_cifar10_data</span>(<span class="params">data_dir,valid_ratio</span>):</span><br><span class="line">    labels = read_csv_labels(os.path.join(data_dir, <span class="string">&#x27;trainLabels.csv&#x27;</span>))</span><br><span class="line">    reorg_train_valid(data_dir, labels, valid_ratio)</span><br><span class="line">    reorg_test(data_dir)</span><br></pre></td></tr></table></figure></p><p>设置批量大小为128，将10％的训练样本作为调整超参数的验证集</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">valid_ratio = <span class="number">0.1</span></span><br><span class="line">reorg_cifar10_data(data_dir,valid_ratio)</span><br></pre></td></tr></table></figure><h3 id="图像增广"><a href="#图像增广" class="headerlink" title="图像增广"></a>图像增广</h3><p>为了防止过拟合，一般会采用图像增广。</p><p>标准化的原因：</p><ol><li>加快模型收敛速度。让特征值范围大致分布在[-1,1]</li><li>避免某些特征主导模型训练。让各通道均值为0，方差为1，平衡每个像素的“权重”</li><li>提高模型泛化能力</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">transform_train = torchvision.transforms.Compose([</span><br><span class="line">    <span class="comment"># 在高度和宽度上将图像放大到40像素的正方形</span></span><br><span class="line">    torchvision.transforms.Resize(<span class="number">40</span>),</span><br><span class="line">    <span class="comment"># 随机裁剪出一个高度和宽度均为40像素的正方形图像，</span></span><br><span class="line">    <span class="comment"># 生成一个面积为原始图像面积0.64～1倍的小正方形，</span></span><br><span class="line">    <span class="comment"># 然后将其缩放为高度和宽度均为32像素的正方形</span></span><br><span class="line">    torchvision.transforms.RandomResizedCrop(<span class="number">32</span>, scale=(<span class="number">0.64</span>, <span class="number">1.0</span>),</span><br><span class="line">                                                   ratio=(<span class="number">1.0</span>, <span class="number">1.0</span>)),</span><br><span class="line">    <span class="comment"># 随机水平翻转</span></span><br><span class="line">    torchvision.transforms.RandomHorizontalFlip(),</span><br><span class="line">    torchvision.transforms.ToTensor(),</span><br><span class="line">    <span class="comment"># 标准化图像的每个通道</span></span><br><span class="line">    <span class="comment"># 数字是根据数据集提前计算的，前面是RGB均值，后边是标准差</span></span><br><span class="line">    torchvision.transforms.Normalize([<span class="number">0.4914</span>, <span class="number">0.4822</span>, <span class="number">0.4465</span>],</span><br><span class="line">                                     [<span class="number">0.2023</span>, <span class="number">0.1994</span>, <span class="number">0.2010</span>])])</span><br><span class="line"><span class="comment"># 测试只执行标准化</span></span><br><span class="line">transform_test = torchvision.transforms.Compose([</span><br><span class="line">    torchvision.transforms.ToTensor(),</span><br><span class="line">    torchvision.transforms.Normalize([<span class="number">0.4914</span>, <span class="number">0.4822</span>, <span class="number">0.4465</span>],</span><br><span class="line">                                     [<span class="number">0.2023</span>, <span class="number">0.1994</span>, <span class="number">0.2010</span>])])</span><br></pre></td></tr></table></figure><h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><p>四个dataset列表：训练集，训练验证集，验证集，测试集</p><p>使用训练集和验证集组合而成的数据集（训练验证集）进行训练，充分利用所有标记的数据。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用列表推导式简洁地加载两个不同子目录的图像数据集，并应用同样的图像增强 transform_train</span></span><br><span class="line">train_ds, train_valid_ds = [torchvision.datasets.ImageFolder(</span><br><span class="line">    os.path.join(data_dir,<span class="string">&#x27;train_valid_test&#x27;</span>,folder),</span><br><span class="line">    transform=transform_train</span><br><span class="line">) <span class="keyword">for</span> folder <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>,<span class="string">&#x27;train_valid&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">valid_ds, test_ds = [torchvision.datasets.ImageFolder(</span><br><span class="line">    os.path.join(data_dir,<span class="string">&#x27;train_valid_test&#x27;</span>,folder),</span><br><span class="line">    transform=transform_test</span><br><span class="line">) <span class="keyword">for</span> folder <span class="keyword">in</span> [<span class="string">&#x27;valid&#x27;</span>,<span class="string">&#x27;test&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train_ds size:&quot;</span>, <span class="built_in">len</span>(train_ds))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train_valid_ds size:&quot;</span>, <span class="built_in">len</span>(train_valid_ds))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;valid_ds size:&quot;</span>, <span class="built_in">len</span>(valid_ds))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test_ds size:&quot;</span>, <span class="built_in">len</span>(test_ds))</span><br></pre></td></tr></table></figure><p>还需要将上面的数据集转换为可迭代的对象：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 DataLoader 创建了训练、验证、测试用的数据迭代器，分别控制是否打乱顺序、是否丢弃最后不足一批的数据</span></span><br><span class="line">train_iter, train_valid_iter = [torch.utils.data.DataLoader(</span><br><span class="line">    dataset, batch_size, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span></span><br><span class="line">) <span class="keyword">for</span> dataset <span class="keyword">in</span> (train_ds, train_valid_ds)]</span><br><span class="line"></span><br><span class="line">valid_iter = torch.utils.data.DataLoader(valid_ds, batch_size,shuffle=<span class="literal">False</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">test_iter = torch.utils.data.DataLoader(test_ds, batch_size, shuffle=<span class="literal">False</span>,drop_last=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><p>使用<code>Resnet-18</code>模型</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_net</span>():</span><br><span class="line">    <span class="comment"># 数据集一共有10个类别</span></span><br><span class="line">    num_classes = <span class="number">10</span></span><br><span class="line">    <span class="comment"># 3 指RGB 3个通道数</span></span><br><span class="line">    net = d2l.resnet18(num_classes, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"><span class="comment"># 交叉熵损失函数，none表示不自动求平均或求和，返回的是每个样本的loss</span></span><br><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&quot;none&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="定义训练函数"><a href="#定义训练函数" class="headerlink" title="定义训练函数"></a>定义训练函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">net,</span></span><br><span class="line"><span class="params">          train_iter,</span></span><br><span class="line"><span class="params">          valid_iter,</span></span><br><span class="line"><span class="params">          num_epochs,</span></span><br><span class="line"><span class="params">          lr,</span></span><br><span class="line"><span class="params">          wd,</span></span><br><span class="line"><span class="params">          devices,</span></span><br><span class="line"><span class="params">          lr_period,</span></span><br><span class="line"><span class="params">          lr_decay</span>):</span><br><span class="line">    <span class="comment"># 定义优化器：使用带动量的SGD优化器，包含学习率和权重衰减</span></span><br><span class="line">    trainer = torch.optim.SGD(net.parameters(), lr=lr, momentum=<span class="number">0.9</span>, weight_decay=wd)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 学习率调度器：每隔 lr_period 个 epoch，将学习率乘以 lr_decay</span></span><br><span class="line">    scheduler = torch.optim.lr_scheduler.StepLR(trainer, lr_period, lr_decay)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取训练集的批次数量，初始化计时器</span></span><br><span class="line">    num_batches, timer = <span class="built_in">len</span>(train_iter), d2l.Timer()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置绘图图例</span></span><br><span class="line">    legend = [<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;train acc&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> valid_iter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        legend.append(<span class="string">&#x27;valid acc&#x27;</span>)  <span class="comment"># 如果有验证集，则加上验证准确率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 动画器：用于可视化训练过程（损失和准确率）</span></span><br><span class="line">    animator = d2l.Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs], legend=legend)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用多GPU训练，将模型包装为 DataParallel 并移动到指定设备上</span></span><br><span class="line">    net = nn.DataParallel(net, device_ids=devices).to(devices[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        net.train()  <span class="comment"># 设置模型为训练模式</span></span><br><span class="line">        metric = d2l.Accumulator(<span class="number">3</span>)  <span class="comment"># 累加器：记录训练损失、训练准确率、样本数量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, (features, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_iter):</span><br><span class="line">            timer.start()  <span class="comment"># 开始计时</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 单个 batch 的训练，返回损失和准确率</span></span><br><span class="line">            l, acc = d2l.train_batch_ch13(net, features, labels, loss, trainer, devices)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 累加损失、准确率、样本数</span></span><br><span class="line">            metric.add(l, acc, labels.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">            timer.stop()  <span class="comment"># 停止计时</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 每训练 1/5 的 batch 或最后一个 batch 时更新图像</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span>) % (num_batches // <span class="number">5</span>) == <span class="number">0</span> <span class="keyword">or</span> i == num_batches - <span class="number">1</span>:</span><br><span class="line">                animator.add(epoch + (i+<span class="number">1</span>) / num_batches,</span><br><span class="line">                             (metric[<span class="number">0</span>] / metric[<span class="number">2</span>],  <span class="comment"># 平均训练损失</span></span><br><span class="line">                              metric[<span class="number">1</span>] / metric[<span class="number">2</span>],  <span class="comment"># 平均训练准确率</span></span><br><span class="line">                              <span class="literal">None</span>))  <span class="comment"># 暂时不更新验证准确率</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果有验证集，在每个 epoch 结束后评估验证准确率并可视化</span></span><br><span class="line">        <span class="keyword">if</span> valid_iter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            valid_acc = d2l.evaluate_accuracy_gpu(net, valid_iter)</span><br><span class="line">            animator.add(epoch + <span class="number">1</span>, (<span class="literal">None</span>, <span class="literal">None</span>, valid_acc))  <span class="comment"># 只更新验证准确率</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新学习率（根据学习率调度器）</span></span><br><span class="line">        scheduler.step()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印最终的训练指标</span></span><br><span class="line">    measures = (<span class="string">f&#x27;train loss <span class="subst">&#123;metric[<span class="number">0</span>] / metric[<span class="number">2</span>]:<span class="number">.3</span>f&#125;</span>, &#x27;</span></span><br><span class="line">                <span class="string">f&#x27;train acc <span class="subst">&#123;metric[<span class="number">1</span>] / metric[<span class="number">2</span>]:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> valid_iter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        measures += <span class="string">f&#x27;, valid acc <span class="subst">&#123;valid_acc:<span class="number">.3</span>f&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印训练速度和设备信息</span></span><br><span class="line">    <span class="built_in">print</span>(measures + <span class="string">f&#x27;\n<span class="subst">&#123;metric[<span class="number">2</span>] * num_epochs / timer.<span class="built_in">sum</span>():<span class="number">.1</span>f&#125;</span>&#x27;</span></span><br><span class="line">          <span class="string">f&#x27; examples/sec on <span class="subst">&#123;<span class="built_in">str</span>(devices)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="训练和验证模型"><a href="#训练和验证模型" class="headerlink" title="训练和验证模型"></a>训练和验证模型</h3><p>定义超参数和训练模型</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devices, num_epochs, lr, wd = d2l.try_all_gpus(), <span class="number">20</span>, <span class="number">2e-4</span>, <span class="number">5e-4</span></span><br><span class="line">lr_period, lr_decay, net = <span class="number">4</span>, <span class="number">0.9</span>, get_net()</span><br><span class="line">train(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,</span><br><span class="line">      lr_decay)</span><br></pre></td></tr></table></figure><h3 id="对测试集进行分类并生成结果"><a href="#对测试集进行分类并生成结果" class="headerlink" title="对测试集进行分类并生成结果"></a>对测试集进行分类并生成结果</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">net, preds = get_net(), []</span><br><span class="line">train(net, train_valid_iter, <span class="literal">None</span>, num_epochs, lr, wd, devices, lr_period,</span><br><span class="line">      lr_decay)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> X, _ <span class="keyword">in</span> test_iter:</span><br><span class="line">    y_hat = net(X.to(devices[<span class="number">0</span>]))</span><br><span class="line">    preds.extend(y_hat.argmax(dim=<span class="number">1</span>).<span class="built_in">type</span>(torch.int32).cpu().numpy())</span><br><span class="line">sorted_ids = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(test_ds) + <span class="number">1</span>))</span><br><span class="line">sorted_ids.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">str</span>(x))</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;id&#x27;</span>: sorted_ids, <span class="string">&#x27;label&#x27;</span>: preds&#125;)</span><br><span class="line">df[<span class="string">&#x27;label&#x27;</span>] = df[<span class="string">&#x27;label&#x27;</span>].apply(<span class="keyword">lambda</span> x: train_valid_ds.classes[x])</span><br><span class="line">df.to_csv(<span class="string">&#x27;submission.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>生成的<code>submission.csv</code>就可以提交到Kaggle上了。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>antfu的薅牛毛地图的自用方法</title>
      <link href="/2025/07/14/antfu%E7%9A%84%E8%96%85%E7%89%9B%E6%AF%9B%E5%9C%B0%E5%9B%BE%E7%9A%84%E8%87%AA%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2025/07/14/antfu%E7%9A%84%E8%96%85%E7%89%9B%E6%AF%9B%E5%9C%B0%E5%9B%BE%E7%9A%84%E8%87%AA%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="antfu的薅牛毛地图的自用方法"><a href="#antfu的薅牛毛地图的自用方法" class="headerlink" title="antfu的薅牛毛地图的自用方法"></a>antfu的薅牛毛地图的自用方法</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>去年看了Anthony Fu的“薅牛毛”演讲，当时看到ppt里密集的路线图着实是被视觉冲击了。将复杂的学习路线通过路线图一个个表示出来，最后整体去俯瞰，竟有一种宏伟的成就感。</p><p>什么是薅牛毛呢？在我的现状下，在学习新东西或者完成任务的时候，难免会有一些“前置知识”需要去了解，然后要理解“前置知识”的话，还需要学习一下“前置知识”的“前置知识”。这可能会变成一种dfs或者bfs，越学越多，越学越远，可能有一天发现自己在草原上薅牛毛，而一开始的目标和薅牛毛没有一点点关联。</p><p>最近正在学习图像识别的内容，最主要的目标就是学会使用YOLOv5。当然仅仅是使用的话很简单，我需要的是了解其中的原理并使用它。也因此我的“薅牛毛”之旅开始了。</p><h2 id="制作方法"><a href="#制作方法" class="headerlink" title="制作方法"></a>制作方法</h2><h3 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h3><p>我们可以先fork一下Anthony Fu的<a href="https://github.com/antfu/yak-shaving-map">仓库代码</a>。</p><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p>然后将自己仓库的代码下载到本地，先安装环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果本地没有pnpm要先下载pnpm，什么？连npm都没有？</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">那可以“薅牛毛”了😂</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm install -g pnpm</span></span><br><span class="line">pnpm install</span><br></pre></td></tr></table></figure><p>运行代码只需要运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm run dev</span><br></pre></td></tr></table></figure></p><h3 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h3><p>其中<code>data.ts</code>中存储的是节点的上下级关系以及节点形状，我们可以删除原来的节点，填写自己想要的节点。</p><p><code>yak-map-pos.json</code>里边是节点的坐标，这个文件不需要手动更改，运行项目后使用鼠标可以拖动节点位置，会自动添加当前节点到json中，json中的节点坐标会自动变化。<strong>建议先把这里面的所有节点删除再添加编写<code>data.ts</code>。</strong></p><p>其中节点类似下面代码：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;YOLOv4&#x27;</span>,</span><br><span class="line">  <span class="attr">display</span>: <span class="string">&#x27;YOLOv4&#x27;</span>,</span><br><span class="line">  <span class="attr">link</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">shape</span>: <span class="string">&#x27;circle&#x27;</span>,</span><br><span class="line">  <span class="attr">color</span>: colors.<span class="property">YOLOv4</span>,</span><br><span class="line">  <span class="attr">from</span>: [<span class="string">&#x27;yolov5&#x27;</span>],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;CSPDarknet53&#x27;</span>,</span><br><span class="line">  <span class="attr">display</span>: <span class="string">&#x27;CSPDarknet53&#x27;</span>,</span><br><span class="line">  <span class="attr">link</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">color</span>: colors.<span class="property">YOLOv4</span>,</span><br><span class="line">  <span class="attr">from</span>: [<span class="string">&#x27;YOLOv4&#x27;</span>],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>注意第一个节点要自定义<code>x</code>和<code>y</code>为0。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>运行后我们打开网页，界面右上角可以调节暗夜模式，鼠标点击左侧空白是回退，鼠标点击右侧空白是前进，右下角按钮可以进入step模式和展示全部。</p><p>这里附上我制作完成后的页面截图：</p><p><img src="https://images.whff521.top/Screenshot%202025-07-14%20at%2019.41.23.png" alt="yolo map"></p><p>我部署到了Cloudflare的pages上了，方便随时查看。这里附上<a href="https://github.com/WHFF521/yak-shaving-map-yolo">我仓库的链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yolo </tag>
            
            <tag> 路线图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch和cuda环境安装</title>
      <link href="/2025/07/05/Pytorch%E5%92%8Ccuda%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2025/07/05/Pytorch%E5%92%8Ccuda%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Pytorch和cuda环境安装"><a href="#Pytorch和cuda环境安装" class="headerlink" title="Pytorch和cuda环境安装"></a>Pytorch和cuda环境安装</h1><p>为了避免更换不同版本Cuda的麻烦，环境在Anaconda里面搭建。</p><h2 id="创建conda环境"><a href="#创建conda环境" class="headerlink" title="创建conda环境"></a>创建conda环境</h2><p>Anaconda的安装就不赘述，首先是创建一个虚拟环境：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name your-env-name python=3.13</span><br></pre></td></tr></table></figure><br><code>your-env-name</code>是环境名称，随意更换，python版本也可根据不同环境进行更改。这里要注意<code>--name</code>是两个<code>-</code>，如果只打一个<code>-</code>你有概率会获得一个名字叫<code>ame</code>的虚拟环境😂</p><p>千万不要忘了进入虚拟环境再进行下面的操作：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate your-env-name</span><br></pre></td></tr></table></figure></p><h2 id="安装Cuda"><a href="#安装Cuda" class="headerlink" title="安装Cuda"></a>安装Cuda</h2><p>这里有两种方法，第一是用conda命令进行安装，源应该是conda仓库。第二种是通过pip，源是pip的仓库。其中conda安装的命令虽然更简单，但是conda仓库里Cuda版本十分有限，所以如果conda仓库里如果没有自己想要的版本还是推荐用pip进行安装。</p><h3 id="通过conda安装"><a href="#通过conda安装" class="headerlink" title="通过conda安装"></a>通过conda安装</h3><p>可以通过以下命令查看conda仓库中有哪些版本的Cuda：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search cudatoolkit --info</span><br></pre></td></tr></table></figure><br>通过conda安装Cuda的命令为：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install cudatoolkit=11.7</span><br></pre></td></tr></table></figure></p><h3 id="通过pip安装"><a href="#通过pip安装" class="headerlink" title="通过pip安装"></a>通过pip安装</h3><p><a href="https://docs.nvidia.com/cuda/cuda-quick-start-guide/index.html#pip-wheels-windows">NVIDIA 官网</a>提供了通过pip安装的方法。</p><p>安装命令如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新pip</span></span><br><span class="line">py -m pip install --upgrade setuptools pip wheel</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装nvidia-pyindex</span></span><br><span class="line">py -m pip install nvidia-pyindex</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装cuda12</span></span><br><span class="line">py -m pip install nvidia-cuda-runtime-cu12</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选 安装其他模块</span></span><br><span class="line">py -m pip install nvidia-&lt;library&gt;</span><br></pre></td></tr></table></figure><br>其中<code>py</code>需要替换成<code>python</code>。</p><h2 id="安装Pytorch"><a href="#安装Pytorch" class="headerlink" title="安装Pytorch"></a>安装Pytorch</h2><p><a href="https://pytorch.org/get-started/locally/">Pytorch 官网</a>提供了对应的安装命令<br><img src="https://images.whff521.top/Screenshot%202025-07-05%20at%2010.35.01.png" alt="安装命令"></p><p>这里贴出我使用的：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118</span><br></pre></td></tr></table></figure></p><h2 id="检验安装"><a href="#检验安装" class="headerlink" title="检验安装"></a>检验安装</h2><p>直接在命令行中输入<code>python</code>进入到python，输入以下几行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.version.cuda)</span><br><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure><p>注意import之后会有一段时间等待python加载。</p><p>PS：今天也是我第一次用anaconda进行搭建这个环境，仅仅是搭建还未投入到代码的使用，可能会有问题。</p><p>PS2：封面是大空スバル，两天前是她的生日！しゅばしゅばしゅば！！！ </p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
            <tag> Cuda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Adjacent Digit Sums</title>
      <link href="/2025/02/13/Codeforces-Adjacent-Digit-Sums/"/>
      <url>/2025/02/13/Codeforces-Adjacent-Digit-Sums/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Adjacent-Digit-Sums"><a href="#Codeforces-Adjacent-Digit-Sums" class="headerlink" title="Codeforces Adjacent Digit Sums"></a>Codeforces Adjacent Digit Sums</h1><p>这是<code>Codeforces Round 1004(Div.2)</code>的第一题，<a href="https://codeforces.com/contest/2067/problem/A#">题目链接</a>。</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>题目给出了两个数 𝑥 和 𝑦，要求判断是否存在一个整数 𝑛，使得 𝑛 的各位数字之和等于 𝑥，且 𝑛+1 的各位数字之和等于 𝑦。</p><p>S(n) = x, S(n+1) = y</p><p>换句话说，你需要找到一个整数 𝑛，使得：</p><ol><li>𝑛 的各位数字相加等于 𝑥。</li><li>𝑛+1 的各位数字相加等于 𝑦。</li></ol><p>如果存在这样的 𝑛，输出“YES”；否则输出“NO”。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ol><li>对于n的个位数字不是9的，<code>S(n+1) = S(n) + 1</code>;</li><li>对于 n 的个位数字是 9 的，假设从个位开始有连续的 k 个 9，那么<code>S(n+1) = S(n) + 1 - k*9</code>,因为从个位开始加上 1 后连续的 k 个 9 都会变成0，最后的进1贡献为1。</li></ol><p>归纳如果 k = 0 即为情况1。</p><p>将 x 和 y 替换到等式里, y = x + 1 - k*9, k = (x-y+1)/9。</p><p>只需判断k是否为大于等于0的整数即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="type">int</span> remainder = (x-y+<span class="number">1</span>)%<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span>(remainder==<span class="number">0</span>&amp;&amp;(x-y+<span class="number">1</span>)/<span class="number">9</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>曾经最想去的地方是现在最讨厌的地方</title>
      <link href="/2025/01/26/%E6%9B%BE%E7%BB%8F%E6%9C%80%E6%83%B3%E5%8E%BB%E7%9A%84%E5%9C%B0%E6%96%B9%E6%98%AF%E7%8E%B0%E5%9C%A8%E6%9C%80%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
      <url>/2025/01/26/%E6%9B%BE%E7%BB%8F%E6%9C%80%E6%83%B3%E5%8E%BB%E7%9A%84%E5%9C%B0%E6%96%B9%E6%98%AF%E7%8E%B0%E5%9C%A8%E6%9C%80%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="曾经最想去的地方是现在最讨厌的地方"><a href="#曾经最想去的地方是现在最讨厌的地方" class="headerlink" title="曾经最想去的地方是现在最讨厌的地方"></a>曾经最想去的地方是现在最讨厌的地方</h1><p>最近在看《灿烂的风和海》，是在澳门拍摄的电视剧。其中Casey姐对8岁的韦世杰说：“小时候最想去的地方但是因为各种原因没有去成，长大后那些地方就变成最讨厌去的地方。因为会一直暗示自己没有去是因为自己不喜欢，不想去。久而久之连自己都相信了。”</p><p>我非常懂Casey姐说的话，有些地方小时候没有去成，有些东西小时候没有得到。即使长大了，有能力去了，有能力获得了，却极力避免去，避免获得。甚至不想再看一眼。这并不是自相矛盾，而是人类自身自我保护的潜意识。</p><p>小时候最想要的玩具，明明当初那么想要，但是父母没有给买。长大了，你会体谅父母的不容易，感叹小时候的幼稚。好不容易已经忘记了，不在意了，但是在商场里那个玩具就是再一次跑到你的视线里，那一瞬间，记忆的闸门终于抵挡不住记忆的洪流，你看见了当初哭泣的指着这个玩具求父母买给我的自己。大多数人可能就会撇开视线走掉吧。</p><p>我们不得不承认这就是心灵上的伤疤，谁都不想揭开这个伤疤，因为我们的心会痛，即使知道当初是多么的幼稚，但是当初撕心裂肺的心情撕开的伤疤永远得不到治疗，只要一提起还是会刺痛。</p><p>为什么伤口没有愈合呢？时间为什么解决不了这件事情呢？我觉得是因为你自己没有放过自己。在别人眼里可能就是芝麻大的小事，因为他们并不在乎。但是在当初我们自己眼里，这就是天大的事情，因为我们在乎。</p><p>我很欣赏一句诗：“欲买桂花同载酒，终不似，少年游。”想要买上桂花和美酒一同泛舟，但终究不像少年出游时拥有那种意气了。我们应该尽量避免这种情况的发生。如果我们成天感叹过去的遗憾，一定会忽略当下的美好，只会造成更大的遗憾。</p><p>我们要随时清楚地知道自己想要什么东西。学会饶恕自己，放过自己。小时候没钱学的钢琴长大后也是可以学的，小时候没去的郊游长大后也是可以去的，虽然“终不似少年游”，虽然以前的朋友已经不在身边，但是这片风景一直没有变，它连同小时候的自己一直都在等着你，你要自己踏足此地，和小时候的自己和解，证明自己值得。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg提取视频音频</title>
      <link href="/2025/01/21/FFmpeg%E6%8F%90%E5%8F%96%E8%A7%86%E9%A2%91%E9%9F%B3%E9%A2%91/"/>
      <url>/2025/01/21/FFmpeg%E6%8F%90%E5%8F%96%E8%A7%86%E9%A2%91%E9%9F%B3%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<h1 id="FFmpeg提取视频音频"><a href="#FFmpeg提取视频音频" class="headerlink" title="FFmpeg提取视频音频"></a>FFmpeg提取视频音频</h1><h2 id="背景故事"><a href="#背景故事" class="headerlink" title="背景故事"></a>背景故事</h2><p>最近在补夏目友人帐的第七季，前几季都是初中时候看的了得有快十年没看了，所以周更的时候没有跟着追。现在有时间了都下载下来一集一集看。</p><p>我发现夏目的语速非常慢，而且发音很标准，毕竟声优是神谷浩史，很有辨识度。重要的是里边用到的词汇也都非常基础，有很多日常生活中的常用词。最近我也在学新版的标日初级上下册，所以对一些基础词汇非常的敏感。</p><p>今天在去超市的路上本来想听一听播客，但是有很多还没有更新，有的更新也是不太想听，感觉营养较低。前几个月我是有搜寻一些日语播客的，想要练一练听力，但是完全听不懂就放弃了。</p><p>所以我联想到了我刚看的两集夏目，这个番非常适合练习听力，而且看过一遍字幕不用担心完全听不懂的现象，而且有有趣的对话和悠扬的背景音乐。</p><p><img src="https://images.whff521.top/vlcsnap-2025-01-21-23h20m21s316.png" alt="xiamu"></p><p><strong>如果能把视频的音频提取出来传到手机上听就好了。</strong></p><p>所以就有了这篇博客。</p><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><h3 id="安装-FFmpeg"><a href="#安装-FFmpeg" class="headerlink" title="安装 FFmpeg"></a>安装 FFmpeg</h3><ol><li>下载并安装 FFmpeg：<a href="https://ffmpeg.org/download.html">FFmpeg 官网</a></li><li>配置环境变量（Windows 用户需要手动添加到 PATH，MacOS直接homebrew下载即可）。</li></ol><h3 id="提取音频命令"><a href="#提取音频命令" class="headerlink" title="提取音频命令"></a>提取音频命令</h3><p>假设你的文件是 <code>input.mp4</code>，目标音频文件格式是 MP3：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -q:a 0 -map a output.mp3</span><br></pre></td></tr></table></figure><ul><li><code>-q:a 0</code> 表示使用最高质量。</li><li><code>-map a</code> 表示仅提取音频流。</li></ul><h2 id="手机端"><a href="#手机端" class="headerlink" title="手机端"></a>手机端</h2><p>不想重复造轮子，我自己的方法是直接电脑上传到apple music资料库，等上传后手机就可以听了。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南游记</title>
      <link href="/2025/01/19/%E5%8D%97%E6%B8%B8%E8%AE%B0/"/>
      <url>/2025/01/19/%E5%8D%97%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="南游记"><a href="#南游记" class="headerlink" title="南游记"></a>南游记</h1><h2 id="规模"><a href="#规模" class="headerlink" title="规模"></a>规模</h2><p>我本来以为这次聚会只有6，7个人的规模，等我到了之后没想到竟然有12人之多。偌大的客厅在人群面前也显现出有些狭小。大多是好久没有见过的高中同学，最长的甚至长达四年，除了某个人胖了好多意以外，其他人外貌基本没有太大的变化。</p><p>第二天的时候人数减到十人，正好配上两辆车，直接扩大了可以游玩的区域范围。</p><h2 id="夜爬"><a href="#夜爬" class="headerlink" title="夜爬"></a>夜爬</h2><p>同市区内就有某山公园，玩了一下午狼人杀，吃过晚饭之后就来夜爬。山不是很高，但是公园面积很大。由于夜晚没有太阳，绕来绕去甚至迷失了一段时间的方向。冬天的半夜气温较冷，虽说穿着羽绒服但是很冻耳朵。半夜的公园里似乎就没看见过其他市民，整个公园都是我们的地盘一样。</p><p>站在山顶的高台上俯瞰市区，照了一会儿合影就慢慢下去了。对于我来说并不是很累，但是有些人似乎有些恐高所以走的比较慢。</p><h2 id="大海"><a href="#大海" class="headerlink" title="大海"></a>大海</h2><p>第二天下午直接开车去看大海。高速路开的也算是很顺畅（我是坐车的）。除了去的时候下高速转弯的时候突然警报后备箱开了，和回来的时候开暖风有一股糊味之外也没什么意外的事情。</p><p>一开始本来是按照导航走的，但是由于聊天太欢导致忘了变右转向道，所以两个车分开了一段时间，不过这次意外似乎是个正确的选择，虽然走错了道路，但是我们后来因为走的道路车少超过了另外一辆车提前到达去高速路的主路上。</p><p>只有岸边水坑里结了一点冰，岸边不知道是不是剧组有一群人立着摄像机在拍摄。</p><p>虽说没有什么游乐项目，只是为了看大海而看大海，但是这是一段很快乐的时光。在路上的聊天，两辆车的位置共享和语音通话，车载音响的歌唱，和朋友们吹着海风大声欢笑才是最重要的事情。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>也没有走多远，只是因为我一直在向南边走而将此游记命名为“南游记”。两天两夜，甚至没有花多少钱，却享受了十分快乐的时光。</p><p>是的，这是值得纪念的时光。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅行 </tag>
            
            <tag> 朋友 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>switch连接openwrt路由器NAT穿越失败问题</title>
      <link href="/2025/01/05/switch%E8%BF%9E%E6%8E%A5openwrt%E8%B7%AF%E7%94%B1%E5%99%A8NAT%E7%A9%BF%E8%B6%8A%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2025/01/05/switch%E8%BF%9E%E6%8E%A5openwrt%E8%B7%AF%E7%94%B1%E5%99%A8NAT%E7%A9%BF%E8%B6%8A%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="switch连接openwrt路由器NAT穿越失败问题"><a href="#switch连接openwrt路由器NAT穿越失败问题" class="headerlink" title="switch连接openwrt路由器NAT穿越失败问题"></a>switch连接openwrt路由器NAT穿越失败问题</h1><p>首先说结论，解决问题的办法是<code>ShadowSocksR Plus+</code>需要代理的端口要改成“所有端口”。</p><h2 id="问题的来源"><a href="#问题的来源" class="headerlink" title="问题的来源"></a>问题的来源</h2><p>我需要路由器给我的switch（任天堂游戏机）做代理，我家里的老路由器NAT类型是B，虽然能匹配到马车8，但是感觉延迟很大，而且大乱斗的竞猜观也看不了。正好我有一个刷过openwrt（QWRT）的路由器。</p><h2 id="试错"><a href="#试错" class="headerlink" title="试错"></a>试错</h2><p>我第一个想法是有线桥接。lan to lan 这样接起来，然后让主路由器分配ip，副路由器只负责当交换机。</p><p>但是不知道为什么网上的桥接教程我都不能成功实现。他们教的把副路由器lan口ip改成主路由器lan口ip统一网段的这一步，每当我改完ip然后路由器就失联了，也没有网。</p><p>好在我直接拔电源再插回去，路由器的系统会重置为出厂化设置。研究了几个小时之后我发现路由器并不是失联了，而是我没有正确的访问。我不知道原因是什么，我电脑网线连接路由器之所以找不到路由器配置网址，好像是因为改lan口ip后新的网络ip并没有分配给电脑，然后电脑和路由器panel在不同的网段里，所以不能访问。</p><p>解决办法就是在电脑控制面板里找到适配器设置（Control Panel-&gt;All Control Panel Items-&gt;Network and Sharing Center-&gt;Change adapter settings），将以太网属性里的ipv4设置为手动ip，设置为和更改panel的ip的同一网段的不同ip上。</p><p><img src="https://images.whff521.top/69968835425934D848C83A3278D54FF2.png" alt="ipv4"></p><p>如图，假设主路由器Default Gateway是192.168.3.1，这个如果不知道就用电脑连接主路由器，然后Terminal里输入<code>ipconfig /all</code>查看。然后路由器lan设置为192.168.3.2,只需要上图一样配置，将自己电脑ip改为同一网段的不同ip即可。然后再输入192.168.3.2就能够再次访问到路由器panel。</p><p>这里解释一下为什么192.168.1.1和192.168.3.1是不同网段，主要是因为家庭路由器的子网掩码是255.255.255.0。这里涉及到计网的知识。这个子网掩码应该按照二进制的思维思考，前面都是111111…后面是0,然后第三个字段的3和1仍然还是不同网段，但是第四个字段对应的0属于同一网段。</p><h2 id="可能是正解"><a href="#可能是正解" class="headerlink" title="可能是正解"></a>可能是正解</h2><p>重置路由器后，网线插在wan口上，wan口协议设置为DHCP服务端即可。这样副路由器就应该有网了。</p><p>当然这样的做法使得主副路由器会在不同的网段中，共享打印机那种场景应该会出问题，但是我并没有这种场景。</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>我为什么排除了vpn的问题而是一心觉得是因为不同网段的问题。第一因为这个路由器在学校的时候运作十分正常，第二chatgpt告诉我可能是因为双重NAT导致的。显然我的决策是有误的。</p><p>因为开梯子和不开梯子NAT类型都是B，而且开梯子后反而完不了马车8了让我心急如焚。我不知道为什么<code>ShadowSocksR Plus+</code>的代理端口为什么被改成了“不代理p2p流量”，这一个设置让我折腾了快一天的时间：</p><p><img src="https://images.whff521.top/Screenshot%202025-01-05%20at%2008.58.42.png" alt="search history"></p><p>这是部分搜索截图。</p><p>最后看到NAT类型变成A，然后狠狠打了几把NS Sports，还是很开心的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot中jwt的使用</title>
      <link href="/2024/12/29/springboot%E4%B8%ADjwt%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/12/29/springboot%E4%B8%ADjwt%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot中jwt的使用"><a href="#Spring-Boot中jwt的使用" class="headerlink" title="Spring Boot中jwt的使用"></a>Spring Boot中jwt的使用</h1><p>记录一下现在我是怎么实现jwt的。为什么说是现在呢？说实话这是我第三次在Spring Boot里添加JWT，但是每次添加的方式和代码因为查阅的资料不同，实现的方式也不太一样。当然jwt终究是jwt，大同小异。</p><p>我用的版本比较新，所以很多方法都被标注了过期，我也没有去深入研究最新的代码究竟应该怎么实现。</p><p>Spring Boot版本是3.3.5， jjwt用的0.12.6。</p><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>用的是<code>jjwt</code>实现jwt，<code>spring-security</code>实现拦截。</p><p>在pom.xml里添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JwtUtil-文件"><a href="#JwtUtil-文件" class="headerlink" title="JwtUtil 文件"></a>JwtUtil 文件</h2><p>这是为了实现<code>jwt</code>而创建的工具类，建议放在项目文件夹的<code>utils</code>文件夹里，和<code>controller</code>文件夹同级。代码中的<code>jwt.secret</code>,<code>jwt.expiration</code>是写在<code>application.properties</code>里的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jwt.secret=XXXXXXXXXXXXX</span><br><span class="line">jwt.expiration=604800000</span><br></pre></td></tr></table></figure><p>这里的<code>jwt.secret</code>必须满足一定的要求：HS256 算法要求签名密钥的大小至少为 256 位（即 32 字节）。并且写在文件里的是用Base64加密过的。Base64 编码的目的是让二进制密钥在传输和存储时更加安全和兼容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.airomance.easytravelroute.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.security.Keys;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.secret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.expiration&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> expirationTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SecretKey <span class="title function_">getSecretKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] decodedKey = Base64.getDecoder().decode(secretKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(decodedKey, <span class="number">0</span>, decodedKey.length, <span class="string">&quot;HmacSHA256&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateToken</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setSubject(username)</span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expirationTime))</span><br><span class="line">                .signWith(getSecretKey())</span><br><span class="line">                .compact();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从JWT中获取用户名</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">extractUsername</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> extractClaim(token, Claims::getSubject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从JWT中获取任何信息</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; T <span class="title function_">extractClaim</span><span class="params">(String token, ClaimsResolver&lt;T&gt; claimsResolver)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> extractAllClaims(token);</span><br><span class="line">        <span class="keyword">return</span> claimsResolver.resolve(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从JWT中提取所有声明</span></span><br><span class="line">    <span class="keyword">private</span> Claims <span class="title function_">extractAllClaims</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(getSecretKey())</span><br><span class="line">                .build()</span><br><span class="line">                .parseSignedClaims(token)</span><br><span class="line">                .getPayload();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证JWT</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateToken</span><span class="params">(String token, String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (username.equals(extractUsername(token)) &amp;&amp; !isTokenExpired(token));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查JWT是否过期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isTokenExpired</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> extractExpiration(token).before(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取JWT过期时间</span></span><br><span class="line">    <span class="keyword">private</span> Date <span class="title function_">extractExpiration</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> extractClaim(token, Claims::getExpiration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">interface</span> <span class="title class_">ClaimsResolver</span>&lt;T&gt; &#123;</span><br><span class="line">        T <span class="title function_">resolve</span><span class="params">(Claims claims)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JwtAuthenticationFilter-文件"><a href="#JwtAuthenticationFilter-文件" class="headerlink" title="JwtAuthenticationFilter 文件"></a>JwtAuthenticationFilter 文件</h2><p>JWT 认证过滤器 (JwtAuthenticationFilter)，用于在每次 HTTP 请求时检查 JWT（JSON Web Token）是否有效，并在验证成功后设置用户身份认证信息。它是基于 Spring Security 的 OncePerRequestFilter 类，用于确保每个请求只被过滤一次。</p><ul><li>检查请求中的 JWT Token。</li><li>验证 Token 的有效性和格式。</li><li>如果 Token 有效，将用户信息设置到 Spring Security 的上下文中。</li><li>如果请求在白名单路径中，则跳过 JWT 检查。</li><li>如果 Token 无效或缺失，返回 HTTP 401 Unauthorized 错误。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.airomance.easytravelroute.filter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.airomance.easytravelroute.utils.JwtUtil;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.JwtException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.OncePerRequestFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtUtil jwtUtil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(JwtAuthenticationFilter.class.getName());</span><br><span class="line">    <span class="comment">// 白名单路径列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] WHITE_LIST_PATHS = &#123;<span class="string">&quot;/users/loginByEmail&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JwtAuthenticationFilter</span><span class="params">(JwtUtil jwtUtil)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jwtUtil = jwtUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果请求是白名单路径，跳过 JWT 校验</span></span><br><span class="line">        <span class="keyword">if</span> (isWhiteListed(request)) &#123;</span><br><span class="line">            filterChain.doFilter(request, response);  <span class="comment">// 直接继续请求链，不做认证</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> getJwtFromRequest(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 token 不为空且有效，进行身份认证</span></span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (jwtUtil.validateToken(token, jwtUtil.extractUsername(token))) &#123;</span><br><span class="line">                    <span class="comment">// 如果 JWT 有效，设置身份认证</span></span><br><span class="line">                    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span></span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(jwtUtil.extractUsername(token), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Token 无效，返回 401 错误</span></span><br><span class="line">                    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">                    response.getWriter().write(<span class="string">&quot;Invalid or expired JWT token&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">                <span class="comment">// 捕获解析异常，返回 401 错误</span></span><br><span class="line">                logger.log(Level.SEVERE, <span class="string">&quot;Your error message here&quot;</span>, e);</span><br><span class="line">                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">                response.getWriter().write(<span class="string">&quot;Invalid JWT token format&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Token 缺失，返回 401 错误</span></span><br><span class="line">            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;JWT token is missing&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续过滤链</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从请求头部获取JWT Token</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getJwtFromRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">bearerToken</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (bearerToken != <span class="literal">null</span> &amp;&amp; bearerToken.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bearerToken.substring(<span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断请求路径是否在白名单中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isWhiteListed</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="keyword">for</span> (String path : WHITE_LIST_PATHS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestURI.equals(path)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="SecurityConfig文件"><a href="#SecurityConfig文件" class="headerlink" title="SecurityConfig文件"></a>SecurityConfig文件</h2><p>Spring Security 的配置类，用于定义应用的安全策略，包括认证机制、过滤器链、密码加密方式等。它通过 SecurityFilterChain 自定义安全规则，并使用 JwtAuthenticationFilter 来实现基于 JWT 的认证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.airomance.easytravelroute.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.airomance.easytravelroute.filter.JwtAuthenticationFilter;</span><br><span class="line"><span class="keyword">import</span> com.airomance.easytravelroute.utils.JwtUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.SecurityFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtUtil jwtUtil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecurityConfig</span><span class="params">(JwtUtil jwtUtil)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jwtUtil = jwtUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 添加自定义的 JwtAuthenticationFilter</span></span><br><span class="line">        http.addFilterBefore(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationFilter</span>(jwtUtil), UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .authorizeRequests(authorizeRequests -&gt; authorizeRequests</span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/users/loginByEmail&quot;</span>).permitAll() <span class="comment">// 登录和注册不需要认证</span></span><br><span class="line">                        .anyRequest().authenticated() <span class="comment">// 其他请求需要认证</span></span><br><span class="line">                )</span><br><span class="line">                .csrf(csrf -&gt; csrf.disable()); <span class="comment">// 禁用 CSRF</span></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缺点和不足"><a href="#缺点和不足" class="headerlink" title="缺点和不足"></a>缺点和不足</h2><p>现在可以看到白名单需要在两个文件里都写一遍，原因是我想要在需要token的时候如果没有tokne的请求返回”JWT token is missing”，但是我发现<code>JwtAuthenticationFilter</code>如果不加入白名单判断，就会把所有没有token的都拦截了。</p><p>而且没有暂时没有加入角色控制，因为相关接口还没有写。</p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业设计 </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-Plus的使用</title>
      <link href="/2024/12/26/MyBatis-Plus%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/12/26/MyBatis-Plus%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis-Plus的使用"><a href="#MyBatis-Plus的使用" class="headerlink" title="MyBatis-Plus的使用"></a>MyBatis-Plus的使用</h1><p>数据库基本设计完毕，创建完数据库后就需要让后端连接数据库。在这里用<code>MyBatis-Plus</code>的代码生成器能快速生成<code>entity</code>,<code>mapper</code>,<code>service</code>等文件。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="第一步，添加依赖"><a href="#第一步，添加依赖" class="headerlink" title="第一步，添加依赖"></a>第一步，添加依赖</h3><p>在<code>pom.xml</code>文件中的<code>dependencies</code>里添加如下几行代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-spring-boot3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.freemarker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在我用的是最新的版本，如有问题请去<a href="https://baomidou.com/">官网</a>查看是否有更新。其中<code>freemarker</code>是我要使用的模版引擎。</p><h3 id="第二步-后端连接数据库"><a href="#第二步-后端连接数据库" class="headerlink" title="第二步 后端连接数据库"></a>第二步 后端连接数据库</h3><p>在<code>application.properties</code>下写明你要连接的数据库的详细信息，我用的是<code>mysql5.7</code>。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/&quot;yourDatabaseName&quot;</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">&quot;yourSqlUsername(maybe root)&quot;</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">&quot;yourSqlPassword&quot;</span></span><br><span class="line"><span class="attr">mybatis-plus.mapper-locations</span>=<span class="string">classpath:xml/*.xml</span></span><br><span class="line"><span class="attr">mybatis-plus.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p>请将双引号的地方换上你自己要使用的。其中最后一句话是为了之后在终端打印出代码执行的sql语句。</p><h3 id="第三步-编写代码生成器代码"><a href="#第三步-编写代码生成器代码" class="headerlink" title="第三步 编写代码生成器代码"></a>第三步 编写代码生成器代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.airomance.easytravelroute;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.FastAutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tables</span> <span class="operator">=</span> <span class="string">&quot;users,roles,xxx,xxx&quot;</span>;</span><br><span class="line">        FastAutoGenerator.create(<span class="string">&quot;jdbc:mysql://localhost:3306/yourDatabaseName&quot;</span>,<span class="string">&quot;username&quot;</span>,<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .globalConfig(builder -&gt; builder</span><br><span class="line">                        .author(<span class="string">&quot;airomance&quot;</span>)</span><br><span class="line">                        .outputDir(Paths.get(System.getProperty(<span class="string">&quot;user.dir&quot;</span>))+<span class="string">&quot;/src/main/java&quot;</span>)</span><br><span class="line">                        .commentDate(<span class="string">&quot;yyyy-MM-dd&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                .packageConfig(builder -&gt; builder</span><br><span class="line">                        .parent(<span class="string">&quot;com.airomance.easytravelroute&quot;</span>)</span><br><span class="line">                        .entity(<span class="string">&quot;entity&quot;</span>)</span><br><span class="line">                        .mapper(<span class="string">&quot;mapper&quot;</span>)</span><br><span class="line">                        .service(<span class="string">&quot;service&quot;</span>)</span><br><span class="line">                        .serviceImpl(<span class="string">&quot;service.impl&quot;</span>)</span><br><span class="line">                        .xml(<span class="string">&quot;mapper.xml&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                .strategyConfig(builder -&gt; builder</span><br><span class="line">                        .addInclude(tables.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">                        .entityBuilder()</span><br><span class="line">                        .enableLombok()</span><br><span class="line">                        .enableFileOverride()</span><br><span class="line">                        .controllerBuilder()</span><br><span class="line">                        .enableRestStyle()</span><br><span class="line">                )</span><br><span class="line">                .templateEngine(<span class="keyword">new</span> <span class="title class_">FreemarkerTemplateEngine</span>())</span><br><span class="line">                .execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请将数据库涉及的数据库名称，用户名，密码换成自己的。还有包名。</p><h3 id="第四步-运行代码生成器"><a href="#第四步-运行代码生成器" class="headerlink" title="第四步 运行代码生成器"></a>第四步 运行代码生成器</h3><p>运行代码后应该会自动创建出<code>entity</code>,<code>mapper</code>,<code>service</code>，<code>controller</code>层等文件。这时需要把mapper文件夹下的xml文件夹移动到项目的<code>resources</code>文件夹下，这样方便配置也是一般的使用习惯。</p><p>注意，这里xml必须移动，原因在第二步已经设置了xml文件夹的路径，就是这句配置：</p><p><code>mybatis-plus.mapper-locations=classpath:xml/*.xml</code></p><h3 id="第五步-设置mapper路径"><a href="#第五步-设置mapper路径" class="headerlink" title="第五步 设置mapper路径"></a>第五步 设置mapper路径</h3><p>我们需要将mapper文件夹的路径告诉Spring boot，在启动项目的<code>application</code>文件下添加一个注解。</p><p><code>@MapperScan(&quot;com.airomance.easytravelroute.mapper&quot;)</code></p><p>添加后这个文件代码应该是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.airomance.easytravelroute;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.airomance.easytravelroute.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyTravelRouteApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(EasyTravelRouteApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>至此应该能够正常运行项目，然后进行接口的详细编写了。</p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研回忆</title>
      <link href="/2024/12/25/%E8%80%83%E7%A0%94%E5%9B%9E%E5%BF%86/"/>
      <url>/2024/12/25/%E8%80%83%E7%A0%94%E5%9B%9E%E5%BF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="考研回忆"><a href="#考研回忆" class="headerlink" title="考研回忆"></a>考研回忆</h1><h2 id="最近几天"><a href="#最近几天" class="headerlink" title="最近几天"></a>最近几天</h2><p>说说考试吧，政治肖四复习的时候也没有安排时间背诵答题，只是简单的看了几天。没想到政治题今年出的很难，而且肖四也是没压到题，这么看来我的时间安排还算合理。为了增强我自己内心的激情和逻辑思维能力，每天都在看《觉醒年代》，这个电视剧拍的是真的好，不过在此就不多讲了。</p><p>英一破天荒的大作文出了只有图表的。要知道过去十几年都是漫画类型的，只有去年出了漫画加图表，今年就只出了图表。我也只能硬着头皮把我背的漫画作文的句式硬套进去。翻译做的很烂呜呜呜。</p><p>数一更是一塌糊涂，除了选择题能拿一点点分数外，大题基本没有会的。三重积分考了绕直线旋转的，之前真题应该没考过吧，虽然在大纲里要求过，但是着实是没有去重点复习。如果说这科能够够国家线的话，没准还真能进复试了，只能说等成绩出来吧。我自己知道自己做的怎么样，所以我感觉希望渺茫。</p><p>专业课数据结构与算法，对于一个常年在oi浑水摸鱼的人来说简直就是如鱼得水。题目非常简单。拿到试卷的时候简单翻看了一下最后面的DP，求相邻颜色不重复的涂颜色最小代价的问题。坐在考场上，尽管那天是阴天，我宛如在夕阳下坐在门口的老太太，手里不紧不慢地择棉花，忍不住轻哼起来。</p><p>还有一件值得记录的事情。就是在考研前一晚的旅店的床上，我和一起考研的同学手机聊天说如果中午有人给我买饭就好了，那我就不用去挤食堂了。然后我突然想到我真有一位不考研的好朋友，如果他要是来了岂不美哉。当机立断地和他谈话，然后给他买了机票让他赶紧飞过来。他也是被我的想法吓到了，不过最终还是来了。不过飞机是考研第一天下午到的，所以他也就是给我买了第二天的午饭而已。其实饭不饭的不重要，有好朋友陪着就是天大的好事。这是给他买的机票截图：</p><p><img src="https://images.whff521.top/IMG_6368.jpg" alt="ticket"></p><p>之后就是考完了然后陪他在合肥玩了两天，周一上午的合肥动物园没几个游客，跟包场了一样。</p><p>回到宿舍之后第一件事就是把所有考研相关的书都扔了，书桌清静了一大片。下面是扔之前纪念的照片，数据结构和一些数学的书在旅馆的时候就扔了。</p><p><img src="https://images.whff521.top/IMG_6395.JPG" alt="books"></p><h2 id="复习之旅"><a href="#复习之旅" class="headerlink" title="复习之旅"></a>复习之旅</h2><p>回想起2023年十月份好像是，一起和我参加CCSP的学长和我说考研要趁早准备，数学应该今年12月份就开始复习了。如今想起来他的话说的非常正确，可惜我并没有去执行。直到来年的3，4月我才系统的开始复习数学。但是那个时候正是同学们找工作的黄金时期，我也是跟着他们做了简历投递各家公司，所以耽误了很长一段时间。</p><p>不知不觉暑假都到了，我依然没有进入到复习考研的状态，每天就是看看网课，做做数据结构的题。直到暑假快结束了，我同学给我发了一个帕拉迪宇的b站视频。我才大梦初醒。那个视频已经不记得讲了什么了，不过确实是给我骂醒了。我意识到我不能在混混僵僵混日子了，也是在这时去买了好几本练习册，去进入到刷题的状态。由于开始时间很晚，没过几天就是九月份开学了。</p><p>好在软件工程专业大四应该是实习的时间，所以什么课都没有了，我也能天天跑去图书馆学习。我基本时间安排是上午数学，下午英语和数据结构。十一月开了政治，开始用小程序做题，时间安排在晚上。早上九点学到中午十一点半就去吃饭，下午两点半学到五点半，晚饭过后学到晚上八点。回到宿舍后八点半出去操场区域去跳绳，强身健体。每周日休息一天（专心打游戏一天）。</p><p>由于进入复习状态的时间节点太晚，而且是半路转换目标从数二换成数一，着实是复习不完，最后仅仅是完成了全部知识点的学习，做的题目还是太少了。而且在考场上尽管我背会了傅里叶级数系数的公式，但是还是没有算出来最终求和的答案，归根结底还是不会做题。</p><h2 id="往后"><a href="#往后" class="headerlink" title="往后"></a>往后</h2><p>现在终于专心致志玩电脑了，先把大部分精力放在毕业设计上，学日语的进程也不能放下。走一步是一步了，要准备好进入职场，走向社会了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于自主学习</title>
      <link href="/2024/12/19/%E5%85%B3%E4%BA%8E%E8%87%AA%E4%B8%BB%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/12/19/%E5%85%B3%E4%BA%8E%E8%87%AA%E4%B8%BB%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="关于自主学习"><a href="#关于自主学习" class="headerlink" title="关于自主学习"></a>关于自主学习</h1><p>最近也是因为在考研，休闲时间会看《觉醒年代》，今天看到一个英语作文在讲激励式教育。</p><p>激励式教育并不可取，因为如果激励消失后，孩子很难再有动力去学习。</p><p>学习究竟是为了什么，这个问题着实需要自己认真思考一下。</p><p>小学到大学的学习可能都只是仅仅想要升学到更好的学校。所以只需要按部就班的学习，做对试卷上的题目就能一天天混日子。从来没有想过学习本身到底是什么。学习本身绝不仅仅是背许多课文，学许多英语单词，考很高的分数。</p><p>为什么要学习？直到高考后选择专业时可能才是某些人第一次问自己想要干什么的时间。自己的理想和梦想的设立，决定和影响着我们人生未来的发展。但是长达九年的义务教育，是否给自己树立了正确的人生观价值观世界观呢？我自己当然是想成为一名程序员，因为电脑工作者很酷，很帅，能够解决很多有趣的问题，实现很多便利的功能。</p><p>那么实现自己的梦想就是需要学习。到了大学之后就不全是老师带着学生死磕课本的学习模式了，自主学习会逐渐成为大学生学习的常态。你想要成为前端工程师，那就去自学html，js，css，vue，react等，想要当后端工程师就要努力钻研spring boot，java，radis等。</p><p>但实际上这种自主学习的目的也并不单纯。比如想要成为程序员是因为薪资高，那么努力学习的目的可能就转变成了为了以后的薪资。那么和激励式教育又有何不同呢？不过是一个是父母给你东西一个是老板给你钱罢了。</p><p>《觉醒年代》中第一次世界大战结束后，一句话传遍中国，那就是“真理战胜强权”。我觉得，追求真理的学习才是真正的自主学习。这是一种纯粹的，学术上的以及实践上的，科学地认识事物发展规律的过程。求知的欲望从物质的满足转化为精神上的满足。何为真理？真理即是正确的，满足事物发展规律的理论，能够服务于大众，服务于社会的。真理可以根据实际情况而拓展和延伸，应用于万事万物。</p><p>那我们之前的学习还是否有意义？我不管什么真理，假理，我学习就是为了钱，为了自己未来的生活，这行不行？这当然行，大行特行。如果否认了这种学习，就是否认了真理。人们常说失败乃成功之母，真理的发现和归纳也是从无数次失败的实践中得来的。只要是前进性的学习，就不能停歇。巨人的肩膀从来不是一个人的肩膀，而是千千万万的民众用千千万万的实践搭建出来的。</p><p>举个例子，如果一开始的学习是为了一份好工作，那么在学习的过程中你会对这份“好工作”有很多新的认识。哦，原来是这样解决问题的；哦，原来还可以这样用吗。学了很长一段时间之后，你可能觉得自己已经很好的掌握了这种知识，也能够胜任这份“好工作了”。很大概率你确实可以获得这份工作，那之后呢？你想过没有，学习的这个过程远远没有停止。在工作上你会遇到各种各样的问题，往往还是书本上，网络上没有教给你的问题。起初你可能会花费很长时间去解决奇怪的问题，但是随着时间的推移你会越来越熟练，这是因为什么？这正是我讲的“真理”在起作用。在实践中你越来越接近“真理”，所以你越来越懂得用“真理”解决问题。所以你解决问题的速度越来越快，因为这些问题都是同一类“真理”的衍生问题。</p><p>但是还有一类问题是无法解决的。就是框架的物理限制。对于程序员来说，运用的所有功能往往取决于框架提供了什么功能。如果框架没有提供这个功能，而问题的解决需要这个功能，最好的解决办法就是你去实现这个功能。通常来讲这就是开源项目成员比较多的提供贡献的理由。功能的实现肯定不是凭空想象，或许是借鉴于其他框架，或许是借鉴于生活。从用轮子到造轮子的这一过程，离不开自主学习。</p><p>目的仅仅是追求真理吗？追求到真理之后还有学会宣传真理。造了轮子没人用，那意义就微乎其微了。但是究竟该怎么宣传我尚不得知，也正是我以后学习应该注意到的点吧。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第36次CCF CSP计算机软件能力认证记录</title>
      <link href="/2024/12/14/%E7%AC%AC36%E6%AC%A1CCF-CSP%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/12/14/%E7%AC%AC36%E6%AC%A1CCF-CSP%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="第36次CCF-CSP计算机软件能力认证记录"><a href="#第36次CCF-CSP计算机软件能力认证记录" class="headerlink" title="第36次CCF CSP计算机软件能力认证记录"></a>第36次CCF CSP计算机软件能力认证记录</h1><p>本次应该是我最后一次参加CSP了，明年就毕业了。遗憾的是这次也仅仅只是拿了300分。需要走的路还很远很远。</p><p><img src="https://images.whff521.top/csp300.png" alt="csp300"></p><p>今天去官网看见能把代码下载下来了，就记录一下。</p><p>然而这并不是完整的题解，只是我自身心路历程的记录。如果想看完整的题解的话我推荐<a href="https://www.cnblogs.com/luckyblock/p/18596275">这篇博客</a></p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>简单模拟签到题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">types</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;f&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(c==<span class="string">&#x27;b&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(c==<span class="string">&#x27;l&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">if</span>(c==<span class="string">&#x27;r&#x27;</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">walk</span><span class="params">(<span class="type">int</span> startx,<span class="type">int</span> starty,string s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> tempx = startx+dx[<span class="built_in">types</span>(s[i])];</span><br><span class="line">        <span class="type">int</span> tempy = starty+dy[<span class="built_in">types</span>(s[i])];</span><br><span class="line">        <span class="keyword">if</span>(tempx&lt;=<span class="number">0</span>||tempx&gt;n||tempy&lt;=<span class="number">0</span>||tempy&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">        startx = tempx;</span><br><span class="line">        starty = tempy;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;startx&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;starty&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;temp;</span><br><span class="line">        <span class="built_in">walk</span>(x,y,temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>没有想出来正解，暴力算出来每个位置b变成0时需要的最少w。看别人的做法应该是用求和公式写不等式然后用前缀和做。出题人的仁慈，暴力有80分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[mxlen],b[mxlen];</span><br><span class="line"><span class="type">int</span> needE[mxlen];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> originE = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i!=x) temp+=b[i];</span><br><span class="line">       temp-=a[i];</span><br><span class="line">        <span class="keyword">if</span>(temp&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            originE+=-temp;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> originE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">work</span>(i)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>模拟Cache，（学过计组的有福了）。但是最后应该是因为直接用二维数组暴力维护最近使用的内存所以TLE了一个点，只拿了90分。赛后想起来如果用deque声明数组做把排序操作时间复杂度降下来应该就能过了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> n,N;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">bool</span> changed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node v[mxlen][mxlen];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            v[i][j].id=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wirte</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;id&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;id&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findInCache</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=(id/n)%N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i][j].id==<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(v[i][j].id==id) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadCache</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i=(id/n)%N;</span><br><span class="line">    node qw;</span><br><span class="line">    qw.id = id;qw.changed=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i][j].id==<span class="number">-1</span>)&#123;</span><br><span class="line">            v[i][j].id=qw.id;</span><br><span class="line">            v[i][j].changed = qw.changed;</span><br><span class="line">            ok=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok) &#123;<span class="built_in">read</span>(id);;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(v[i][n<span class="number">-1</span>].changed) <span class="built_in">wirte</span>(v[i][n<span class="number">-1</span>].id);</span><br><span class="line">    v[i][n<span class="number">-1</span>].id = qw.id;</span><br><span class="line">    v[i][n<span class="number">-1</span>].changed = qw.changed;</span><br><span class="line">    <span class="built_in">read</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wirteCache</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=(id/n)%N;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i][j].id==id)&#123;</span><br><span class="line">            pos = j;</span><br><span class="line">            v[i][j].changed = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node temp;</span><br><span class="line">    temp.id = v[i][pos].id;</span><br><span class="line">    temp.changed = v[i][pos].changed;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=pos;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">        v[i][j].id = v[i][j<span class="number">-1</span>].id;</span><br><span class="line">        v[i][j].changed = v[i][j<span class="number">-1</span>].changed;</span><br><span class="line">    &#125;</span><br><span class="line">    v[i][<span class="number">0</span>].id = temp.id;</span><br><span class="line">    v[i][<span class="number">0</span>].changed = temp.changed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readInCache</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=(id/n)%N;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i][j].id==id)&#123;</span><br><span class="line">            pos = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node temp;</span><br><span class="line">    temp.id = v[i][pos].id;</span><br><span class="line">    temp.changed = v[i][pos].changed;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=pos;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">        v[i][j].id = v[i][j<span class="number">-1</span>].id;</span><br><span class="line">        v[i][j].changed = v[i][j<span class="number">-1</span>].changed;</span><br><span class="line">    &#125;</span><br><span class="line">    v[i][<span class="number">0</span>].id = temp.id;</span><br><span class="line">    v[i][<span class="number">0</span>].changed = temp.changed;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> type,a;</span><br><span class="line">        cin&gt;&gt;type&gt;&gt;a;</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">findInCache</span>(a))&#123;</span><br><span class="line">                <span class="built_in">readInCache</span>(a);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">loadCache</span>(a);</span><br><span class="line">                <span class="built_in">readInCache</span>(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">findInCache</span>(a))&#123;</span><br><span class="line">                <span class="built_in">wirteCache</span>(a);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">loadCache</span>(a);</span><br><span class="line">                <span class="built_in">wirteCache</span>(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;N;</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p>这道题更是没有思路。正解应该是DP。赛场上只想到了把所有能到的点用边长为1的边连接，然后dijkstra求最短路，只拿了30分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[mxlen],k[mxlen];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    ll v,w,next;</span><br><span class="line">&#125;G[mxlen];</span><br><span class="line">ll head[mxlen],cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll u,ll v,ll w)</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    G[cnt].w=w;</span><br><span class="line">    G[cnt].v=v;</span><br><span class="line">    G[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    ll d,u;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node&amp; t)<span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d&gt;t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int pre[mxlen],last[mxlen],other[mxlen],len[mxlen],l;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void add(int x,int y,int z)&#123;</span></span><br><span class="line"><span class="comment">//     l++;</span></span><br><span class="line"><span class="comment">//     pre[l] = last[x];</span></span><br><span class="line"><span class="comment">//     last[x] = l;</span></span><br><span class="line"><span class="comment">//     other[l] = y;</span></span><br><span class="line"><span class="comment">//     len[l] = z;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">ll dis[mxlen];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>((node)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node temp = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        ll u =temp.u;</span><br><span class="line">        ll d = temp.d;</span><br><span class="line">        <span class="keyword">if</span>(d!=dis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=G[i].next)&#123;</span><br><span class="line">            ll v=G[i].v,w=G[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[u]+w&lt;dis[v])&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                q.<span class="built_in">push</span>((node)&#123;dis[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n]==dis[<span class="number">0</span>]) <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dis[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(n,i+k[i]);j++)&#123;</span><br><span class="line">                <span class="built_in">add</span>(i,j-a[j],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后时间不够了，也没有时间去分析最后一题了，看了一眼根本没看懂呜呜呜。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业设计day0</title>
      <link href="/2024/11/19/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1day0/"/>
      <url>/2024/11/19/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1day0/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>此为记录毕业设计中代码实现功能记录的系列。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>目前只是创建了项目初始文件和git仓库，由于尚未完成，所以github仓库暂为私有不公开状态。</p><h3 id="后端-SpringBoot"><a href="#后端-SpringBoot" class="headerlink" title="后端 SpringBoot"></a>后端 SpringBoot</h3><p>创建项目截图如下：</p><p><img src="https://images.whff521.top/Screenshot%202024-11-19%20at%2010.58.59.png" alt="springboot1"></p><p><img src="https://images.whff521.top/Screenshot%202024-11-19%20at%2011.00.43.png" alt="springboot2"></p><p>Maven仓库，java17，jar包，Spring Boot 3.3.5，预装插件为 MySQL Driver，Lombok，Spring Web</p><h3 id="前端-Android"><a href="#前端-Android" class="headerlink" title="前端 Android"></a>前端 Android</h3><p>创建截图如下：</p><p><img src="https://images.whff521.top/Screenshot%202024-11-17%20at%2018.56.37.png" alt="android"></p><p>java编写， Minimum SDK：API24(Android 7.0),Groovy DSL 构建。</p><p>因为感觉好玩，初始选了Android Studio给的Navigation Drawer Views Activity，现在用这种布局的软件比较少，打算做一个和小红书差不多的。</p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2024/10/31/%E6%8E%92%E5%BA%8F/"/>
      <url>/2024/10/31/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>在数据结构中，<strong>排序</strong>（Sorting）指的是将一个数据集合中的元素按指定顺序重新排列的过程。排序是计算机科学的基本操作之一，对数据处理和分析具有重要作用。排序的结果通常是按从小到大（升序）或从大到小（降序）排列的有序序列。</p><h2 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h2><ol><li><p><strong>内部排序和外部排序</strong>：</p><ul><li><strong>内部排序</strong>：数据量较小，能够将所有待排序的记录一次性加载到内存中完成排序。</li><li><strong>外部排序</strong>：数据量较大，无法一次加载到内存中，需要借助外存（如硬盘）分批次处理并排序。</li></ul></li><li><p><strong>稳定性</strong>：</p><ul><li><strong>稳定排序</strong>：若两个相等的元素在排序前后的相对位置不变，则排序算法是稳定的。例如，若记录有相同的键值，稳定排序会保持它们的初始顺序。</li><li><strong>不稳定排序</strong>：可能会改变相等元素的相对位置。</li></ul></li><li><p><strong>时间复杂度</strong>：排序算法的时间复杂度通常以 $O(n^2)$ 或 $O(n \log n)$ 为主，决定了其在不同规模数据上的效率。</p></li><li><p><strong>空间复杂度</strong>：算法在排序过程中额外占用的存储空间。部分排序算法只需少量辅助空间（如原地排序），而有些则需要较多的辅助空间。</p></li><li><p><strong>排序算法的适用场景</strong>：根据数据量、数据特性（如是否近似有序）以及稳定性要求，选择合适的排序算法。</p></li></ol><h2 id="常见的排序算法及其特性"><a href="#常见的排序算法及其特性" class="headerlink" title="常见的排序算法及其特性"></a>常见的排序算法及其特性</h2><h3 id="1-冒泡排序（Bubble-Sort）："><a href="#1-冒泡排序（Bubble-Sort）：" class="headerlink" title="1. 冒泡排序（Bubble Sort）："></a>1. <strong>冒泡排序（Bubble Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：通过重复遍历待排序的序列，依次比较相邻元素，将较大或较小的元素向后交换。</li><li><strong>时间复杂度</strong>：$O(n^2)$</li><li><strong>特点</strong>：简单但效率低，适用于数据量小的情况。</li><li><strong>稳定性</strong>：稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">bool</span> swapped = <span class="literal">false</span>; <span class="comment">// 用于检测是否发生交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 arr[j] 和 arr[j + 1]</span></span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果在一轮遍历中没有发生交换，说明数组已排序</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bubbleSort</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-选择排序（Selection-Sort）："><a href="#2-选择排序（Selection-Sort）：" class="headerlink" title="2. 选择排序（Selection Sort）："></a>2. <strong>选择排序（Selection Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：每次从未排序部分选择最小（或最大）元素，放在已排序部分的末尾。</li><li><strong>时间复杂度</strong>：$O(n^2)$</li><li><strong>特点</strong>：减少了交换次数，但依然不适合大型数据。</li><li><strong>稳定性</strong>：不稳定</li></ul><h3 id="3-插入排序（Insertion-Sort）："><a href="#3-插入排序（Insertion-Sort）：" class="headerlink" title="3. 插入排序（Insertion Sort）："></a>3. <strong>插入排序（Insertion Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：将待排序数据分成已排序和未排序两部分，逐个将未排序元素插入已排序部分的正确位置。</li><li><strong>时间复杂度</strong>：$O(n^2)$</li><li><strong>特点</strong>：适用于小规模或近乎有序的序列。</li><li><strong>稳定性</strong>：稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> key = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前元素插入到已排序部分</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">insertionSort</span>(arr, n);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-归并排序（Merge-Sort）："><a href="#4-归并排序（Merge-Sort）：" class="headerlink" title="4. 归并排序（Merge Sort）："></a>4. <strong>归并排序（Merge Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：采用分治法，将数据分成子序列分别排序，再将有序子序列合并为完整序列。</li><li><strong>时间复杂度</strong>：$O(n \log n)$</li><li><strong>特点</strong>：效率高，适用于大型数据集，但需要额外存储空间。</li><li><strong>稳定性</strong>：稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = right - mid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时数组</span></span><br><span class="line">    <span class="type">int</span>* leftArr = <span class="keyword">new</span> <span class="type">int</span>[n1];</span><br><span class="line">    <span class="type">int</span>* rightArr = <span class="keyword">new</span> <span class="type">int</span>[n2];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝数据到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">        leftArr[i] = arr[left + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n2; j++)</span><br><span class="line">        rightArr[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并临时数组到原数组</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArr[i] &lt;= rightArr[j]) &#123;</span><br><span class="line">            arr[k] = leftArr[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = rightArr[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝剩余元素（如果有）</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = leftArr[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = rightArr[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放临时数组</span></span><br><span class="line">    <span class="keyword">delete</span>[] leftArr;</span><br><span class="line">    <span class="keyword">delete</span>[] rightArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归排序左右两部分</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, left, mid);</span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并排序后的两部分</span></span><br><span class="line">        <span class="built_in">merge</span>(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-快速排序（Quick-Sort）："><a href="#5-快速排序（Quick-Sort）：" class="headerlink" title="5. 快速排序（Quick Sort）："></a>5. <strong>快速排序（Quick Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：同样采用分治法，通过选择一个基准元素将数组分为两部分，再对每部分递归排序。</li><li><strong>时间复杂度</strong>：平均 $O(n \log n)$，最差 $O(n^2)$</li><li><strong>特点</strong>：通常比其他排序算法快，适合大型数据集，但对有序数组性能不佳。</li><li><strong>稳定性</strong>：不稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high]; <span class="comment">// 选择最后一个元素作为枢轴</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;       <span class="comment">// i 是较小元素的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt; high; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123; </span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]); <span class="comment">// 将较小的元素交换到前面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[high]); <span class="comment">// 将枢轴放到正确位置</span></span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;                <span class="comment">// 返回枢轴的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high); <span class="comment">// 获取分区索引</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>); <span class="comment">// 递归排序左半部分</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high); <span class="comment">// 递归排序右半部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-堆排序（Heap-Sort）："><a href="#6-堆排序（Heap-Sort）：" class="headerlink" title="6. 堆排序（Heap Sort）："></a>6. <strong>堆排序（Heap Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：利用堆这种数据结构进行排序，将数组构建成最大堆或最小堆，逐步取出堆顶元素排序。</li><li><strong>时间复杂度</strong>：$O(n \log n)$</li><li><strong>特点</strong>：时间复杂度稳定，但不适合小规模数据。</li><li><strong>稳定性</strong>：不稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点 i 及其子树调整为最大堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;         <span class="comment">// 将当前节点 i 设为最大值</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;    <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;   <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大值不是当前节点，则交换并递归调整</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主堆排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐一提取元素，重建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]); <span class="comment">// 将堆顶元素移到数组末尾</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);         <span class="comment">// 对剩余的元素重新进行堆化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">heapSort</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="7-希尔排序（Shell-Sort）："><a href="#7-希尔排序（Shell-Sort）：" class="headerlink" title="7. 希尔排序（Shell Sort）："></a>7. <strong>希尔排序（Shell Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：插入排序的改进版，逐步将数据分组并进行插入排序，最后整体排序。</li><li><strong>时间复杂度</strong>：介于 $O(n)$ 和 $O(n^2)$ 之间，具体取决于增量序列。</li><li><strong>特点</strong>：相对高效，尤其在数据量较大时。</li><li><strong>稳定性</strong>：不稳定</li></ul><h3 id="8-计数排序（Counting-Sort）："><a href="#8-计数排序（Counting-Sort）：" class="headerlink" title="8. 计数排序（Counting Sort）："></a>8. <strong>计数排序（Counting Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：适合数据范围较小的整数序列，通过统计数据出现的次数进行排序。</li><li><strong>时间复杂度</strong>：$O(n + k)$，其中 $k$ 为数值范围。</li><li><strong>特点</strong>：非常高效，但仅适用于特定场景。</li><li><strong>稳定性</strong>：稳定</li></ul><h3 id="9-基数排序（Radix-Sort）："><a href="#9-基数排序（Radix-Sort）：" class="headerlink" title="9. 基数排序（Radix Sort）："></a>9. <strong>基数排序（Radix Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：按数位或字符位置逐步排序，适合整数或字符串等定长数据。</li><li><strong>时间复杂度</strong>：$O(d \times (n + k))$，其中 $d$ 是位数，$k$ 为基数。</li><li><strong>特点</strong>：适用于数值或字符数据，效率高。</li><li><strong>稳定性</strong>：稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组中最大元素的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数排序，用于按特定位数对数组排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> exp)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* output = <span class="keyword">new</span> <span class="type">int</span>[n]; <span class="comment">// 输出数组</span></span><br><span class="line">    <span class="type">int</span> count[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;      <span class="comment">// 计数数组（基数范围为 0 到 9）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计在当前位数出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count[(arr[i] / exp) % <span class="number">10</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算累积和，更新 count 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建输出数组，按当前位数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> index = (arr[i] / exp) % <span class="number">10</span>;</span><br><span class="line">        output[count[index] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        count[index]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将排序好的数据拷贝回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = output[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基数排序的主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="built_in">getMax</span>(arr, n); <span class="comment">// 获取最大元素以确定最高位数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每一位数进行计数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> exp = <span class="number">1</span>; max / exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">countSort</span>(arr, n, exp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">170</span>, <span class="number">45</span>, <span class="number">75</span>, <span class="number">90</span>, <span class="number">802</span>, <span class="number">24</span>, <span class="number">2</span>, <span class="number">66</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">radixSort</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>代码说明:</li></ul><ol><li><code>getMax</code> 函数用于找到数组中的最大值，确定排序过程中最高的位数。</li><li><code>countSort</code> 函数实现了针对当前位数的计数排序。<code>exp</code> 表示当前处理的位数（例如，个位、十位等），通过 <code>arr[i] / exp % 10</code> 提取该位上的数字。</li><li><code>radixSort</code> 函数调用 <code>countSort</code>，从最低位开始对数组进行多轮排序，直到最高位。<br>基数排序的时间复杂度为 $O(d \cdot (n + k))$，其中 $d$ 是数字的最大位数，$n$ 是数组长度，$k$ 是基数（通常为10）。在处理整数的情况下，它通常被认为是线性时间排序算法。</li></ol><h3 id="10-桶排序（Bucket-Sort）："><a href="#10-桶排序（Bucket-Sort）：" class="headerlink" title="10. 桶排序（Bucket Sort）："></a>10. <strong>桶排序（Bucket Sort）</strong>：</h3><ul><li><strong>基本思想</strong>：将数据分到不同的桶中，然后对每个桶进行排序，最后合并桶。</li><li><strong>时间复杂度</strong>：平均 $O(n + k)$</li><li><strong>特点</strong>：适合数据分布均匀的情况。</li><li><strong>稳定性</strong>：稳定（取决于桶内排序方法）</li></ul><h2 id="选择排序算法的依据"><a href="#选择排序算法的依据" class="headerlink" title="选择排序算法的依据"></a>选择排序算法的依据</h2><p>根据数据特性和需求，选择排序算法时一般考虑以下因素：</p><ul><li><strong>数据规模</strong>：数据规模小可以选择简单算法（如插入、选择、冒泡），规模较大可以考虑快速排序或归并排序。</li><li><strong>数据特性</strong>：若数据接近有序，选择插入排序；对于整数范围较小的数据，可以选择计数排序。</li><li><strong>稳定性要求</strong>：需要稳定的排序算法可以选择归并排序、计数排序、基数排序等。</li><li><strong>空间要求</strong>：对空间要求较高的场景可优先考虑堆排序或快速排序（可原地排序）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2024/10/31/%E5%9B%BE/"/>
      <url>/2024/10/31/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p><strong>图（Graph）</strong> 是一种用于表示关系的非线性数据结构，由<strong>顶点（节点，Vertices/Nodes）</strong>和<strong>边（Edges）</strong>组成，表示顶点之间的关系。图的概念适用于很多场景，比如社交网络（用户和好友关系）、地图（城市和路线）等。</p><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><ol><li><strong>顶点（Vertex）</strong>：图中的基本单位，表示实体或对象。</li><li><strong>边（Edge）</strong>：连接两个顶点的线，表示它们之间的关系或路径。</li><li><strong>有向图（Directed Graph）</strong>：边有方向的图，边表示从一个顶点到另一个顶点的单向关系。</li><li><strong>无向图（Undirected Graph）</strong>：边没有方向的图，边表示顶点之间的双向关系。</li><li><strong>加权图（Weighted Graph）</strong>：每条边上都有一个权重或费用，用于表示顶点之间的距离或成本。</li><li><strong>邻接</strong>：如果两个顶点之间有直接边相连，则称它们是邻接的。</li><li><strong>路径（Path）</strong>：从一个顶点到另一个顶点的一条顶点序列，其中相邻顶点之间都有边相连。</li><li><strong>环（Cycle）</strong>：从一个顶点出发经过若干边回到该顶点的路径。</li><li><strong>连通图（Connected Graph）</strong>：在无向图中，任何两个顶点之间都可以找到路径的图。</li></ol><h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><ul><li><strong>邻接矩阵（Adjacency Matrix）</strong>：用二维数组表示顶点之间是否相连。</li><li><strong>邻接表（Adjacency List）</strong>：用链表或数组表示每个顶点相邻的顶点。</li></ul><p>以下是使用邻接矩阵和邻接表表示图的简洁 C++ 代码示例。</p><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><p>邻接矩阵使用二维数组表示图，其中 <code>matrix[i][j] = 1</code> 表示顶点 <code>i</code> 和 <code>j</code> 之间有边，<code>0</code> 表示没有边。适合稠密图（边较多）的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphMatrix</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; matrix;</span><br><span class="line">    <span class="type">int</span> numVertices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GraphMatrix</span>(<span class="type">int</span> vertices) &#123;</span><br><span class="line">        numVertices = vertices;</span><br><span class="line">        matrix.<span class="built_in">resize</span>(vertices, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(vertices, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> src, <span class="type">int</span> dest)</span> </span>&#123;</span><br><span class="line">        matrix[src][dest] = <span class="number">1</span>;</span><br><span class="line">        matrix[dest][src] = <span class="number">1</span>;  <span class="comment">// 如果是无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; row : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> val : row)</span><br><span class="line">                cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">GraphMatrix <span class="title">graph</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    graph.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h3><p>邻接表使用链表或向量数组来存储图，每个顶点有一个链表（或向量）表示其相邻顶点，适合稀疏图（边较少）的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjList;</span><br><span class="line">    <span class="type">int</span> numVertices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GraphList</span>(<span class="type">int</span> vertices) &#123;</span><br><span class="line">        numVertices = vertices;</span><br><span class="line">        adjList.<span class="built_in">resize</span>(vertices);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> src, <span class="type">int</span> dest)</span> </span>&#123;</span><br><span class="line">        adjList[src].<span class="built_in">push_back</span>(dest);</span><br><span class="line">        adjList[dest].<span class="built_in">push_back</span>(src);  <span class="comment">// 如果是无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[i])</span><br><span class="line">                cout &lt;&lt; neighbor &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">GraphList <span class="title">graph</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    graph.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><strong>邻接矩阵</strong>：适合用于边较多的图，空间复杂度为 (O(V^2))。</li><li><strong>邻接表</strong>：适合用于边较少的图，空间复杂度为 (O(V + E))，更节省空间。</li></ul><h2 id="图的遍历操作"><a href="#图的遍历操作" class="headerlink" title="图的遍历操作"></a>图的遍历操作</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边（无向图）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList, <span class="type">int</span> src, <span class="type">int</span> dest)</span> </span>&#123;</span><br><span class="line">    adjList[src].<span class="built_in">push_back</span>(dest);</span><br><span class="line">    adjList[dest].<span class="built_in">push_back</span>(src);  <span class="comment">// 无向图</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先搜索（DFS）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> start, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    cout &lt;&lt; start &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[start]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(neighbor, adjList, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广度优先搜索（BFS）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> start, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> v = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> numVertices = <span class="number">5</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjList</span>(numVertices);  <span class="comment">// 邻接表表示图</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    <span class="built_in">addEdge</span>(adjList, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">addEdge</span>(adjList, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">addEdge</span>(adjList, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">addEdge</span>(adjList, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">addEdge</span>(adjList, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先搜索</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;DFS starting from vertex 0: &quot;</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(numVertices, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">0</span>, adjList, visited);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广度优先搜索</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BFS starting from vertex 0: &quot;</span>;</span><br><span class="line">    <span class="built_in">fill</span>(visited.<span class="built_in">begin</span>(), visited.<span class="built_in">end</span>(), <span class="literal">false</span>);  <span class="comment">// 重置访问标记</span></span><br><span class="line">    <span class="built_in">BFS</span>(<span class="number">0</span>, adjList, visited);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明：</p><ol><li><strong>邻接表的创建</strong>：用二维 <code>vector</code> 表示邻接表，其中 <code>adjList[i]</code> 存储顶点 <code>i</code> 的所有相邻顶点。</li><li><strong><code>addEdge</code></strong>：在邻接表中添加一条边。由于是无向图，所以需要添加双向连接。</li><li><strong>DFS</strong>：递归遍历所有相邻的未访问顶点，打印访问顺序。</li><li><strong>BFS</strong>：使用队列逐层遍历，打印访问顺序。</li><li><strong><code>visited</code></strong>：在 DFS 和 BFS 中用于标记访问过的顶点。</li></ol><h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DFS starting from vertex 0: 0 1 2 3 4 </span><br><span class="line">BFS starting from vertex 0: 0 1 2 3 4 </span><br></pre></td></tr></table></figure><ul><li><strong>DFS</strong> 先沿着一条路径深入，再回溯。</li><li><strong>BFS</strong> 逐层遍历，适合用于无权图中的最短路径查找。</li></ul><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>最小生成树（Minimum Spanning Tree，MST）。它用于找到一个无向加权连通图中连接所有顶点的最小代价子图。生成树的边数为 (V - 1)（其中 (V) 是顶点数），且没有环。生成树的总权重最小，即最小生成树。</p><h3 id="最小生成树的两个主要算法"><a href="#最小生成树的两个主要算法" class="headerlink" title="最小生成树的两个主要算法"></a>最小生成树的两个主要算法</h3><ol><li><p><strong>Kruskal 算法</strong>：</p><ul><li>基于“贪心算法”思想。</li><li>按权重从小到大排序所有边，并按顺序选择最小权重的边，只要它不形成环。</li><li>常用“并查集”来检测环。</li><li><strong>时间复杂度</strong>：(O(E \log E))，其中 (E) 是边数。</li></ul></li><li><p><strong>Prim 算法</strong>：</p><ul><li>也是基于“贪心算法”。</li><li>从任意一个顶点开始，将该顶点加入 MST，之后重复选择与已加入 MST 的顶点相邻的权重最小的边。</li><li>常用优先队列（最小堆）来优化边的选择。</li><li><strong>时间复杂度</strong>：(O(E \log V))。</li></ul></li></ol><h3 id="Kruskal-算法的实现（C-代码示例）"><a href="#Kruskal-算法的实现（C-代码示例）" class="headerlink" title="Kruskal 算法的实现（C++ 代码示例）"></a>Kruskal 算法的实现（C++ 代码示例）</h3><p>Kruskal 算法适合边较少的稀疏图，因为它的效率主要取决于边的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> src, dest, weight;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; other.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent, rank;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        rank.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[u] != u)</span><br><span class="line">            parent[u] = <span class="built_in">find</span>(parent[u]);  <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> parent[u];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootU = <span class="built_in">find</span>(u);</span><br><span class="line">        <span class="type">int</span> rootV = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (rootU == rootV)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// u 和 v 已经连接在一起</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootU] &gt; rank[rootV]) &#123;</span><br><span class="line">            parent[rootV] = rootU;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootU] &lt; rank[rootV]) &#123;</span><br><span class="line">            parent[rootU] = rootV;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootV] = rootU;</span><br><span class="line">            ++rank[rootU];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskalMST</span><span class="params">(<span class="type">int</span> V, vector&lt;Edge&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());  <span class="comment">// 按权重排序边</span></span><br><span class="line">    <span class="function">UnionFind <span class="title">uf</span><span class="params">(V)</span></span>;</span><br><span class="line">    <span class="type">int</span> mstWeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; edge : edges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uf.<span class="built_in">unionSets</span>(edge.src, edge.dest)) &#123;  <span class="comment">// 无环则加入 MST</span></span><br><span class="line">            mstWeight += edge.weight;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Edge (&quot;</span> &lt;&lt; edge.src &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; edge.dest &lt;&lt; <span class="string">&quot;) with weight &quot;</span> &lt;&lt; edge.weight &lt;&lt; <span class="string">&quot; added to MST\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mstWeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">4</span>;  <span class="comment">// 顶点数</span></span><br><span class="line">    vector&lt;Edge&gt; edges = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Minimum Spanning Tree Weight: &quot;</span> &lt;&lt; <span class="built_in">kruskalMST</span>(V, edges) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Prim-算法的实现（C-代码示例）"><a href="#Prim-算法的实现（C-代码示例）" class="headerlink" title="Prim 算法的实现（C++ 代码示例）"></a>Prim 算法的实现（C++ 代码示例）</h3><p>Prim 算法适合边较多的稠密图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;  <span class="comment">// &#123;权重, 顶点&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">primMST</span><span class="params">(<span class="type">int</span> V, vector&lt;vector&lt;pii&gt;&gt;&amp; adjList)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">inMST</span><span class="params">(V, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;</span><br><span class="line">    <span class="type">int</span> mstWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从第 0 个顶点开始</span></span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [weight, u] = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inMST[u]) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        inMST[u] = <span class="literal">true</span>;</span><br><span class="line">        mstWeight += weight;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; u &lt;&lt; <span class="string">&quot; added to MST with edge weight &quot;</span> &lt;&lt; weight &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [neighborWeight, v] : adjList[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!inMST[v]) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;neighborWeight, v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mstWeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">4</span>;</span><br><span class="line">    vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">adjList</span>(V);</span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">10</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">6</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">5</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    adjList[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">10</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    adjList[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">15</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">6</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    adjList[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">5</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    adjList[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">15</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    adjList[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Minimum Spanning Tree Weight: &quot;</span> &lt;&lt; <span class="built_in">primMST</span>(V, adjList) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ul><li><strong>Kruskal 算法</strong>：<ul><li>使用 <code>UnionFind</code> 数据结构来管理连接和检测环。</li><li>按权重排序边，并依次检查，若边不会形成环，则将其加入 MST。</li></ul></li><li><strong>Prim 算法</strong>：<ul><li>从一个起始顶点出发，使用优先队列（最小堆）记录与已加入顶点相邻的最小边。</li><li>每次从优先队列中取出权重最小的边，将其对应的顶点加入 MST。</li></ul></li></ul><h3 id="输出示例-1"><a href="#输出示例-1" class="headerlink" title="输出示例"></a>输出示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Edge (2 - 3) with weight 4 added to MST</span><br><span class="line">Edge (0 - 3) with weight 5 added to MST</span><br><span class="line">Edge (0 - 1) with weight 10 added to MST</span><br><span class="line">Minimum Spanning Tree Weight: 19</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>Kruskal 算法</strong>：适合边较少的图，按边排序后添加到 MST。</li><li><strong>Prim 算法</strong>：适合边较多的图，优先从已连接的顶点选择最小的边。</li></ul><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>最短路径算法用于在加权图中查找从起点到终点的最短距离（权重和最小）路径。</p><h3 id="最短路径算法的主要方法"><a href="#最短路径算法的主要方法" class="headerlink" title="最短路径算法的主要方法"></a>最短路径算法的主要方法</h3><p><strong>Dijkstra 算法</strong>：</p><ul><li>适用于边权非负的图。</li><li>使用“贪心算法”思想，每次选择距离起点最近的顶点并更新它的邻接顶点。</li><li>利用优先队列（最小堆）实现效率更高的版本。</li><li><strong>时间复杂度</strong>：(O(E \log V))，其中 (E) 是边数，(V) 是顶点数。</li></ul><h3 id="Dijkstra-算法的实现（C-代码示例）"><a href="#Dijkstra-算法的实现（C-代码示例）" class="headerlink" title="Dijkstra 算法的实现（C++ 代码示例）"></a>Dijkstra 算法的实现（C++ 代码示例）</h3><p>Dijkstra 算法适用于边权为非负的图，特别适合用于单源最短路径问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;  <span class="comment">// &#123;距离, 顶点&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dijkstra算法求最短路径</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> V, vector&lt;vector&lt;pii&gt;&gt;&amp; adjList, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(V, numeric_limits&lt;<span class="type">int</span>&gt;::max())</span></span>;  <span class="comment">// 距离数组初始化为无穷大</span></span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;  <span class="comment">// 最小堆</span></span><br><span class="line"></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, start&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = pq.<span class="built_in">top</span>().second;</span><br><span class="line">        <span class="type">int</span> d = pq.<span class="built_in">top</span>().first;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (d &gt; dist[u]) <span class="keyword">continue</span>;  <span class="comment">// 跳过不需要更新的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [weight, v] : adjList[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[u] + weight &lt; dist[v]) &#123;  <span class="comment">// 如果找到更短路径</span></span><br><span class="line">                dist[v] = dist[u] + weight;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dist[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">5</span>;</span><br><span class="line">    vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">adjList</span>(V);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">10</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    adjList[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    adjList[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">8</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">5</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    adjList[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">4</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 起点</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; distances = <span class="built_in">dijkstra</span>(V, adjList, start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最短路径</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Shortest distances from vertex &quot;</span> &lt;&lt; start &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; distances[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><ul><li>使用最小堆实现贪心选择每次最短路径的顶点。</li><li>每次从堆中提取距离最小的顶点，检查其邻接顶点并更新距离。</li><li>时间复杂度 (O(E \log V)) 主要取决于堆操作。</li></ul><h3 id="SPFA（Shortest-Path-Faster-Algorithm）算法"><a href="#SPFA（Shortest-Path-Faster-Algorithm）算法" class="headerlink" title="SPFA（Shortest Path Faster Algorithm）算法"></a><strong>SPFA（Shortest Path Faster Algorithm）算法</strong></h3><ul><li><strong>原理</strong>：SPFA 算法是 Bellman-Ford 的改进版，利用队列来加速松弛过程。SPFA 仅对需要更新的节点进行处理，不必在每一轮松弛时遍历所有边。</li><li><strong>适用场景</strong>：通常在大部分边为正、且负权边较少的图中，SPFA 表现非常好。</li><li><strong>时间复杂度</strong>：最坏情况下为 (O(V \times E))，但在实际应用中通常远优于 Bellman-Ford。平均复杂度接近 (O(E))。</li></ul><h2 id="SPFA-算法实现示例："><a href="#SPFA-算法实现示例：" class="headerlink" title="SPFA 算法实现示例："></a><strong>SPFA 算法实现示例：</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> dest, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> V, vector&lt;vector&lt;Edge&gt;&gt;&amp; adjList, <span class="type">int</span> start, vector&lt;<span class="type">int</span>&gt;&amp; dist)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">inQueue</span><span class="params">(V, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(V, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dist.<span class="built_in">assign</span>(V, numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    inQueue[start] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        inQueue[u] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : adjList[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = edge.dest;</span><br><span class="line">            <span class="type">int</span> weight = edge.weight;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dist[u] != numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>() &amp;&amp; dist[u] + weight &lt; dist[v]) &#123;</span><br><span class="line">                dist[v] = dist[u] + weight;</span><br><span class="line">                <span class="keyword">if</span> (!inQueue[v]) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    inQueue[v] = <span class="literal">true</span>;</span><br><span class="line">                    count[v]++;</span><br><span class="line">                    <span class="keyword">if</span> (count[v] &gt; V - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 检测到负权环</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 没有负权环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">5</span>;</span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">adjList</span>(V);</span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">10</span>&#125;);</span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    adjList[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    adjList[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">8</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    adjList[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">4</span>&#125;);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dist;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SPFA</span>(V, adjList, start, dist)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Shortest distances from vertex &quot;</span> &lt;&lt; start &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; dist[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Graph contains a negative weight cycle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>拓扑排序（Topological Sorting）用于有向无环图（DAG）中，对图中的节点进行线性排序，以满足每个有向边 ( u \rightarrow v ) 中节点 ( u ) 必须排在节点 ( v ) 之前的要求。拓扑排序常用于解决依赖关系问题，比如任务调度、编译依赖等。</p><h3 id="拓扑排序的基本原理"><a href="#拓扑排序的基本原理" class="headerlink" title="拓扑排序的基本原理"></a>拓扑排序的基本原理</h3><ol><li><p><strong>前提条件</strong>：</p><ul><li>拓扑排序只能在 <strong>有向无环图（DAG）</strong> 上实现，因为如果有环存在，就无法对节点进行线性排序。</li></ul></li><li><p><strong>拓扑排序方法</strong>：</p><ul><li>拓扑排序的实现通常有两种方法：<strong>DFS</strong> 和 <strong>Kahn 算法（BFS）</strong>。</li></ul></li><li><p><strong>主要步骤</strong>：</p><ul><li><strong>DFS法</strong>：对每个未访问的节点进行 DFS 遍历，当遍历到没有后续节点时，将该节点记录下来。这样会得到一个逆序的排序结果。</li><li><strong>Kahn 算法（BFS）</strong>：利用入度的概念，将入度为 0 的节点依次加入队列，处理该节点后将其指向的节点入度减一，并将新入度为 0 的节点加入队列，直至队列为空。</li></ul></li></ol><h3 id="拓扑排序的两种实现"><a href="#拓扑排序的两种实现" class="headerlink" title="拓扑排序的两种实现"></a>拓扑排序的两种实现</h3><h4 id="方法一：DFS-法"><a href="#方法一：DFS-法" class="headerlink" title="方法一：DFS 法"></a>方法一：DFS 法</h4><p>DFS 法适合用递归的方式实现。</p><p><strong>代码实现</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topologicalSortDFS</span><span class="params">(<span class="type">int</span> v, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList, vector&lt;<span class="type">bool</span>&gt;&amp; visited, stack&lt;<span class="type">int</span>&gt;&amp; topoStack)</span> </span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有邻接节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            <span class="built_in">topologicalSortDFS</span>(neighbor, adjList, visited, topoStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点处理完毕，加入栈中</span></span><br><span class="line">    topoStack.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topologicalSort</span><span class="params">(<span class="type">int</span> V, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(V, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; topoStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有节点，进行 DFS</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="built_in">topologicalSortDFS</span>(i, adjList, visited, topoStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出拓扑排序结果</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Topological Sort (DFS): &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!topoStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; topoStack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        topoStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">6</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjList</span>(V);</span><br><span class="line">    adjList[<span class="number">5</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    adjList[<span class="number">5</span>].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    adjList[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    adjList[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    adjList[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">topologicalSort</span>(V, adjList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Topological Sort (DFS): 5 4 2 3 1 0</span><br></pre></td></tr></table></figure><h4 id="方法二：Kahn-算法（BFS-法）"><a href="#方法二：Kahn-算法（BFS-法）" class="headerlink" title="方法二：Kahn 算法（BFS 法）"></a>方法二：Kahn 算法（BFS 法）</h4><p>Kahn 算法通过入度（in-degree）来实现拓扑排序：</p><ol><li>计算每个节点的入度，将入度为 0 的节点加入队列。</li><li>依次从队列中取出节点，输出其编号。</li><li>将该节点指向的所有节点的入度减 1，如果入度变为 0，则将该节点加入队列。</li><li>直到队列为空，最终的输出顺序即为拓扑排序结果。</li></ol><p><strong>代码实现</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topologicalSortKahn</span><span class="params">(<span class="type">int</span> V, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(V, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个节点的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[i]) &#123;</span><br><span class="line">            inDegree[neighbor]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将入度为 0 的节点加入队列</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kahn&#x27;s algorithm</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Topological Sort (Kahn&#x27;s Algorithm): &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有邻接节点，将其入度减 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[u]) &#123;</span><br><span class="line">            inDegree[neighbor]--;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[neighbor] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">6</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjList</span>(V);</span><br><span class="line">    adjList[<span class="number">5</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    adjList[<span class="number">5</span>].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    adjList[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    adjList[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    adjList[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">topologicalSortKahn</span>(V, adjList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Topological Sort (Kahn&#x27;s Algorithm): 4 5 0 2 3 1</span><br></pre></td></tr></table></figure><h3 id="拓扑排序方法总结"><a href="#拓扑排序方法总结" class="headerlink" title="拓扑排序方法总结"></a>拓扑排序方法总结</h3><div class="table-container"><table><thead><tr><th>方法</th><th>主要步骤</th><th>复杂度</th><th>优缺点</th></tr></thead><tbody><tr><td>DFS 法</td><td>DFS 遍历节点，将节点按逆序入栈</td><td>(O(V + E))</td><td>适合递归实现，空间开销较少</td></tr><tr><td>Kahn 算法（BFS 法）</td><td>计算入度，队列处理入度为 0 的节点</td><td>(O(V + E))</td><td>不适合递归实现，但逻辑较直观</td></tr></tbody></table></div><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>有环图无法拓扑排序</strong>：如果在 Kahn 算法中，无法输出所有节点，则说明存在环；在 DFS 法中若检测到回到已访问节点则说明有环。</li></ul><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>关键路径算法（Critical Path Method, CPM）主要用于 <strong>有向无环图（DAG）</strong> 中的 <strong>任务调度问题</strong>，帮助确定任务的最长路径（即关键路径）以及项目的最短完成时间。关键路径中的任务没有时间余地，一旦延迟会导致项目整体延误。</p><h3 id="关键路径的基本原理"><a href="#关键路径的基本原理" class="headerlink" title="关键路径的基本原理"></a>关键路径的基本原理</h3><ol><li><p><strong>事件的最早开始时间（earliest start, ES）</strong>：</p><ul><li>从起点向终点计算，在满足所有前序任务完成的情况下，每个任务可以开始的最早时间。</li></ul></li><li><p><strong>事件的最晚开始时间（latest start, LS）</strong>：</p><ul><li>从终点向起点反向计算，在不延迟项目总工期的前提下，每个任务可以推迟到的最晚开始时间。</li></ul></li><li><p><strong>计算方法</strong>：</p><ul><li>通过 <strong>正向遍历</strong> 和 <strong>反向遍历</strong>，分别计算每个任务的最早和最晚完成时间。</li><li><strong>关键路径</strong>是从起点到终点的最长路径（即时间最长的路径），这条路径上的所有任务都为关键任务，任何一个任务的延迟都会影响整个项目的工期。</li></ul></li></ol><h3 id="关键路径的实现（C-代码）"><a href="#关键路径的实现（C-代码）" class="headerlink" title="关键路径的实现（C++ 代码）"></a>关键路径的实现（C++ 代码）</h3><p>假设任务的关系以有向无环图的邻接表形式给出，图中每个节点表示一个任务，边表示任务依赖，边的权重表示任务所需时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> dest, weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topologicalSort</span><span class="params">(<span class="type">int</span> v, vector&lt;vector&lt;Edge&gt;&gt;&amp; adjList, vector&lt;<span class="type">bool</span>&gt;&amp; visited, stack&lt;<span class="type">int</span>&gt;&amp; topoStack)</span> </span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : adjList[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[edge.dest]) &#123;</span><br><span class="line">            <span class="built_in">topologicalSort</span>(edge.dest, adjList, visited, topoStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    topoStack.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键路径算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">criticalPath</span><span class="params">(<span class="type">int</span> V, vector&lt;vector&lt;Edge&gt;&gt;&amp; adjList)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">earliest</span><span class="params">(V, <span class="number">0</span>)</span></span>;  <span class="comment">// 存储最早开始时间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">latest</span><span class="params">(V, numeric_limits&lt;<span class="type">int</span>&gt;::max())</span></span>;  <span class="comment">// 存储最晚开始时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 拓扑排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(V, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; topoStack;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="built_in">topologicalSort</span>(i, adjList, visited, topoStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 正向计算最早开始时间（earliest start time）</span></span><br><span class="line">    <span class="keyword">while</span> (!topoStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = topoStack.<span class="built_in">top</span>();</span><br><span class="line">        topoStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : adjList[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = edge.dest;</span><br><span class="line">            earliest[v] = <span class="built_in">max</span>(earliest[v], earliest[u] + edge.weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 反向计算最晚开始时间（latest start time）</span></span><br><span class="line">    <span class="type">int</span> projectDuration = *<span class="built_in">max_element</span>(earliest.<span class="built_in">begin</span>(), earliest.<span class="built_in">end</span>());  <span class="comment">// 项目总工期</span></span><br><span class="line">    <span class="built_in">fill</span>(latest.<span class="built_in">begin</span>(), latest.<span class="built_in">end</span>(), projectDuration);  <span class="comment">// 初始化最晚时间为项目总工期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = V - <span class="number">1</span>; u &gt;= <span class="number">0</span>; u--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : adjList[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = edge.dest;</span><br><span class="line">            latest[u] = <span class="built_in">min</span>(latest[u], latest[v] - edge.weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 找到关键路径</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Critical Path: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : adjList[i]) &#123;</span><br><span class="line">            <span class="type">int</span> j = edge.dest;</span><br><span class="line">            <span class="keyword">if</span> (earliest[i] == latest[i] &amp;&amp; earliest[i] + edge.weight == earliest[j]) &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;End&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> projectDuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> V = <span class="number">6</span>;</span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">adjList</span>(V);</span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    adjList[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    adjList[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    adjList[<span class="number">1</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    adjList[<span class="number">2</span>].<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    adjList[<span class="number">3</span>].<span class="built_in">push_back</span>(&#123;<span class="number">5</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    adjList[<span class="number">4</span>].<span class="built_in">push_back</span>(&#123;<span class="number">5</span>, <span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> projectDuration = <span class="built_in">criticalPath</span>(V, adjList);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Project Duration: &quot;</span> &lt;&lt; projectDuration &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释-2"><a href="#代码解释-2" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><p><strong>拓扑排序</strong>：</p><ul><li>由于关键路径算法应用于有向无环图（DAG），首先对图进行拓扑排序，便于按依赖顺序处理任务。</li><li><code>topologicalSort</code> 函数使用递归 DFS 实现拓扑排序。</li></ul></li><li><p><strong>正向遍历计算最早开始时间</strong>：</p><ul><li>从拓扑排序后的起点开始，根据前序任务的最早完成时间计算每个任务的最早开始时间。</li></ul></li><li><p><strong>反向遍历计算最晚开始时间</strong>：</p><ul><li>从终点倒着计算，尽量推迟任务时间（保证不影响总工期），计算每个任务的最晚开始时间。</li><li>使用 <code>fill</code> 将 <code>latest</code> 数组初始化为总工期，这样可以方便地更新最晚开始时间。</li></ul></li><li><p><strong>关键路径</strong>：</p><ul><li>关键路径上的任务满足 <code>earliest[i] == latest[i]</code>，即任务的最早开始时间等于最晚开始时间。通过检查每条边的权重和关键任务条件，确定关键路径并输出。</li></ul></li></ol><h3 id="输出示例-2"><a href="#输出示例-2" class="headerlink" title="输出示例"></a>输出示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Critical Path: 0 -&gt; 1 -&gt; 3 -&gt; 5 -&gt; End</span><br><span class="line">Project Duration: 8</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>关键路径</strong> 是整个项目的最长路径。沿关键路径的所有任务必须按时完成，以免延误项目。</li><li>关键路径算法利用 <strong>拓扑排序</strong> 来确保按依赖关系遍历任务。</li></ul><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2024/10/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2024/10/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p><strong>并查集</strong>（Disjoint Set Union, DSU）是一种数据结构，用于处理<strong>不相交集合</strong>（disjoint sets）的合并（union）和查询（find）操作。并查集特别适用于动态连通性问题，例如判断两个元素是否在同一个集合中或合并两个集合。广泛应用在图论算法中，比如 Kruskal 最小生成树算法。</p><h3 id="并查集的概念"><a href="#并查集的概念" class="headerlink" title="并查集的概念"></a>并查集的概念</h3><p>并查集主要支持两个操作：</p><ol><li><strong>查找（Find）</strong>：确定元素所属的集合。通常返回集合的“代表元素”。</li><li><strong>合并（Union）</strong>：将两个集合合并成一个集合。</li></ol><p>并查集使用<strong>树结构</strong>来表示集合，每个集合中的元素都指向一个根节点，根节点代表该集合。为优化效率，通常使用以下两种技术：</p><ul><li><strong>路径压缩（Path Compression）</strong>：在查找操作中，将树的高度降低，使得查找的时间复杂度接近常数。</li><li><strong>按秩合并（Union by Rank）</strong>：在合并操作中，将较小的树合并到较大的树上，避免树变得过于深。</li></ul><h3 id="并查集的性质"><a href="#并查集的性质" class="headerlink" title="并查集的性质"></a>并查集的性质</h3><ol><li><strong>时间复杂度</strong>：使用路径压缩和按秩合并的并查集可以将单次操作的平均时间复杂度优化到几乎为常数，接近 $O(\alpha(n))$ ，其中 $(\alpha)$ 是阿克曼函数的逆，非常接近常数。</li><li><strong>空间复杂度</strong>：并查集使用 (O(n)) 的空间，其中 (n) 为元素个数。</li></ol><h3 id="并查集的-C-实现"><a href="#并查集的-C-实现" class="headerlink" title="并查集的 C++ 实现"></a>并查集的 C++ 实现</h3><p>以下是并查集的标准实现代码，包含路径压缩和按秩合并优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisjointSet</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;  <span class="comment">// 存储每个节点的父节点</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rank;    <span class="comment">// 存储树的高度（秩）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="built_in">DisjointSet</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        rank.<span class="built_in">resize</span>(n, <span class="number">0</span>);  <span class="comment">// 初始秩为 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;  <span class="comment">// 每个节点的父节点初始化为自己</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找操作，带路径压缩</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = <span class="built_in">find</span>(parent[x]);  <span class="comment">// 递归查找并路径压缩</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并操作，按秩合并</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">            <span class="comment">// 将秩低的树合并到秩高的树上</span></span><br><span class="line">            <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">                parent[rootY] = rootX;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">                parent[rootX] = rootY;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootY] = rootX;</span><br><span class="line">                rank[rootX]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查两个元素是否在同一个集合中</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">DisjointSet <span class="title">ds</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 创建包含10个元素的并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并一些集合</span></span><br><span class="line">    ds.<span class="built_in">unionSets</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    ds.<span class="built_in">unionSets</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    ds.<span class="built_in">unionSets</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    ds.<span class="built_in">unionSets</span>(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询集合连接情况</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is 1 connected to 3? &quot;</span> &lt;&lt; (ds.<span class="built_in">isConnected</span>(<span class="number">1</span>, <span class="number">3</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is 1 connected to 4? &quot;</span> &lt;&lt; (ds.<span class="built_in">isConnected</span>(<span class="number">1</span>, <span class="number">4</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并更多集合</span></span><br><span class="line">    ds.<span class="built_in">unionSets</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is 1 connected to 5 after union? &quot;</span> &lt;&lt; (ds.<span class="built_in">isConnected</span>(<span class="number">1</span>, <span class="number">5</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><p><strong>初始化</strong>：</p><ul><li><code>parent</code> 数组存储每个节点的父节点，初始时每个节点的父节点是自己，表示每个元素独立的集合。</li><li><code>rank</code> 数组存储每个集合的秩，初始为 <code>0</code>。</li></ul></li><li><p><strong>查找操作 <code>find</code></strong>：</p><ul><li>通过递归查找，找到元素所属集合的根节点，并进行路径压缩，将路径上的所有节点直接连接到根节点。</li><li>路径压缩可以减少后续查找操作的时间复杂度。</li></ul></li><li><p><strong>合并操作 <code>unionSets</code></strong>：</p><ul><li>先找到两个元素所属集合的根节点，通过秩大小决定合并方向。</li><li>将低秩的集合合并到高秩集合上，以保持树的高度较低；如果秩相同，将任意一个根连接到另一个根，同时增加连接根的秩。</li></ul></li><li><p><strong>连接检查 <code>isConnected</code></strong>：</p><ul><li>检查两个元素是否属于同一集合，如果根节点相同则属于同一集合。</li></ul></li></ol><h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h3><p>假设输入是如上代码中的操作，输出将如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Is 1 connected to 3? Yes</span><br><span class="line">Is 1 connected to 4? No</span><br><span class="line">Is 1 connected to 5 after union? Yes</span><br></pre></td></tr></table></figure><p>通过路径压缩和按秩合并优化后的并查集，能够高效地支持合并和查找操作。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2024/10/30/%E6%A0%91/"/>
      <url>/2024/10/30/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>在数据结构中，<strong>树</strong>（Tree）是一种分层的非线性数据结构，它由节点（node）和边（edge）组成，并且具有以下性质：</p><h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><ol><li><strong>节点和边</strong>：树包含一组节点，通过边连接，节点之间呈现出层级关系。</li><li><strong>根节点</strong>：树的起始节点称为根节点（root），通常位于树的顶端。</li><li><strong>父节点和子节点</strong>：每个节点可以连接其他节点，称为子节点（children）；连接它们的节点称为父节点（parent）。</li><li><strong>叶子节点</strong>：没有子节点的节点称为叶子节点（leaf）。</li><li><strong>层级</strong>：树的每一层从根节点开始，按层级关系排列。</li><li><strong>路径</strong>：节点之间的路径由节点和边组成，从根节点到某个特定节点的路径是节点之间的唯一路径。</li></ol><h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2><ol><li><strong>唯一根节点</strong>：树中只有一个根节点，没有父节点。</li><li><strong>节点数量关系</strong>：有 ( n ) 个节点的树，边的数量为 ( n - 1 )。</li><li><strong>层次性</strong>：树具有层次结构，自上而下逐级分层。</li><li><strong>无回路性</strong>：树中不存在回路，任何两个节点之间只有唯一一条路径。</li><li><strong>连通性</strong>：树是一个连通的无向图，从根节点可以到达所有节点。</li></ol><h2 id="特殊类型的树"><a href="#特殊类型的树" class="headerlink" title="特殊类型的树"></a>特殊类型的树</h2><ul><li><strong>二叉树</strong>：每个节点最多只有两个子节点的树。</li><li><strong>完全二叉树</strong>：除最后一层外，所有层的节点数都达到最大值，且最后一层节点从左到右连续排列。</li><li><strong>平衡二叉树</strong>：任意节点的左右子树高度差不超过一定值（如 AVL 树）。</li><li><strong>二叉搜索树（BST）</strong>：左子节点的值小于根节点，右子节点的值大于根节点，便于快速查找。</li></ul><p>好的，这里是考试大纲所涉及的二叉树和树的基本概念、性质和C++的实现示例：</p><h2 id="二叉树的概念、性质和实现"><a href="#二叉树的概念、性质和实现" class="headerlink" title="二叉树的概念、性质和实现"></a>二叉树的概念、性质和实现</h2><p><strong>二叉树</strong>是每个节点最多有两个子节点的树结构。每个节点的子节点通常被称为左子节点和右子节点。</p><p><strong>性质</strong>：</p><ol><li>二叉树的第 (i) 层最多有 (2^{i-1}) 个节点。</li><li>高度为 (h) 的二叉树最多有 (2^h - 1) 个节点。</li><li>完全二叉树和满二叉树是特殊的二叉树。</li></ol><p><strong>实现</strong>（链式存储）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点示例</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;val) root-&gt;left = <span class="built_in">insert</span>(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;right = <span class="built_in">insert</span>(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="二叉树的顺序存储结构和链式存储结构"><a href="#二叉树的顺序存储结构和链式存储结构" class="headerlink" title="二叉树的顺序存储结构和链式存储结构"></a>二叉树的顺序存储结构和链式存储结构</h2><p><strong>顺序存储结构</strong>：顺序存储通常使用数组存储完全二叉树。第 (i) 个节点的左子节点在 (2i+1)，右子节点在 (2i+2)。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> binaryTree[<span class="number">100</span>];  <span class="comment">// 顺序存储二叉树的数组表示</span></span><br></pre></td></tr></table></figure></p><p><strong>链式存储结构</strong>：链式存储用指针实现更灵活，适用于非完全二叉树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p><strong>前序遍历</strong>、<strong>中序遍历</strong>、<strong>后序遍历</strong>和<strong>层序遍历</strong>是常见的二叉树遍历方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历 (根 -&gt; 左 -&gt; 右)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历 (左 -&gt; 根 -&gt; 右)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">        cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历 (左 -&gt; 右 -&gt; 根)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="built_in">postorder</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">postorder</span>(root-&gt;right);</span><br><span class="line">        cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树和森林的存储结构、遍历"><a href="#树和森林的存储结构、遍历" class="headerlink" title="树和森林的存储结构、遍历"></a>树和森林的存储结构、遍历</h2><p><strong>树的存储</strong>：一般用链式结构存储树（多叉树），每个节点指向多个子节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    vector&lt;TreeNode*&gt; children;  <span class="comment">// 每个节点可以有多个子节点</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>森林的概念</strong>：森林是一组互不相交的树的集合。常用递归将森林表示为一棵树，每棵树的根节点作为链式存储的下一节点。</p><p><strong>遍历森林</strong>：可以通过先序、后序等遍历方式实现，每个子树递归遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverseForest</span><span class="params">(<span class="type">const</span> vector&lt;TreeNode*&gt;&amp; forest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode* tree : forest) &#123;</span><br><span class="line">        <span class="built_in">preorder</span>(tree);  <span class="comment">// 遍历每棵树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆与优先队列"><a href="#堆与优先队列" class="headerlink" title="堆与优先队列"></a>堆与优先队列</h2><p><strong>堆</strong>是一种特殊的二叉树，是完全二叉树的一种。堆有两种常见的类型：<strong>最大堆</strong>和<strong>最小堆</strong>。</p><ul><li><strong>最大堆</strong>：每个父节点的值都大于等于其子节点的值，根节点是堆中最大的元素。</li><li><strong>最小堆</strong>：每个父节点的值都小于等于其子节点的值，根节点是堆中最小的元素。</li></ul><h3 id="堆的性质"><a href="#堆的性质" class="headerlink" title="堆的性质"></a>堆的性质</h3><ol><li><strong>完全二叉树</strong>：堆使用完全二叉树的结构，因此适合用数组表示。</li><li><strong>节点关系</strong>：在堆的数组表示中，对于第 <code>i</code> 个节点：<ul><li>父节点位置为 <code>(i-1)/2</code>。</li><li>左子节点位置为 <code>2i+1</code>。</li><li>右子节点位置为 <code>2i+2</code>。</li></ul></li></ol><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p><strong>优先队列</strong>是一种基于堆的数据结构，可以快速访问和删除优先级最高（或最低）的元素。在 C++ 中，标准库提供了 <code>priority_queue</code>，其默认实现为最大堆。</p><h4 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h4><p>以下是一个最大堆的简单实现，包括插入和删除最大值的操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">heapifyUp</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> parent = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (heap[index] &gt; heap[parent]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(heap[index], heap[parent]);</span><br><span class="line">                index = parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">heapifyDown</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = heap.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; size) &#123;</span><br><span class="line">            <span class="type">int</span> leftChild = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> rightChild = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> largerChild = leftChild;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rightChild &lt; size &amp;&amp; heap[rightChild] &gt; heap[leftChild]) &#123;</span><br><span class="line">                largerChild = rightChild;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (heap[index] &lt; heap[largerChild]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(heap[index], heap[largerChild]);</span><br><span class="line">                index = largerChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        heap.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="built_in">heapifyUp</span>(heap.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> maxVal = heap[<span class="number">0</span>];</span><br><span class="line">        heap[<span class="number">0</span>] = heap.<span class="built_in">back</span>();</span><br><span class="line">        heap.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">heapifyDown</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> maxVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MaxHeap heap;</span><br><span class="line">    heap.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    heap.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    heap.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Extracted Max: &quot;</span> &lt;&lt; heap.<span class="built_in">extractMax</span>() &lt;&lt; endl;  <span class="comment">// 输出 20</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Extracted Max: &quot;</span> &lt;&lt; heap.<span class="built_in">extractMax</span>() &lt;&lt; endl;  <span class="comment">// 输出 15</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Extracted Max: &quot;</span> &lt;&lt; heap.<span class="built_in">extractMax</span>() &lt;&lt; endl;  <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优先队列的实现（C-标准库）"><a href="#优先队列的实现（C-标准库）" class="headerlink" title="优先队列的实现（C++ 标准库）"></a>优先队列的实现（C++ 标准库）</h4><p>C++ STL 提供了 <code>priority_queue</code>，默认是最大堆，但可以通过传递自定义比较器来实现最小堆。</p><p>好的，以下是一个直接实现的<strong>优先队列</strong>，不依赖 C++ 标准模板库（STL）。我们将使用<strong>最大堆</strong>的方式来实现优先队列，可以快速地获取最大值并进行插入和删除操作。最小堆的实现方式类似，只需调整比较逻辑。</p><h4 id="基于最大堆的优先队列实现"><a href="#基于最大堆的优先队列实现" class="headerlink" title="基于最大堆的优先队列实现"></a>基于最大堆的优先队列实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heap; <span class="comment">// 使用数组来表示堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上浮操作，用于插入元素后调整堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">heapifyUp</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> parent = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (heap[index] &gt; heap[parent]) &#123; <span class="comment">// 如果当前节点大于父节点，交换位置</span></span><br><span class="line">                <span class="built_in">swap</span>(heap[index], heap[parent]);</span><br><span class="line">                index = parent; <span class="comment">// 更新当前节点为父节点位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉操作，用于删除元素后调整堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">heapifyDown</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = heap.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; size) &#123; <span class="comment">// 只需检查左子节点存在的情况</span></span><br><span class="line">            <span class="type">int</span> leftChild = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> rightChild = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> largerChild = leftChild;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到较大的子节点</span></span><br><span class="line">            <span class="keyword">if</span> (rightChild &lt; size &amp;&amp; heap[rightChild] &gt; heap[leftChild]) &#123;</span><br><span class="line">                largerChild = rightChild;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前节点小于较大的子节点，交换</span></span><br><span class="line">            <span class="keyword">if</span> (heap[index] &lt; heap[largerChild]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(heap[index], heap[largerChild]);</span><br><span class="line">                index = largerChild; <span class="comment">// 更新当前节点为交换后的子节点位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        heap.<span class="built_in">push_back</span>(val);  <span class="comment">// 添加到堆的末尾</span></span><br><span class="line">        <span class="built_in">heapifyUp</span>(heap.<span class="built_in">size</span>() - <span class="number">1</span>); <span class="comment">// 调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;PriorityQueue is empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除最大元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;PriorityQueue is empty&quot;</span>);</span><br><span class="line">        heap[<span class="number">0</span>] = heap.<span class="built_in">back</span>();  <span class="comment">// 将最后一个元素移到堆顶</span></span><br><span class="line">        heap.<span class="built_in">pop_back</span>();  <span class="comment">// 删除最后一个元素</span></span><br><span class="line">        <span class="built_in">heapifyDown</span>(<span class="number">0</span>); <span class="comment">// 调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PriorityQueue pq;</span><br><span class="line"></span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Top Element: &quot;</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; endl;  <span class="comment">// 输出 20</span></span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Top Element after pop: &quot;</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; endl;  <span class="comment">// 输出 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释</p><ol><li><p><strong><code>push</code> 方法</strong>：将新元素插入堆的末尾，之后调用 <code>heapifyUp</code> 进行上浮调整，保证堆的最大性质。</p></li><li><p><strong><code>top</code> 方法</strong>：返回堆顶元素，即优先级最高的元素（最大值）。</p></li><li><p><strong><code>pop</code> 方法</strong>：删除堆顶元素，将堆的最后一个元素移到堆顶，并调用 <code>heapifyDown</code> 进行下沉调整，保证堆的最大性质。</p></li><li><p><strong><code>heapifyUp</code> 和 <code>heapifyDown</code> 方法</strong>：维护堆的性质，分别用于元素插入和删除后的调整操作。</p></li></ol><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p><strong>二叉排序树</strong>（Binary Search Tree, BST）是一种特殊的二叉树，用于快速查找、插入和删除操作。BST 在很多应用中用于构建集合和字典。</p><h3 id="二叉排序树的概念"><a href="#二叉排序树的概念" class="headerlink" title="二叉排序树的概念"></a>二叉排序树的概念</h3><ul><li><strong>二叉排序树</strong>是一种有序的二叉树。对于 BST 中的每个节点 <code>N</code>，满足以下性质：<ol><li><strong>左子树</strong>所有节点的值小于 <code>N</code> 节点的值。</li><li><strong>右子树</strong>所有节点的值大于 <code>N</code> 节点的值。</li><li>左右子树也是二叉排序树。</li></ol></li></ul><h3 id="二叉排序树的性质"><a href="#二叉排序树的性质" class="headerlink" title="二叉排序树的性质"></a>二叉排序树的性质</h3><ol><li><strong>查找、插入和删除操作</strong>的时间复杂度平均为 <code>O(log n)</code>，最坏情况下为 <code>O(n)</code>，当 BST 退化为链表（即每个节点只有一个子节点）时会达到最坏情况。</li><li><strong>中序遍历</strong>可以得到一个升序的序列。</li><li>二叉排序树不允许有重复的节点。</li></ol><h3 id="二叉排序树的简洁-C-实现"><a href="#二叉排序树的简洁-C-实现" class="headerlink" title="二叉排序树的简洁 C++ 实现"></a>二叉排序树的简洁 C++ 实现</h3><p>以下是一个简单的 C++ 实现，包括插入、查找和删除操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);  <span class="comment">// 空节点，创建新节点</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; root-&gt;val)</span><br><span class="line">            root-&gt;left = <span class="built_in">insert</span>(root-&gt;left, val);  <span class="comment">// 插入左子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val)</span><br><span class="line">            root-&gt;right = <span class="built_in">insert</span>(root-&gt;right, val); <span class="comment">// 插入右子树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 空节点表示未找到</span></span><br><span class="line">        <span class="keyword">if</span> (val == root-&gt;val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">search</span>(root-&gt;left, val);  <span class="comment">// 在左子树中查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">search</span>(root-&gt;right, val); <span class="comment">// 在右子树中查找</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">remove</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; root-&gt;val)</span><br><span class="line">            root-&gt;left = <span class="built_in">remove</span>(root-&gt;left, val);  <span class="comment">// 删除左子树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val)</span><br><span class="line">            root-&gt;right = <span class="built_in">remove</span>(root-&gt;right, val); <span class="comment">// 删除右子树节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 找到要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (!root-&gt;left) &#123;</span><br><span class="line">                TreeNode* rightChild = root-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> rightChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;right) &#123;</span><br><span class="line">                TreeNode* leftChild = root-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> leftChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 有两个子节点</span></span><br><span class="line">                TreeNode* minNode = <span class="built_in">getMin</span>(root-&gt;right);</span><br><span class="line">                root-&gt;val = minNode-&gt;val;  <span class="comment">// 用右子树中的最小节点替换当前节点</span></span><br><span class="line">                root-&gt;right = <span class="built_in">remove</span>(root-&gt;right, minNode-&gt;val); <span class="comment">// 删除右子树中的最小节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小节点</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">getMin</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root-&gt;left) root = root-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历（输出树中节点的值）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">            cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BinarySearchTree bst;</span><br><span class="line">    TreeNode* root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    root = bst.<span class="built_in">insert</span>(root, <span class="number">50</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(root, <span class="number">30</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(root, <span class="number">20</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(root, <span class="number">40</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(root, <span class="number">70</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(root, <span class="number">60</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(root, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历（输出有序序列）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Inorder traversal: &quot;</span>;</span><br><span class="line">    bst.<span class="built_in">inorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找节点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Search for 40: &quot;</span> &lt;&lt; (bst.<span class="built_in">search</span>(root, <span class="number">40</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not found&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    root = bst.<span class="built_in">remove</span>(root, <span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Inorder traversal after deleting 20: &quot;</span>;</span><br><span class="line">    bst.<span class="built_in">inorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释</p><ol><li><strong>插入节点</strong>：递归地找到正确的插入位置，将节点添加到左子树或右子树。</li><li><strong>查找节点</strong>：根据值在左子树或右子树中递归查找。</li><li><strong>删除节点</strong>：<ul><li>如果要删除的节点没有子节点，直接删除。</li><li>如果只有一个子节点，用子节点替换当前节点。</li><li>如果有两个子节点，用右子树中最小的节点替换当前节点，然后删除替换节点。</li></ul></li><li><strong>中序遍历</strong>：按照左子树 -&gt; 根节点 -&gt; 右子树的顺序遍历节点，输出排序后的值。</li></ol><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><strong>平衡二叉树</strong>（Balanced Binary Tree）是一种改进的二叉搜索树，它保证树的高度保持平衡，从而避免最坏情况下退化为链表。常见的平衡二叉树包括 <strong>AVL树</strong> 和 <strong>红黑树</strong>。这里以 <strong>AVL树</strong> 为例，来介绍平衡二叉树的概念、性质以及实现。</p><h3 id="平衡二叉树的概念和性质"><a href="#平衡二叉树的概念和性质" class="headerlink" title="平衡二叉树的概念和性质"></a>平衡二叉树的概念和性质</h3><ol><li><p><strong>平衡因子</strong>：每个节点的左子树和右子树的高度差不超过1，称为平衡二叉树。具体来说，对于 AVL 树，任一节点的平衡因子（左子树高度减去右子树高度的差）只能是 -1、0 或 1。</p></li><li><p><strong>自平衡</strong>：在插入或删除节点后，AVL 树会通过旋转操作（如单旋转、双旋转）来恢复平衡。</p></li><li><p><strong>查找、插入和删除操作的时间复杂度</strong>为 (O(\log n))，这是因为 AVL 树总是保持平衡，树的高度始终为 (O(\log n))。</p></li></ol><h3 id="AVL-树的旋转操作"><a href="#AVL-树的旋转操作" class="headerlink" title="AVL 树的旋转操作"></a>AVL 树的旋转操作</h3><ul><li><strong>左旋</strong>：右子树高度大于左子树时，将右子节点旋转为根节点。</li><li><strong>右旋</strong>：左子树高度大于右子树时，将左子节点旋转为根节点。</li><li><strong>双旋转</strong>：当插入节点破坏平衡因子后，先进行一次左旋或右旋，再进行一次右旋或左旋。</li></ul><h3 id="AVL-树的简洁-C-实现"><a href="#AVL-树的简洁-C-实现" class="headerlink" title="AVL 树的简洁 C++ 实现"></a>AVL 树的简洁 C++ 实现</h3><p>以下是一个包含插入操作的简单 AVL 树实现代码。插入操作后会进行平衡调整。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">height</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取节点高度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node ? node-&gt;height : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getBalance</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node ? <span class="built_in">getHeight</span>(node-&gt;left) - <span class="built_in">getHeight</span>(node-&gt;right) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右旋</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">rightRotate</span><span class="params">(TreeNode* y)</span> </span>&#123;</span><br><span class="line">        TreeNode* x = y-&gt;left;</span><br><span class="line">        TreeNode* T2 = x-&gt;right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旋转</span></span><br><span class="line">        x-&gt;right = y;</span><br><span class="line">        y-&gt;left = T2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新高度</span></span><br><span class="line">        y-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(y-&gt;left), <span class="built_in">getHeight</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        x-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(x-&gt;left), <span class="built_in">getHeight</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左旋</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">leftRotate</span><span class="params">(TreeNode* x)</span> </span>&#123;</span><br><span class="line">        TreeNode* y = x-&gt;right;</span><br><span class="line">        TreeNode* T2 = y-&gt;left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旋转</span></span><br><span class="line">        y-&gt;left = x;</span><br><span class="line">        x-&gt;right = T2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新高度</span></span><br><span class="line">        x-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(x-&gt;left), <span class="built_in">getHeight</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        y-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(y-&gt;left), <span class="built_in">getHeight</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点并保持平衡</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode* node, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入到左子树或右子树</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; node-&gt;val) node-&gt;left = <span class="built_in">insert</span>(node-&gt;left, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node-&gt;val) node-&gt;right = <span class="built_in">insert</span>(node-&gt;right, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> node; <span class="comment">// 不允许插入重复值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前节点高度</span></span><br><span class="line">        node-&gt;height = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">getHeight</span>(node-&gt;left), <span class="built_in">getHeight</span>(node-&gt;right));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查平衡因子并旋转</span></span><br><span class="line">        <span class="type">int</span> balance = <span class="built_in">getBalance</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左左情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; val &lt; node-&gt;left-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右右情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; val &gt; node-&gt;right-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; val &gt; node-&gt;left-&gt;val) &#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">leftRotate</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右左情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; val &lt; node-&gt;right-&gt;val) &#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">rightRotate</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历输出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">            cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AVLTree avl;</span><br><span class="line">    TreeNode* root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    root = avl.<span class="built_in">insert</span>(root, <span class="number">10</span>);</span><br><span class="line">    root = avl.<span class="built_in">insert</span>(root, <span class="number">20</span>);</span><br><span class="line">    root = avl.<span class="built_in">insert</span>(root, <span class="number">30</span>);</span><br><span class="line">    root = avl.<span class="built_in">insert</span>(root, <span class="number">40</span>);</span><br><span class="line">    root = avl.<span class="built_in">insert</span>(root, <span class="number">50</span>);</span><br><span class="line">    root = avl.<span class="built_in">insert</span>(root, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出中序遍历</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Inorder traversal of AVL tree: &quot;</span>;</span><br><span class="line">    avl.<span class="built_in">inorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释</p><ol><li><strong>getHeight 和 getBalance</strong>：用于计算节点的高度和平衡因子。</li><li><strong>右旋和左旋操作</strong>：用于在失衡时恢复平衡。</li><li><strong>insert 操作</strong>：按二叉搜索树的规则插入新节点，并在每次插入后检查平衡性并进行必要的旋转操作。</li><li><strong>inorder 遍历</strong>：用于输出 AVL 树中节点的值，验证树结构的正确性。</li></ol><h2 id="哈夫曼-Huffman-树和哈夫曼编码"><a href="#哈夫曼-Huffman-树和哈夫曼编码" class="headerlink" title="哈夫曼(Huffman)树和哈夫曼编码"></a>哈夫曼(Huffman)树和哈夫曼编码</h2><p><strong>哈夫曼树</strong>（Huffman Tree）和<strong>哈夫曼编码</strong>（Huffman Coding）是数据压缩领域的重要概念。它们通过使用变长编码表对频率较高的数据分配较短的编码，从而有效地减少数据的存储空间。</p><h3 id="哈夫曼树的概念"><a href="#哈夫曼树的概念" class="headerlink" title="哈夫曼树的概念"></a>哈夫曼树的概念</h3><ul><li><strong>哈夫曼树</strong>是一种带权路径长度最短的二叉树，用于实现最优前缀编码。通常用于无损数据压缩。</li><li>在哈夫曼树中，频率较高的字符会被分配较短的编码，而频率较低的字符会被分配较长的编码，从而使整体编码长度最小化。</li></ul><h3 id="哈夫曼编码的概念"><a href="#哈夫曼编码的概念" class="headerlink" title="哈夫曼编码的概念"></a>哈夫曼编码的概念</h3><ul><li><strong>哈夫曼编码</strong>是一种基于哈夫曼树的前缀编码。每个字符用一串二进制数字表示，且不同字符的编码无公共前缀（前缀编码），避免了编码歧义。</li><li>在构建哈夫曼树后，从根到每个叶节点的路径形成该节点的编码，左子树为 <code>0</code>，右子树为 <code>1</code>。</li></ul><h3 id="哈夫曼树的性质"><a href="#哈夫曼树的性质" class="headerlink" title="哈夫曼树的性质"></a>哈夫曼树的性质</h3><ol><li><strong>最优编码</strong>：哈夫曼编码是无损压缩的最优编码方式之一，可有效减少存储空间。</li><li><strong>前缀编码</strong>：无公共前缀，避免编码歧义。</li><li><strong>构造复杂度</strong>：哈夫曼树构建过程的时间复杂度为 (O(n \log n))，其中 (n) 是字符的种类数。</li></ol><p><strong>无公共前缀</strong>的意思是，在一个编码系统中，任何一个字符的编码都不是另一个字符编码的开头部分（前缀）。在这种情况下，解码时不会有歧义，因为每个编码是唯一且独立的。</p><p>在哈夫曼编码中，这种“无公共前缀”性质被称为<strong>前缀码</strong>（Prefix Code）。具体来说：</p><ul><li>例如，如果字符 A 的编码是 <code>0</code>，字符 B 的编码是 <code>10</code>，字符 C 的编码是 <code>110</code>，字符 D 的编码是 <code>111</code>，那么这些编码没有公共前缀，因为：<ul><li><code>0</code> 不会是其他编码（<code>10</code>, <code>110</code>, <code>111</code>）的前缀。</li><li><code>10</code> 也不会是 <code>110</code> 或 <code>111</code> 的前缀。</li></ul></li></ul><p>这样可以确保<strong>唯一解码</strong>，即每当我们解码时，遇到编码 <code>0</code> 时立即知道是 A，遇到 <code>10</code> 时就是 B，以此类推。</p><h3 id="哈夫曼树和哈夫曼编码的C-实现"><a href="#哈夫曼树和哈夫曼编码的C-实现" class="headerlink" title="哈夫曼树和哈夫曼编码的C++实现"></a>哈夫曼树和哈夫曼编码的C++实现</h3><p>以下是一个简洁的C++实现，使用最小堆来构建哈夫曼树，并生成哈夫曼编码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义哈夫曼树的节点结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> ch;              <span class="comment">// 字符</span></span><br><span class="line">    <span class="type">int</span> freq;             <span class="comment">// 字符频率</span></span><br><span class="line">    HuffmanNode* left;    <span class="comment">// 左子节点</span></span><br><span class="line">    HuffmanNode* right;   <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">HuffmanNode</span>(<span class="type">char</span> c, <span class="type">int</span> f) : <span class="built_in">ch</span>(c), <span class="built_in">freq</span>(f), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数，用于优先队列（最小堆）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(HuffmanNode* a, HuffmanNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;freq &gt; b-&gt;freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成哈夫曼编码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateCodes</span><span class="params">(HuffmanNode* root, string code, unordered_map&lt;<span class="type">char</span>, string&gt;&amp; huffmanCode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到达叶节点，保存字符及其对应编码</span></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        huffmanCode[root-&gt;ch] = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">generateCodes</span>(root-&gt;left, code + <span class="string">&quot;0&quot;</span>, huffmanCode);</span><br><span class="line">    <span class="built_in">generateCodes</span>(root-&gt;right, code + <span class="string">&quot;1&quot;</span>, huffmanCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放哈夫曼树内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeTree</span><span class="params">(HuffmanNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">freeTree</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">freeTree</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建哈夫曼树并生成编码</span></span><br><span class="line"><span class="function">unordered_map&lt;<span class="type">char</span>, string&gt; <span class="title">buildHuffmanTree</span><span class="params">(<span class="type">const</span> unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; freq)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用最小堆来构建哈夫曼树</span></span><br><span class="line">    priority_queue&lt;HuffmanNode*, vector&lt;HuffmanNode*&gt;, Compare&gt; minHeap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化每个字符的节点并加入优先队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : freq) &#123;</span><br><span class="line">        minHeap.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">HuffmanNode</span>(pair.first, pair.second));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并节点，构建哈夫曼树</span></span><br><span class="line">    <span class="keyword">while</span> (minHeap.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        HuffmanNode* left = minHeap.<span class="built_in">top</span>(); minHeap.<span class="built_in">pop</span>();</span><br><span class="line">        HuffmanNode* right = minHeap.<span class="built_in">top</span>(); minHeap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建新的内部节点，频率为左右子节点频率之和</span></span><br><span class="line">        HuffmanNode* sum = <span class="keyword">new</span> <span class="built_in">HuffmanNode</span>(<span class="string">&#x27;\0&#x27;</span>, left-&gt;freq + right-&gt;freq);</span><br><span class="line">        sum-&gt;left = left;</span><br><span class="line">        sum-&gt;right = right;</span><br><span class="line">        minHeap.<span class="built_in">push</span>(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成哈夫曼编码</span></span><br><span class="line">    HuffmanNode* root = minHeap.<span class="built_in">top</span>();</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, string&gt; huffmanCode;</span><br><span class="line">    <span class="built_in">generateCodes</span>(root, <span class="string">&quot;&quot;</span>, huffmanCode);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">freeTree</span>(root);  <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">return</span> huffmanCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义字符频率</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; freq = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&#x27;b&#x27;</span>, <span class="number">9</span>&#125;, &#123;<span class="string">&#x27;c&#x27;</span>, <span class="number">12</span>&#125;, &#123;<span class="string">&#x27;d&#x27;</span>, <span class="number">13</span>&#125;, &#123;<span class="string">&#x27;e&#x27;</span>, <span class="number">16</span>&#125;, &#123;<span class="string">&#x27;f&#x27;</span>, <span class="number">45</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建哈夫曼树并生成编码</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, string&gt; huffmanCode = <span class="built_in">buildHuffmanTree</span>(freq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出编码</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Huffman Codes:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : huffmanCode) &#123;</span><br><span class="line">        cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><strong>HuffmanNode</strong>：定义哈夫曼树的节点结构体，包含字符、频率及左右子节点。</li><li><strong>Compare 函数对象</strong>：用于最小堆比较，以频率为基础构建最小堆。</li><li><strong>buildHuffmanTree</strong>：构建哈夫曼树，通过合并最小频率的节点，最终形成一棵树。</li><li><strong>generateCodes</strong>：递归生成编码，通过树的路径生成每个字符的二进制编码。</li><li><strong>main 函数</strong>：定义字符频率，调用 <code>buildHuffmanTree</code> 构建哈夫曼树并生成编码，最后输出编码结果。</li></ol><h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h3><p>假设频率表为 <code>&#123;&#39;a&#39;: 5, &#39;b&#39;: 9, &#39;c&#39;: 12, &#39;d&#39;: 13, &#39;e&#39;: 16, &#39;f&#39;: 45&#125;</code>，输出结果可能如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Huffman Codes:</span><br><span class="line">a : 1100</span><br><span class="line">b : 1101</span><br><span class="line">c : 100</span><br><span class="line">d : 101</span><br><span class="line">e : 111</span><br><span class="line">f : 0</span><br></pre></td></tr></table></figure></p><p>代码说明</p><p>通过哈夫曼编码，字符 ‘f’ 频率最高，编码最短，而频率较低的字符 ‘a’ 和 ‘b’ 编码更长，从而达到压缩效果。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2024/10/30/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2024/10/30/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>哈希表（Hash Table）是一种用于存储键值对的数据结构，可以通过哈希函数快速地根据键找到对应的值。哈希表的查找、插入和删除操作在平均情况下具有 <code>O(1)</code> 的时间复杂度，非常高效。</p><h2 id="1-哈希表的基本概念"><a href="#1-哈希表的基本概念" class="headerlink" title="1. 哈希表的基本概念"></a>1. 哈希表的基本概念</h2><p>哈希表的核心思想是将键通过一个<strong>哈希函数</strong>（Hash Function）映射到一个哈希表的索引位置上。若两个键映射到同一位置（即出现<strong>哈希冲突</strong>），则需要解决冲突以保证数据存储的正确性。</p><h3 id="哈希表的术语"><a href="#哈希表的术语" class="headerlink" title="哈希表的术语"></a>哈希表的术语</h3><ul><li><strong>哈希函数</strong>：将键映射到表中某个位置的函数。</li><li><strong>哈希冲突</strong>：两个不同的键被映射到同一个位置。</li><li><strong>装载因子</strong>：表中已填充元素的数量与哈希表大小的比值。较高的装载因子会增加冲突发生的可能性。</li></ul><h2 id="2-哈希表的实现方式"><a href="#2-哈希表的实现方式" class="headerlink" title="2. 哈希表的实现方式"></a>2. 哈希表的实现方式</h2><p>哈希表的常用实现方式主要有两种：</p><ol><li><strong>开放寻址法</strong>：在发生冲突时，通过寻找其他空闲位置来存储元素。常见的开放寻址方法包括线性探测、二次探测和双重哈希。</li><li><strong>链地址法（拉链法）</strong>：在每个哈希表位置存储一个链表，在发生冲突时将新元素插入到链表中。</li></ol><h2 id="3-哈希表的-C-实现"><a href="#3-哈希表的-C-实现" class="headerlink" title="3. 哈希表的 C++ 实现"></a>3. 哈希表的 C++ 实现</h2><h3 id="使用链地址法（拉链法）的-C-实现"><a href="#使用链地址法（拉链法）的-C-实现" class="headerlink" title="使用链地址法（拉链法）的 C++ 实现"></a>使用链地址法（拉链法）的 C++ 实现</h3><p>我们可以使用一个数组加链表的结构来实现哈希表。每个数组元素是一个链表，用于解决哈希冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; table;  <span class="comment">// 哈希表的数组，每个位置是一个链表</span></span><br><span class="line">    <span class="type">int</span> size;                 <span class="comment">// 哈希表的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数：简单取模法</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunction</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HashTable</span>(<span class="type">int</span> s) : <span class="built_in">size</span>(s) &#123;</span><br><span class="line">        table.<span class="built_in">resize</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line">        table[index].<span class="built_in">push_back</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line">        table[index].<span class="built_in">remove</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : table[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element == key) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示哈希表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : table[i]) &#123;</span><br><span class="line">                cout &lt;&lt; element &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">HashTable <span class="title">hashTable</span><span class="params">(<span class="number">7</span>)</span></span>; <span class="comment">// 创建大小为 7 的哈希表</span></span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hash Table:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Searching for 15: &quot;</span> &lt;&lt; (hashTable.<span class="built_in">search</span>(<span class="number">15</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">remove</span>(<span class="number">15</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After removing 15:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul><li><strong>哈希函数</strong>：这里我们用简单的取模方法，将键值对映射到表中的某个位置。<code>hashFunction(int key)</code> 通过 <code>key % size</code> 计算索引。</li><li><strong>插入操作</strong>：将元素插入到哈希表中指定索引的链表中。</li><li><strong>删除操作</strong>：从哈希表中指定索引的链表中删除目标元素。</li><li><strong>查找操作</strong>：检查目标元素是否在哈希表的某个位置的链表中。</li></ul><h3 id="开放寻址法的几种探测方法"><a href="#开放寻址法的几种探测方法" class="headerlink" title="开放寻址法的几种探测方法"></a>开放寻址法的几种探测方法</h3><ol><li><strong>线性探测</strong>（Linear Probing）：冲突时按固定步长（通常为 1）查找下一个空位。</li><li><strong>二次探测</strong>（Quadratic Probing）：冲突时按二次方步长查找下一个空位，步长逐渐增加以避免簇现象。</li><li><strong>双重哈希</strong>（Double Hashing）：使用两个哈希函数，当冲突发生时，通过第二个哈希函数计算步长。</li></ol><p>下面我们以<strong>线性探测法</strong>为例，展示开放寻址法的实现。</p><h3 id="使用开放寻址法的哈希表-C-实现"><a href="#使用开放寻址法的哈希表-C-实现" class="headerlink" title="使用开放寻址法的哈希表 C++ 实现"></a>使用开放寻址法的哈希表 C++ 实现</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul><li>使用一个数组保存元素，初始值为 -1 或 <code>nullptr</code> 表示该位置空闲。</li><li>插入元素时，如果计算出的索引位置被占用，则按探测策略查找下一个位置。</li><li>删除元素时，采用标记（例如 <code>-2</code>）表示“删除状态”，这样在查找时不会打断探测链。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenAddressHashTable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; table; <span class="comment">// 哈希表数组</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数：简单取模</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunction</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OpenAddressHashTable</span>(<span class="type">int</span> s) : <span class="built_in">size</span>(s) &#123;</span><br><span class="line">        table.<span class="built_in">resize</span>(size, <span class="number">-1</span>); <span class="comment">// -1 表示空闲位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线性探测</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> probeIndex = (index + i) % size;  <span class="comment">// 线性探测</span></span><br><span class="line">            <span class="keyword">if</span> (table[probeIndex] == <span class="number">-1</span> || table[probeIndex] == <span class="number">-2</span>) &#123; <span class="comment">// 找到空闲或已删除位置</span></span><br><span class="line">                table[probeIndex] = key;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 哈希表已满</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线性探测</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> probeIndex = (index + i) % size;</span><br><span class="line">            <span class="keyword">if</span> (table[probeIndex] == key) &#123;  <span class="comment">// 找到目标元素</span></span><br><span class="line">                table[probeIndex] = <span class="number">-2</span>; <span class="comment">// -2 标记删除状态</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (table[probeIndex] == <span class="number">-1</span>) &#123;  <span class="comment">// 没找到且遇到空闲位置，停止查找</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunction</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线性探测</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> probeIndex = (index + i) % size;</span><br><span class="line">            <span class="keyword">if</span> (table[probeIndex] == key) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">// 找到目标元素</span></span><br><span class="line">            <span class="keyword">if</span> (table[probeIndex] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 找到空闲位置，停止查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示哈希表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; table[i] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (table[i] == <span class="number">-2</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: [Deleted]&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: [Empty]&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">OpenAddressHashTable <span class="title">hashTable</span><span class="params">(<span class="number">7</span>)</span></span>; <span class="comment">// 创建大小为 7 的哈希表</span></span><br><span class="line"></span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">    hashTable.<span class="built_in">insert</span>(<span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hash Table:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Searching for 15: &quot;</span> &lt;&lt; (hashTable.<span class="built_in">search</span>(<span class="number">15</span>) ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">remove</span>(<span class="number">15</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After removing 15:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    hashTable.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><ul><li><strong>哈希函数</strong>：使用 <code>key % size</code> 计算元素的初始索引位置。</li><li><strong>线性探测</strong>：在发生冲突时，通过逐次递增索引来查找下一个空闲位置，直到找到空位或返回失败。</li><li><strong>删除标记</strong>：删除元素时，将该位置标记为 <code>-2</code>（表示已删除），防止探测链的中断。<code>-1</code> 表示空闲位置。</li><li><strong>查找与删除</strong>：查找元素时遇到 <code>-1</code> 即可停止查找，遇到 <code>-2</code> 则继续探测链。</li></ul><h3 id="其他探测方法简述"><a href="#其他探测方法简述" class="headerlink" title="其他探测方法简述"></a>其他探测方法简述</h3><ol><li><strong>二次探测</strong>：冲突时探测间隔为 $( i^2 )$ （如 <code>index + i^2</code>）。这样可以避免线性探测中的“主簇”问题，但可能引入新的探测区域。</li><li><strong>双重哈希</strong>：冲突时通过第二个哈希函数计算步长，跳跃性地寻找位置，减少了探测链的聚集现象。</li></ol><p>开放寻址法通常比链地址法更节省空间，但当装载因子过高时，开放寻址法的性能下降更明显。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列</title>
      <link href="/2024/10/30/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2024/10/30/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-栈的基本概念与操作"><a href="#1-栈的基本概念与操作" class="headerlink" title="1. 栈的基本概念与操作"></a>1. 栈的基本概念与操作</h2><p>栈（Stack）是一种<strong>后进先出</strong>（LIFO, Last In First Out）的数据结构，最后插入的元素最先被删除。</p><h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><ol><li><strong>初始化</strong>：创建一个空栈。</li><li><strong>入栈（Push）</strong>：将一个元素压入栈顶。</li><li><strong>出栈（Pop）</strong>：从栈顶删除一个元素。</li><li><strong>取栈顶元素（Top）</strong>：获取栈顶元素的值，但不删除它。</li><li><strong>判断是否为空</strong>：检查栈是否为空。</li></ol><h2 id="2-队列的基本概念与操作"><a href="#2-队列的基本概念与操作" class="headerlink" title="2. 队列的基本概念与操作"></a>2. 队列的基本概念与操作</h2><p>队列（Queue）是一种<strong>先进先出</strong>（FIFO, First In First Out）的数据结构，最先插入的元素最先被删除。</p><h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><ol><li><strong>初始化</strong>：创建一个空队列。</li><li><strong>入队（Enqueue）</strong>：将一个元素加入到队尾。</li><li><strong>出队（Dequeue）</strong>：从队头删除一个元素。</li><li><strong>取队头元素（Front）</strong>：获取队头元素的值，但不删除它。</li><li><strong>判断是否为空</strong>：检查队列是否为空。</li></ol><h2 id="3-栈的顺序存储结构"><a href="#3-栈的顺序存储结构" class="headerlink" title="3. 栈的顺序存储结构"></a>3. 栈的顺序存储结构</h2><p>栈的顺序存储结构通常使用数组实现，栈顶指针 <code>top</code> 用于指向栈顶元素。</p><h3 id="栈的顺序存储结构的-C-实现"><a href="#栈的顺序存储结构的-C-实现" class="headerlink" title="栈的顺序存储结构的 C++ 实现"></a>栈的顺序存储结构的 C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>() : <span class="built_in">top</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top &gt;= MAX_SIZE - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 栈满</span></span><br><span class="line">        data[++top] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 栈空</span></span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 栈空</span></span><br><span class="line">        <span class="keyword">return</span> data[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= top; ++i) std::cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-队列的顺序存储结构"><a href="#4-队列的顺序存储结构" class="headerlink" title="4. 队列的顺序存储结构"></a>4. 队列的顺序存储结构</h2><p>队列的顺序存储结构可以用循环数组实现，使用 <code>front</code> 和 <code>rear</code> 两个指针分别指向队头和队尾。</p><h3 id="队列的顺序存储结构的-C-实现"><a href="#队列的顺序存储结构的-C-实现" class="headerlink" title="队列的顺序存储结构的 C++ 实现"></a>队列的顺序存储结构的 C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>() : <span class="built_in">front</span>(<span class="number">0</span>), <span class="built_in">rear</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">enqueue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((rear + <span class="number">1</span>) % MAX_SIZE == front) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 队列满</span></span><br><span class="line">        data[rear] = value;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == rear) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 队列空</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == rear) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 队列空</span></span><br><span class="line">        <span class="keyword">return</span> data[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = front;</span><br><span class="line">        <span class="keyword">while</span> (i != rear) &#123;</span><br><span class="line">            std::cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            i = (i + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-栈的链式存储结构"><a href="#5-栈的链式存储结构" class="headerlink" title="5. 栈的链式存储结构"></a>5. 栈的链式存储结构</h2><p>栈的链式存储结构使用链表实现，每次入栈和出栈都在链表的头部操作。</p><h3 id="栈的链式存储结构的-C-实现"><a href="#栈的链式存储结构的-C-实现" class="headerlink" title="栈的链式存储结构的 C++ 实现"></a>栈的链式存储结构的 C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* top;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedStack</span>() : <span class="built_in">top</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(value);</span><br><span class="line">        newNode-&gt;next = top;</span><br><span class="line">        top = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!top) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 栈空</span></span><br><span class="line">        Node* temp = top;</span><br><span class="line">        top = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top ? top-&gt;data : <span class="number">-1</span>;  <span class="comment">// 栈空返回 -1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node* curr = top;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            std::cout &lt;&lt; curr-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-队列的链式存储结构"><a href="#6-队列的链式存储结构" class="headerlink" title="6. 队列的链式存储结构"></a>6. 队列的链式存储结构</h2><p>队列的链式存储结构使用链表实现，链表的头部作为队头，尾部作为队尾。</p><h3 id="队列的链式存储结构的-C-实现"><a href="#队列的链式存储结构的-C-实现" class="headerlink" title="队列的链式存储结构的 C++ 实现"></a>队列的链式存储结构的 C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    QNode* next;</span><br><span class="line">    <span class="built_in">QNode</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QNode *front, *rear;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedQueue</span>() : <span class="built_in">front</span>(<span class="literal">nullptr</span>), <span class="built_in">rear</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        QNode* newNode = <span class="keyword">new</span> <span class="built_in">QNode</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (!rear) &#123;</span><br><span class="line">            front = rear = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rear-&gt;next = newNode;</span><br><span class="line">            rear = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!front) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 队列空</span></span><br><span class="line">        QNode* temp = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!front) rear = <span class="literal">nullptr</span>;  <span class="comment">// 队列变空</span></span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front ? front-&gt;data : <span class="number">-1</span>;  <span class="comment">// 队列空返回 -1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QNode* curr = front;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            std::cout &lt;&lt; curr-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>栈</strong>：遵循 LIFO 原则，典型操作包括入栈和出栈。</li><li><strong>队列</strong>：遵循 FIFO 原则，典型操作包括入队和出队。</li><li><strong>顺序存储</strong>：使用数组实现，适合容量固定的情况，操作简单。</li><li><strong>链式存储</strong>：使用链表实现，适合动态长度的情况，节省空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/2024/10/30/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2024/10/30/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是一种数据结构，表示由<strong>同一类型的元素按顺序排列</strong>的有限集合。线性表中的元素有顺序关系，可以通过顺序号访问。它是最常用的结构之一，常用于实现数据的顺序存储和查找操作。</p><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><p>一个线性表 $( L )$ 可以定义为一个具有相同类型的元素集合，其中第一个元素为 $( a_1 )$，第二个元素为 $( a_2 )$，依次排列，直到第 $( n )$ 个元素 $( a_n )$。线性表的长度是元素的个数，当长度为 0 时，称其为空表。</p><p>在数学上可以表示为：<br>$[ L = { a_1, a_2, \dots, a_n } ]$</p><h2 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h2><p>线性表的基本操作主要包括以下几个：</p><ol><li><p><strong>初始化</strong>（Initialization）</p><ul><li>创建一个空的线性表。</li></ul></li><li><p><strong>插入</strong>（Insert）</p><ul><li>将一个新元素插入到线性表的指定位置。插入时，需要将插入位置后的所有元素向后移动。</li></ul></li><li><p><strong>删除</strong>（Delete）</p><ul><li>删除线性表中的指定位置的元素。删除时，需要将删除位置后的所有元素向前移动。</li></ul></li><li><p><strong>查找</strong>（Find/Search）</p><ul><li>根据元素的值查找其在表中的位置，或根据位置查找对应的元素值。</li></ul></li><li><p><strong>更新</strong>（Update）</p><ul><li>修改线性表中指定位置的元素值。</li></ul></li><li><p><strong>遍历</strong>（Traverse）</p><ul><li>顺序访问线性表中的每一个元素，通常用于打印或处理每个元素。</li></ul></li><li><p><strong>获取长度</strong>（Length）</p><ul><li>获取线性表中元素的个数。</li></ul></li></ol><h2 id="线性表的实现方式"><a href="#线性表的实现方式" class="headerlink" title="线性表的实现方式"></a>线性表的实现方式</h2><p>线性表的实现通常有两种存储结构：</p><ul><li><strong>顺序存储结构</strong>：使用数组存储元素，适合顺序访问，但插入和删除操作的效率较低。</li><li><strong>链式存储结构</strong>：使用链表存储元素，适合频繁的插入和删除操作，常见的链表类型包括单链表、循环链表和双向链表。</li></ul><h3 id="1-顺序表的实现"><a href="#1-顺序表的实现" class="headerlink" title="1. 顺序表的实现"></a>1. 顺序表的实现</h3><p>顺序表使用数组实现，其特点是可以直接通过索引访问元素，效率高，但插入和删除需要移动元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqList</span>() : <span class="built_in">length</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt; length || length &gt;= MAX_SIZE) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = length; i &gt; pos; --i) data[i] = data[i - <span class="number">1</span>];</span><br><span class="line">        data[pos] = value;</span><br><span class="line">        length++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt;= length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt; length - <span class="number">1</span>; ++i) data[i] = data[i + <span class="number">1</span>];</span><br><span class="line">        length--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">            <span class="keyword">if</span> (data[i] == value) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) std::cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-单链表的实现"><a href="#2-单链表的实现" class="headerlink" title="2. 单链表的实现"></a>2. 单链表的实现</h3><p>单链表由节点构成，适合频繁的插入和删除操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SinglyLinkedList</span>() : <span class="built_in">head</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(value);</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node *prev = <span class="literal">nullptr</span>, *curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr &amp;&amp; curr-&gt;data != value) &#123;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!curr) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prev) prev-&gt;next = curr-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> head = curr-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> curr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">find</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;data == value) <span class="keyword">return</span> curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            std::cout &lt;&lt; curr-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-循环链表的实现"><a href="#3-循环链表的实现" class="headerlink" title="3. 循环链表的实现"></a>3. 循环链表的实现</h3><p>循环链表的最后一个节点指向第一个节点，形成一个循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    CNode* next;</span><br><span class="line">    <span class="built_in">CNode</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CNode* tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircularLinkedList</span>() : <span class="built_in">tail</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        CNode* newNode = <span class="keyword">new</span> <span class="built_in">CNode</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (!tail) &#123;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            tail-&gt;next = tail;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode-&gt;next = tail-&gt;next;</span><br><span class="line">            tail-&gt;next = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tail) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        CNode *curr = tail-&gt;next, *prev = tail;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;data == value) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curr == tail) tail = (tail-&gt;next == tail) ? <span class="literal">nullptr</span> : prev;</span><br><span class="line">                prev-&gt;next = curr-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> curr;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (curr != tail-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">CNode* <span class="title">find</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tail) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        CNode* curr = tail-&gt;next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;data == value) <span class="keyword">return</span> curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (curr != tail-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tail) <span class="keyword">return</span>;</span><br><span class="line">        CNode* curr = tail-&gt;next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; curr-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (curr != tail-&gt;next);</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-双向链表的实现"><a href="#4-双向链表的实现" class="headerlink" title="4. 双向链表的实现"></a>4. 双向链表的实现</h3><p>双向链表每个节点有前驱和后继指针，方便双向遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    DNode* prev;</span><br><span class="line">    DNode* next;</span><br><span class="line">    <span class="built_in">DNode</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DNode* head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DoublyLinkedList</span>() : <span class="built_in">head</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        DNode* newNode = <span class="keyword">new</span> <span class="built_in">DNode</span>(value);</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        <span class="keyword">if</span> (head) head-&gt;prev = newNode;</span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        DNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr &amp;&amp; curr-&gt;data != value) curr = curr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!curr) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;prev) curr-&gt;prev-&gt;next = curr-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> head = curr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;next) curr-&gt;next-&gt;prev = curr-&gt;prev;</span><br><span class="line">        <span class="keyword">delete</span> curr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DNode* <span class="title">find</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        DNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;data == value) <span class="keyword">return</span> curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            std::cout &lt;&lt; curr-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些代码分别实现了顺序表、单链表、循环链表和双向链表的数据结构及其基本操作，适合考试和项目中的线性表应用。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCSP2024 赛后回忆</title>
      <link href="/2024/10/23/CCSP2024-%E8%B5%9B%E5%90%8E%E5%9B%9E%E5%BF%86/"/>
      <url>/2024/10/23/CCSP2024-%E8%B5%9B%E5%90%8E%E5%9B%9E%E5%BF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="CCSP2024-赛后回忆"><a href="#CCSP2024-赛后回忆" class="headerlink" title="CCSP2024 赛后回忆"></a>CCSP2024 赛后回忆</h1><p>这次是在浙江金华的浙江师范大学，虽然说这里可能有一点点偏僻，但是店铺什么的基本都有，奶茶店，肯德基什么的甚至开在了校内。</p><p>这应该是我大学最后一次参加国家级的赛事了吧。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="I-O-任务调度队列"><a href="#I-O-任务调度队列" class="headerlink" title="I/O 任务调度队列"></a>I/O 任务调度队列</h3><p>按来的时间排个序，奇数放第一个队列，偶数放第二个队列，保证每个任务等待的时间最小就可以了，签到题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t[mxlen];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;t[i];</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">sort</span>(t+<span class="number">1</span>,t+n+<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t[i]&gt;=ans1)&#123;</span><br><span class="line">                    ans1 = t[i]+<span class="number">10</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    ans1 += <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(t[i]&gt;=ans2)&#123;</span><br><span class="line">                    ans2 = t[i]+<span class="number">10</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> ans2 +=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans1&gt;ans2) <span class="built_in">swap</span>(ans1,ans2);</span><br><span class="line">        cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数树"><a href="#数树" class="headerlink" title="数树"></a>数树</h3><p>模拟题？直接按照他说的把功能都写了就行了，记录一下每个节点的父节点是什么。一开始只用了一位数组来记录点和父节点断开，改来改去只有45分。后来突然想到他可能和好多节点都断开，直接用vector存一下就过了。</p><p>第二天听颁奖典礼上讲题解说的是分快树，LCT做。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> pre_ans;</span><br><span class="line"><span class="type">int</span> w[mxlen];</span><br><span class="line"><span class="type">int</span> father[mxlen];</span><br><span class="line"><span class="type">int</span> now_root = <span class="number">1</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; broken[mxlen];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[mxlen];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_relation</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;broken[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(broken[u][i]==v) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_father</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    father[u] = fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check_relation</span>(u,g[u][i])) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">find_father</span>(g[u][i],u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pre_ans) <span class="keyword">return</span> v;</span><br><span class="line">    <span class="keyword">return</span> v^pre_ans;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs_weight</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check_relation</span>(u,g[u][i])) <span class="keyword">continue</span>;</span><br><span class="line">        ans+=<span class="built_in">dfs_weight</span>(g[u][i],u,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(w[u]&gt;x) ans++;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_heaviest</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = w[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check_relation</span>(u,g[u][i])) <span class="keyword">continue</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,<span class="built_in">find_heaviest</span>(g[u][i],u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">find_minw_minindex</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    node tmp = &#123;w[u],u&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check_relation</span>(u,g[u][i])) <span class="keyword">continue</span>;</span><br><span class="line">        node son = <span class="built_in">find_minw_minindex</span>(g[u][i],u);</span><br><span class="line">        <span class="keyword">if</span>(son.weight&lt;tmp.weight)&#123;</span><br><span class="line">            tmp.weight = son.weight;</span><br><span class="line">            tmp.index = son.index;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(son.weight==tmp.weight)&#123;</span><br><span class="line">            <span class="keyword">if</span>(son.index&lt;tmp.index)&#123;</span><br><span class="line">                tmp.weight = son.weight;</span><br><span class="line">                tmp.index = son.index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u,x;</span><br><span class="line">    <span class="comment">// ask how many points&#x27; weight more than v in u subtree</span></span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;x;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        x = <span class="built_in">change</span>(x);</span><br><span class="line">        pre_ans = <span class="built_in">dfs_weight</span>(u,father[u],x);</span><br><span class="line">        cout&lt;&lt;pre_ans&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;x;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        x = <span class="built_in">change</span>(x);</span><br><span class="line">        w[u] = x;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;x;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        x = <span class="built_in">change</span>(x);</span><br><span class="line">        n++;</span><br><span class="line">        g[n].<span class="built_in">push_back</span>(u);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(n);</span><br><span class="line">        father[n] = u;</span><br><span class="line">        w[n] = x;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        broken[u].<span class="built_in">push_back</span>(father[u]);</span><br><span class="line">        broken[father[u]].<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="built_in">find_father</span>(u,<span class="number">-1</span>);</span><br><span class="line">        pre_ans = <span class="built_in">find_heaviest</span>(u,father[u]);</span><br><span class="line">        cout&lt;&lt;pre_ans&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">5</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        node temp = <span class="built_in">find_minw_minindex</span>(u,father[u]);</span><br><span class="line">        pre_ans = temp.index;</span><br><span class="line">        cout&lt;&lt;pre_ans&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">6</span>)&#123;</span><br><span class="line">        cin&gt;&gt;u;</span><br><span class="line">        u = <span class="built_in">change</span>(u);</span><br><span class="line">        <span class="built_in">find_father</span>(u,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">            g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;w[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">find_father</span>(now_root,<span class="number">-1</span>);</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        pre_ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            cin&gt;&gt;op;</span><br><span class="line">            <span class="built_in">solve</span>(op);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="贝壳统计（shell）"><a href="#贝壳统计（shell）" class="headerlink" title="贝壳统计（shell）"></a>贝壳统计（shell）</h3><p>这题。。。。80分带修莫队板子题。后面插入元素的改了半天都会超时，不懂怎么改。只拿了80分。</p><p>一开始直接暴力做能拿40分。我看这1e5的数据，两维数组都开不了，也没办法记忆化，就想起来了之前看过的快慢指针，我拿两个指针来回记录时间应该会小一点，很遗憾还是40分。我看着我写的<code>pre_l--</code>和<code>pre_r++</code>越看越熟悉，，，这不就是莫队吗？？？？！！！还好这比赛让带U盘，然后我点开里面的模版（赛前都没看过，不知道从哪里下的了都），直接目录直达带修莫队，ubuntu里复制pdf里代码到vscode里缩进都没了，我也没管，粘过来改改变量名称直接就拿了80分。</p><p>第二天题解讲的是线段树什么的维护增加位置的个数，把添加的数改为负数，还没插入的为负数不用管，好像有点道理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e5</span>+<span class="number">1e4</span>+<span class="number">15</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[mxlen*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> block = <span class="number">2589</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span>&#123;</span><br><span class="line">    <span class="type">int</span> id,l,r,t;</span><br><span class="line">&#125;q[mxlen];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Modify</span>&#123;</span><br><span class="line">    <span class="type">int</span> pos,col,lst;</span><br><span class="line">&#125;c[mxlen];</span><br><span class="line"><span class="type">int</span> cnt[mxlen];</span><br><span class="line"><span class="type">int</span> bi[mxlen];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Query &amp;a, <span class="type">const</span> Query &amp;b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> al = bi[a.l], ar = bi[a.r];</span><br><span class="line"><span class="type">int</span> bl = bi[b.l], br = bi[b.r];</span><br><span class="line"><span class="keyword">if</span>(al != bl)<span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line"><span class="keyword">if</span>(ar != br)<span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line"><span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[x] == <span class="number">0</span>)res ++ ;</span><br><span class="line">cnt[x] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">cnt[x] -- ;</span><br><span class="line"><span class="keyword">if</span>(cnt[x] == <span class="number">0</span>)res -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mq = <span class="number">0</span>,mc = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans[mxlen];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> res)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(res&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">res=-res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(res&gt;<span class="number">9</span>)</span><br><span class="line"><span class="built_in">write</span>(res/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(res%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modui</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">    bi[i] = (i - <span class="number">1</span>) / block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + mq, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> k = <span class="number">1</span>, i = <span class="number">0</span>, j = <span class="number">1</span>, t = <span class="number">0</span>, res = <span class="number">0</span>; k &lt;= mq; ++ k)&#123;</span><br><span class="line">        <span class="type">int</span> id = q[k].id, l = q[k].l, r = q[k].r, tim = q[k].t;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; r)res += ++ cnt[a[ ++ i]] == <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; r)res -= -- cnt[a[i -- ]] == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; l)res -= -- cnt[a[j ++ ]] == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &gt; l)res += ++ cnt[a[ -- j]] == <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//再处理y轴</span></span><br><span class="line">    <span class="keyword">while</span>(t &lt; tim)&#123;</span><br><span class="line">    t ++ ;</span><br><span class="line">    <span class="keyword">if</span>(c[t].pos &gt;= j &amp;&amp; c[t].pos &lt;= i)&#123;</span><br><span class="line">    <span class="built_in">del</span>(a[c[t].pos], res);</span><br><span class="line">    <span class="built_in">add</span>(c[t].col, res);</span><br><span class="line">    <span class="comment">//res -= !--cnt[w[c[t].pos]] - !cnt[c[t].col]++;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[c[t].pos], c[t].col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t &gt; tim)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c[t].pos &gt;= j &amp;&amp; c[t].pos &lt;= i)&#123;</span><br><span class="line">    <span class="built_in">del</span>(a[c[t].pos], res);</span><br><span class="line">    <span class="built_in">add</span>(c[t].col, res);</span><br><span class="line">    <span class="comment">//res -= !--cnt[w[c[t].pos]] - !cnt[c[t].col]++;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[c[t].pos], c[t].col);</span><br><span class="line">    t -- ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[id] = res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=mq;i++)&#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i]), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_large</span><span class="params">(<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> L,R;</span><br><span class="line">        cin&gt;&gt;L&gt;&gt;R;</span><br><span class="line">        q[++mq] = (Query)&#123;mq,L,R,mc&#125;;        </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> P,V;</span><br><span class="line">        cin&gt;&gt;P&gt;&gt;V;</span><br><span class="line">        c[++mc] = (Modify)&#123;P,V&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">modui</span>();</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        mq = <span class="number">0</span>;</span><br><span class="line">        mc = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> P,V;</span><br><span class="line">        cin&gt;&gt;P&gt;&gt;V;</span><br><span class="line">        n++;</span><br><span class="line">       a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+P,V);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1e4</span>)&#123;</span><br><span class="line">        <span class="built_in">solve_large</span>(op);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> L,R;</span><br><span class="line">        cin&gt;&gt;L&gt;&gt;R;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=L;i&lt;=R;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[a[i]])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                vis[a[i]]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> P,V;</span><br><span class="line">        cin&gt;&gt;P&gt;&gt;V;</span><br><span class="line">        a[P] = V;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> P,V;</span><br><span class="line">        cin&gt;&gt;P&gt;&gt;V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        a.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            a.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            cin&gt;&gt;op;</span><br><span class="line">            <span class="built_in">solve</span>(op);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">1e4</span>&amp;&amp;op!=<span class="number">3</span>) <span class="built_in">modui</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>后两题真的折磨，光输入都差不多写了100多行，然而就只拿到了10分，这里就不贴代码了。我觉得要是平时写过系统相关的代码应该很快能写出来，我看有人很快就写完了。我调了半天真的有点崩溃了，看了看排行榜感觉再努力也进不了金牌了，还是早早收场就提前出来了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后是拿了290分，差十分银。这次可以说是大意失荆州——骄兵必败了。六点半的时候还排在银奖队伍中前部位，因为七点后就封傍了，我觉得就算有人后面写出来后两题也不至于把我退到铜吧（请不要学我。。。）。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4870 概率DP</title>
      <link href="/2024/10/15/HDU-4870-%E6%A6%82%E7%8E%87DP/"/>
      <url>/2024/10/15/HDU-4870-%E6%A6%82%E7%8E%87DP/</url>
      
        <content type="html"><![CDATA[<h1 id="HDU-4870-概率DP"><a href="#HDU-4870-概率DP" class="headerlink" title="HDU 4870 概率DP"></a>HDU 4870 概率DP</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=4870">Problem Link</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>新账号打rank，rank从0开始，打到1000分结束。每场rank增加50的概率为p，否则rank-100。新人用两个信号去打，每次用rank值低的账号，问任意一个账号达到rank1000分，新人要打的期望场数。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p><a href="https://www.cnblogs.com/philo-zhou/p/11330699.html">参考博客</a></p><p>将分数离散为赢了加1分，输了减2分。用<code>dp[i]</code>表示从i-1分到i分需要打的期望场数。</p><p>每次比赛有两种情况，一是p概率赢了加1分，二是(1-p)概率输了减2分。</p><p><code>dp[i]=1*p+(1-p)(1+dp[i-2]+dp[i-1]+dp[i])</code></p><p>期望等于所有情况乘以概率的和。</p><ul><li>一场就赢了，则是<code>1*p</code></li><li>一场输了，则需要<code>(1+dp[i-2]+dp[i-1]+dp[i])</code>场才能赢回来。其中1是输了这场，然后从<code>i-3</code>打到<code>i-2</code>,从<code>i-2</code>打到<code>i-1</code>，从<code>i-1</code>打到<code>i</code>分。</li></ul><p>化简得</p><p><code>dp[i]=(1+(1-p)*(dp[i-2]+dp[i-1]))/p</code></p><p><code>dp[1] = 1/p, dp[2] = 1/p/p</code></p><p>注意，因为最低分是0分，所以计算<code>dp[1]</code>和<code>dp[2]</code>的时候公式里填0补充。</p><p>用<code>tot</code>记录每一分需要的场数，因为有两个账号，且每次都是用分数低的，所以最后一定是一个账号1000分，另一个账号950分。我们计算两个账号都是1000分需要的场数，即<code>tot*2</code>，然后减去一个950分到1000分的期望场数(<code>dp[20]</code>)，即是答案。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">25</span>;</span><br><span class="line"><span class="type">double</span> dp[mxlen];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> p;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;p)!=EOF)&#123;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>/p;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>/p/p;</span><br><span class="line">        <span class="type">double</span> tot = dp[<span class="number">1</span>]+dp[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">20</span>;i++)&#123;</span><br><span class="line">            dp[i] = (<span class="number">1</span>+(<span class="number">1</span>-p)*(dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]))/p;</span><br><span class="line">            tot += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>,<span class="number">2</span>*tot-dp[<span class="number">20</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1024 M子段和最大</title>
      <link href="/2024/10/12/HDU-1024-M%E5%AD%90%E6%AE%B5%E5%92%8C%E6%9C%80%E5%A4%A7/"/>
      <url>/2024/10/12/HDU-1024-M%E5%AD%90%E6%AE%B5%E5%92%8C%E6%9C%80%E5%A4%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="M子段和最大问题"><a href="#M子段和最大问题" class="headerlink" title="M子段和最大问题"></a>M子段和最大问题</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1024">Problem Link</a></p><p>Given an array and divide into m sequences. One sequences at least has one number and the sequences can’t contain the number with same index. And the index of the numbers in one sequence should be continuous. Notice that we don’t have to use all the numbers.</p><p>N between 1 to 1e6.</p><h2 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="SOLUTION"></a>SOLUTION</h2><p><strong><code>Dynamic programming</code></strong>. </p><p>Let <code>d[i][j]</code> denote the maximum sum of the current array that is divided into i segments and the last segment ends with the jth number. </p><p>When comes to the jth number, we have two options. One is the jth number to be a new segments, the other is to add it to the back of the last segment which ends with (j-1)th number.</p><p>So the transfer equation is <code>dp[i][j]=max(pre_max+a[j],dp[i][j-1]+a[j])</code>. <code>pre_max</code> represents to the maximum answer that the pre array divided into <code>i-1</code> segments.</p><p><a href="https://blog.csdn.net/winter2121/article/details/72848482">Reference blog</a></p><p><img src="https://images.whff521.top/hdu-1024.jpg" alt="Reference Image"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll dp[mxlen];</span><br><span class="line">ll a[mxlen];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="comment">// 用memset会超时</span></span><br><span class="line">        <span class="comment">//memset(dp,0,sizeof(dp));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            ll pre = dp[i<span class="number">-1</span>];</span><br><span class="line">            ll pre_max = -inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n-m+i;j++)&#123;</span><br><span class="line">                pre_max = <span class="built_in">max</span>(pre_max,pre);</span><br><span class="line">                pre = dp[j];</span><br><span class="line">                <span class="keyword">if</span>(j!=i) dp[j] = <span class="built_in">max</span>(pre_max,dp[j<span class="number">-1</span>])+a[j];</span><br><span class="line">                <span class="keyword">else</span> dp[j] = pre_max+a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = -inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m;i&lt;=n;i++)&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 子段和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1029 寻找数列主元素</title>
      <link href="/2024/10/08/HDU-1029-%E5%AF%BB%E6%89%BE%E6%95%B0%E5%88%97%E4%B8%BB%E5%85%83%E7%B4%A0/"/>
      <url>/2024/10/08/HDU-1029-%E5%AF%BB%E6%89%BE%E6%95%B0%E5%88%97%E4%B8%BB%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="寻找数列主元素"><a href="#寻找数列主元素" class="headerlink" title="寻找数列主元素"></a>寻找数列主元素</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1029">Problem link</a></p><p>Finding a integer that appears at least (N+1)/2 times in the array.</p><h2 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h2><p>The <strong>Boyer-Moore Voting Algorithm</strong> (Moore’s Voting Algorithm) is a highly efficient method to find the majority element in a sequence (an element that appears more than half the time). It operates in <strong>O(n) time</strong> and uses <strong>O(1) space</strong>.</p><h3 id="Key-Idea"><a href="#Key-Idea" class="headerlink" title="Key Idea:"></a>Key Idea:</h3><p>The algorithm works by maintaining a <strong>candidate</strong> for the majority element and a <strong>counter</strong> to track its occurrences. It leverages a “pairing” or “cancellation” mechanism to eliminate non-majority elements.</p><h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps:"></a>Steps:</h3><ol><li><strong>Initialize</strong>:<ul><li>Set the <code>candidate</code> to <code>None</code> and the <code>count</code> to <code>0</code>.</li></ul></li><li><strong>First Pass (Finding the Candidate)</strong>:<ul><li>Traverse the array:<ul><li>If <code>count == 0</code>, set the current element as the <code>candidate</code> and set <code>count = 1</code>.</li><li>If the current element matches the <code>candidate</code>, increment <code>count</code>.</li><li>If the current element differs from the <code>candidate</code>, decrement <code>count</code>.</li></ul></li></ul></li><li><strong>Second Pass (Validation)</strong>:<ul><li>After completing the first pass, the <code>candidate</code> is the potential majority element. To confirm, traverse the array again and count the occurrences of the <code>candidate</code>. If it appears more than half the time, it is the majority element; otherwise, there is no majority element.</li></ul></li></ol><h3 id="Time-and-Space-Complexity"><a href="#Time-and-Space-Complexity" class="headerlink" title="Time and Space Complexity:"></a>Time and Space Complexity:</h3><ul><li><strong>Time Complexity</strong>: O(n) – two passes through the array.</li><li><strong>Space Complexity</strong>: O(1) – constant space is used for the <code>candidate</code> and <code>count</code>.</li></ul><h3 id="Key-Reasons-for-its-Effectiveness"><a href="#Key-Reasons-for-its-Effectiveness" class="headerlink" title="Key Reasons for its Effectiveness:"></a>Key Reasons for its Effectiveness:</h3><h4 id="1-Majority-Element-Dominates"><a href="#1-Majority-Element-Dominates" class="headerlink" title="1. Majority Element Dominates:"></a>1. <strong>Majority Element Dominates</strong>:</h4><p>If there is a majority element, it must appear <strong>more than half</strong> the time in the array. Let’s say the majority element is <code>M</code>, and the number of occurrences of <code>M</code> is greater than half of the total elements in the array (i.e., <code>count(M) &gt; n/2</code>). </p><p>In any process of matching pairs of elements, <code>M</code> will never be fully canceled out because it occurs more frequently than any other element.</p><h4 id="2-Cancellation-Process"><a href="#2-Cancellation-Process" class="headerlink" title="2. Cancellation Process:"></a>2. <strong>Cancellation Process</strong>:</h4><p>During the first pass, the algorithm essentially “cancels out” elements that are different from each other by using the <code>count</code> to increase and decrease based on whether an element matches the current candidate.</p><ul><li>Every time an element that is <strong>not the candidate</strong> is encountered, the <code>count</code> is decreased, effectively <strong>canceling out</strong> both the current candidate and the opposing element.</li><li>When the <code>count</code> reaches zero, a new candidate is chosen. This new candidate can still be the majority element or a temporary placeholder if more occurrences of the majority element appear later.</li></ul><p>This step ensures that elements that appear fewer times will eventually be canceled out by the majority element.</p><h4 id="3-Why-the-Majority-Element-Survives"><a href="#3-Why-the-Majority-Element-Survives" class="headerlink" title="3. Why the Majority Element Survives:"></a>3. <strong>Why the Majority Element Survives</strong>:</h4><p>The majority element will <strong>not be canceled out completely</strong> because it appears more than half the time. Even though other elements may reduce the <code>count</code> temporarily, the majority element’s higher frequency ensures that it will eventually remain as the candidate by the end of the first pass.</p><h3 id="Example-Walkthrough"><a href="#Example-Walkthrough" class="headerlink" title="Example Walkthrough:"></a>Example Walkthrough:</h3><p>Consider an array <code>[2, 2, 1, 1, 1, 2, 2]</code>:</p><ol><li>Initial <code>candidate = None</code>, <code>count = 0</code>.</li><li>First element <code>2</code>: <code>count == 0</code>, so <code>candidate = 2</code>, <code>count = 1</code>.</li><li>Second element <code>2</code>: <code>candidate == 2</code>, <code>count = 2</code>.</li><li>Third element <code>1</code>: <code>candidate != 1</code>, <code>count = 1</code>.</li><li>Fourth element <code>1</code>: <code>candidate != 1</code>, <code>count = 0</code>.</li><li>Fifth element <code>1</code>: <code>count == 0</code>, so <code>candidate = 1</code>, <code>count = 1</code>.</li><li>Sixth element <code>2</code>: <code>candidate != 2</code>, <code>count = 0</code>.</li><li>Seventh element <code>2</code>: <code>count == 0</code>, so <code>candidate = 2</code>, <code>count = 1</code>.</li></ol><p>After this, <code>candidate = 2</code>. In the verification step, <code>2</code> appears 4 times, which is more than <code>n/2 = 3.5</code>, confirming it is the majority element.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>This problem guarantees that there will be an answer. So we don’t need the step of check.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        ll x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">                ans = x;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans==x)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摩尔投票法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1465 (错位排列问题)</title>
      <link href="/2024/09/23/HDU-1465-%E9%94%99%E4%BD%8D%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/"/>
      <url>/2024/09/23/HDU-1465-%E9%94%99%E4%BD%8D%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Derangement-Problem"><a href="#Derangement-Problem" class="headerlink" title="Derangement Problem"></a>Derangement Problem</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1465">problem link</a></p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>You have <code>n</code> letters, each with a different recipient. However, all the letters are delivered to the wrong recipients, meaning no one receives the letter intended for them. You need to determine how many possible ways this can happen.</p><p>This problem can be simplified to a case where you have an array of numbers from 1 to n. For each position in the array(starting from index 1), the number in that position is different from its index. The goal is to count how many such arrangement exist.</p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>This is a classic <strong>derangement</strong> problem. You can find a more detailed explanation on <a href="https://oi-wiki.org/math/combinatorics/derangement/">oi-wiki</a> and <a href="https://en.wikipedia.org/wiki/Derangement">wikipedia</a>.</p><p>I solved the problem using a recursive approach. Let<code>D[i]</code>represent the number of derangements when <code>n = i</code>. The recursive formula is: <code>D[i]=(i-1)D[i-1]+(i-1)D[i-2]</code>.</p><p>Here’s an explanation of the formula:</p><p>Assume we already know the answers for <code>i-1</code>. Now, we add the <code>i-th</code> number to the sequence in the <code>i-th</code> position. Since the number in each position must differ from the position itself, we need to swap <code>i</code> with a number in the previous positions. The first case is where all of the previous <code>i-1</code> numbers are already deranged, so we can swap <code>i</code> with any of them, giving us <code>(i-1)D[i-1]</code> possibilities. The second case is where <code>i-2</code> numbers are deranged, but one number matches its index. In this case, we swap <code>i</code> with that number, which gives us <code>(i-1)D[i-2]</code> possibilities.</p><p><img src="https://images.whff521.top/Dislocation.jpg" alt="dislocation"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll a[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;=<span class="number">20</span>;i++)&#123;</span><br><span class="line">        a[i] = (i<span class="number">-1</span>)*(a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 错位排列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes of Lecture 23: Computational Complexity</title>
      <link href="/2024/09/21/Notes-of-Lecture-23-Computational-Complexity/"/>
      <url>/2024/09/21/Notes-of-Lecture-23-Computational-Complexity/</url>
      
        <content type="html"><![CDATA[<h1 id="Notes-of-Lecture-23-Computational-Complexity"><a href="#Notes-of-Lecture-23-Computational-Complexity" class="headerlink" title="Notes of Lecture 23: Computational Complexity"></a>Notes of Lecture 23: Computational Complexity</h1><p><a href="https://youtu.be/moPtwq_cVH8?si=u92BMoXF0Yqg1YH5">video link</a></p><h2 id="P-EXP-R"><a href="#P-EXP-R" class="headerlink" title="P,EXP,R"></a>P,EXP,R</h2><p>P = {problems solvable in at most(&lt;=) polynomial time}</p><p>EXP = {problems solvable in exponential(2^$n^c$) time}</p><p>R = {problems solvable in finite time}</p><p><img src="https://images.whff521.top/PEXPR.png" alt="P,EXP,R"></p><p>The axis is computational difficulty.</p><h2 id="Most-problems-uncomputable"><a href="#Most-problems-uncomputable" class="headerlink" title="Most problems uncomputable"></a>Most problems uncomputable</h2><p>Examples:</p><ul><li>negative-weight cycle detection (P)</li><li>NxN Chess (EXP&amp;!P)</li><li>Tetris (EXP, don’t know whether is P)</li><li>halting problem: given program, does it ever halt/stop? (not in R)</li></ul><p>Most decision problems are uncomputable (not in R)</p><ul><li>program $\approx$ binary string $\approx$ natural number (integer)</li><li>decision problem = function : input($\approx$ binary string (N)) -&gt;{yes(1),no(0)}</li></ul><p>So decision problem is in $\mathbb{R}$;</p><p>$|\mathbb{R}|$ &gt;&gt; $|\mathbb{N}|$ =&gt; almost every problem unsolvable by any program</p><h2 id="NP"><a href="#NP" class="headerlink" title="NP"></a>NP</h2><p>NP = {decision problems solvable in polynomial time via a “lucky” algorithm}</p><ul><li><p>nondeterministic model : algorithm makes guesses &amp; says YES/NO.</p></li><li><p>guesses are guaranteed to lead to “YES” if possible </p></li><li><p>Tetris is NP</p></li></ul><p>proof = sequence of moves to make</p><p>NP = {decision problems with “solutions” that can be “checked” in polynomial time}</p><ul><li>When answer = YES, can prove it &amp; check proof in polynomial time.</li></ul><h2 id="Hardness-amp-Completeness"><a href="#Hardness-amp-Completeness" class="headerlink" title="Hardness &amp; Completeness"></a>Hardness &amp; Completeness</h2><p>P!=NP : big conjecture $\approx$ “can’t engineer luck” $\approx$ generating (proofs of) solutions can be harder than checking them.</p><p>Claim: if P!=NP then Tetris is NP-P =&gt; not in P.</p><p>Why? Tetris is NP-hard(as hard as every problem which is NP)</p><ul><li>in fact Tetris is NP-complete = NP $\cap$ NP-hard</li></ul><p><img src="https://images.whff521.top/NPwholeAxis.png" alt="whole axis"></p><h2 id="Reductions"><a href="#Reductions" class="headerlink" title="Reductions"></a>Reductions</h2><p>Reductions: A -&gt; B</p><p>convert problem A(don’t know how to solve) into problem B(you know how to solve)</p><ul><li><p>unweighted shortest paths -&gt; weighted shortest paths</p></li><li><p>min-product path -&gt; shortest path</p></li><li><p>longest path -&gt; shortest path</p></li></ul><p>B is as hard ad A</p><p>3- partition [Karp] -&gt; Tetris</p>]]></content>
      
      
      <categories>
          
          <category> 摘抄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1085 multiple knapsack problem</title>
      <link href="/2024/09/19/HDU-1085-multiple-knapsack-problem/"/>
      <url>/2024/09/19/HDU-1085-multiple-knapsack-problem/</url>
      
        <content type="html"><![CDATA[<h1 id="Multiple-Knapsack-Problem"><a href="#Multiple-Knapsack-Problem" class="headerlink" title="Multiple Knapsack Problem"></a>Multiple Knapsack Problem</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1085">problem link</a></p><h2 id="The-Meaning-of-the-problem"><a href="#The-Meaning-of-the-problem" class="headerlink" title="The Meaning of the problem"></a>The Meaning of the problem</h2><p>You have three kinds of coins. Their face values are 1,2 and 5. Of cause you only have a limited number of coins. You need to find the minimum value that you can’t represent exactly with these coins.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>There are  lots of people solve this problem using Generating function. That way is too hard to understand. We just need to think of this problem as a multiple knapsack problem.</p><p>I learned from <a href="https://seramasumi.github.io/docs/Algorithms/mc-%E5%BE%AE%E8%AF%BE%E5%A0%82-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html">this blog</a></p><p><code>dp[j] = 1</code> means that <code>j</code> value can be represent by the coins.</p><p>Set <code>dp[0] = 1</code> initially. And the transfer equation is <code>dp[j] = max(dp[j],dp[j-k*money[i]])</code></p><p>Let’s assume there is only one 1 yuan coin, one 2 yuan coin and one 5 yuan coin. When <code>d[j]</code> need changing, we should see whether <code>d[j-value]</code> can be represent.</p><p>The top row of the table shows the total amount of money. The leftmost column of the table shows the face value of the coins.</p><p>Here’s the picture to show how the sequence is changed.</p><p><img src="https://images.whff521.top/Screenshot%202024-09-19%20at%2020.29.36.png" alt="knapsack sheet"></p><p>The top row of the table shows the total amount of money. The leftmost column of the table shows the face value of the coins.</p><p>The answer is <code>i</code> where <code>dp[i] = 0</code>.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[mxlen];</span><br><span class="line"><span class="type">int</span> num[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> money[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n1,n2,n5;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;num[<span class="number">1</span>],&amp;num[<span class="number">2</span>],&amp;num[<span class="number">3</span>]);        </span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;num[<span class="number">2</span>]==<span class="number">0</span>&amp;&amp;num[<span class="number">3</span>]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> sum = num[<span class="number">1</span>]+<span class="number">2</span>*num[<span class="number">2</span>]+<span class="number">5</span>*num[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 多重背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 倒序是因为我们转移需要上一层的数据，正序的话会改变值从而后面的值更新错误</span></span><br><span class="line">            <span class="comment">// 因为实际上这是用一维数组代替二维数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=money[i];j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k*money[i]&lt;=j&amp;&amp;k&lt;=num[i];k++)&#123;</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j],dp[j-k*money[i]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = sum+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=sum;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[i]) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多重背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1025 longest increasing subsequence</title>
      <link href="/2024/09/17/HDU-1025-longest-increasing-subsequence/"/>
      <url>/2024/09/17/HDU-1025-longest-increasing-subsequence/</url>
      
        <content type="html"><![CDATA[<h1 id="Constructing-Roads-In-JGShining’s-Kingdom"><a href="#Constructing-Roads-In-JGShining’s-Kingdom" class="headerlink" title="Constructing Roads In JGShining’s Kingdom"></a>Constructing Roads In JGShining’s Kingdom</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1025">problem link</a></p><h2 id="The-meaning-of-the-problem"><a href="#The-meaning-of-the-problem" class="headerlink" title="The meaning of the problem"></a>The meaning of the problem</h2><p>So why this is longest increasing subsequence Problem ? Look at the picture below:</p><p><img src="https://images.whff521.top/hdu1025.jpg" alt="hdu1025"></p><p>As the problem described, we can’t have crossed lines. Each line has two endpoints. One is the “rich” endpoint above and the other is the “poor” endpoint below. The rich endpoints’ number of the lines we finally pick up should be <strong>monotonically increasing</strong>. The corresponding poor endpoints should be <strong>monotonically increasing</strong> too. Otherwise the lines will be crossed.</p><p>Let’s use <strong><code>a[p]=q</code> to represent that the p city can link q city</strong>. Then the problem tend to become a question of longest increasing subsequence.</p><h2 id="The-Algorithm"><a href="#The-Algorithm" class="headerlink" title="The Algorithm"></a>The Algorithm</h2><p>There is a quite easy way to understand the LIS problem. I learned it from <a href="https://leetcode.cn/problems/longest-increasing-subsequence/solutions/13118/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/">this tutorial</a></p><blockquote><p>A clever approach. Create a new array <code>cell</code> to store the longest increasing subsequence.  </p><p>Iterate through the original sequence, and binary insert each element into <code>cell</code>.</p><p>If all the elements in <code>cell</code> are smaller than the current one, append it at the end.<br>Otherwise, <strong>replace the smallest element in <code>cell</code> that is larger than the current one</strong>.<br>In short, the idea is to keep <code>cell</code> storing relatively smaller elements. Although <code>cell</code> may not represent the actual longest increasing subsequence, its length is correct.</p><p>Author: ColdMe<br>Link: <a href="https://leetcode.cn/problems/longest-increasing-subsequence/solutions/13118/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/">https://leetcode.cn/problems/longest-increasing-subsequence/solutions/13118/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-e/</a><br>Source: LeetCode<br>Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please credit the source.</p></blockquote><p>There are ways to prove that the <code>cell</code> array is monotonically increasing. Anything detailed you can see <a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence">Wikipedia</a></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> seq[mxlen];</span><br><span class="line"><span class="type">int</span> a[mxlen];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            a[x]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(seq,<span class="number">0</span>,<span class="built_in">sizeof</span>(seq));</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;seq[len])&#123;</span><br><span class="line">                seq[++len] = a[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> l=<span class="number">1</span>,r=len;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">                    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(seq[mid]&gt;=a[i]) r = mid<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                seq[l] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// When the number of roads is greater than 2, an s needs to be added after the road.</span></span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\nMy king, at most 1 road can be built.\n\n&quot;</span>,++cnt);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\nMy king, at most %d roads can be built.\n\n&quot;</span>,++cnt,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最长上升子序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1023 Train Problem II 高精度卡特兰数</title>
      <link href="/2024/09/16/HDU-1023-Train-Problem-II-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
      <url>/2024/09/16/HDU-1023-Train-Problem-II-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="High-precision-Catalan-number"><a href="#High-precision-Catalan-number" class="headerlink" title="High-precision Catalan number"></a>High-precision Catalan number</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1023">problem link</a></p><p>This is a classic problem of finding the number of stack push ans pop sequences. The only headache is that it requires high precision.</p><h2 id="How-to-determine-whether-it-is-a-Catalan-number"><a href="#How-to-determine-whether-it-is-a-Catalan-number" class="headerlink" title="How to determine whether it is a Catalan number"></a>How to determine whether it is a Catalan number</h2><p>For a more detailed introduction to the Catalan number,see <a href="https://oi-wiki.org/math/combinatorics/catalan/">oi-wiki</a> and <a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0">wikipedia</a></p><p>I think there is another simple way to judge, which is to see whether the first few numbers are consistent with the Catalan number. If they are the same, then it is likely to be a correct guess.</p><p><img src="https://images.whff521.top/catalan.png" alt="截图来自oi-wiki"></p><h2 id="Algortithm-Implementation"><a href="#Algortithm-Implementation" class="headerlink" title="Algortithm Implementation"></a>Algortithm Implementation</h2><p>We use <code>catalan[i][j]</code> to represent the j-th digital of the i-th Catalan number. </p><p>The formula I use is <code>h(n) = (4n-2)*h(n-1)/(n+1)</code>.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> catalan[<span class="number">105</span>][mxlen];</span><br><span class="line"><span class="comment">// catalan[i][j] stores the j-th digit of the i-th catalan number</span></span><br><span class="line"><span class="comment">// h(n) = (4n-2)*h(n-1)/(n+1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    catalan[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;mxlen;j++)&#123;</span><br><span class="line">            tmp+=catalan[i<span class="number">-1</span>][j]*(<span class="number">4</span>*i<span class="number">-2</span>);</span><br><span class="line">            catalan[i][j] = tmp%<span class="number">10</span>;</span><br><span class="line">            tmp/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mxlen is big enough, so tmp will be 0 after the loop</span></span><br><span class="line">        j=mxlen<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(catalan[i][j]==<span class="number">0</span>) j--;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            tmp = tmp*<span class="number">10</span>+catalan[i][j];</span><br><span class="line">            catalan[i][j--] = tmp/(i+<span class="number">1</span>);  </span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;=i+<span class="number">1</span>) tmp%=(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Catalan number is a integer, so remain is 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pre_work</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="type">int</span> i = mxlen<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(catalan[n][i]==<span class="number">0</span>) i--;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,catalan[n][i--]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卡特兰数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1011 Starship Troopers 树形DP</title>
      <link href="/2024/09/13/HDU-1011-Starship-Troopers-%E6%A0%91%E5%BD%A2DP/"/>
      <url>/2024/09/13/HDU-1011-Starship-Troopers-%E6%A0%91%E5%BD%A2DP/</url>
      
        <content type="html"><![CDATA[<h1 id="答案会比你想象的简单很多"><a href="#答案会比你想象的简单很多" class="headerlink" title="答案会比你想象的简单很多"></a>答案会比你想象的简单很多</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1011">题目链接</a></p><p>这道题最大的障碍应该是猜对题意。。。题里说的“possibility”应该不是真正的相对于人数的概率，而是可以随意相加的数字，你可以直接当成获得这个数量的金币之类的。</p><p>树形迷宫，只要你能放置超过对应数量的士兵在这个节点，你就可以获得这个节点的“possibility”。同时你可以继续向这个节点的子节点进行进攻，你甚至可以兵分几路向下前进。这些被放置的士兵只能留在被放置的节点而不能重复利用。你一共有m个士兵，求出你可以获得的“possibility”的最大值。</p><h2 id="正向思考"><a href="#正向思考" class="headerlink" title="正向思考"></a>正向思考</h2><p>每当你占领一个节点，面临的就是你如何要用剩下的军队，分成几部分去这个节点的子节点。显然正向出发去求你并不知道到底怎样决策才能获得最大价值，因为你甚至还不知道接下来你会面临什么样的节点。</p><h2 id="反向思考"><a href="#反向思考" class="headerlink" title="反向思考"></a>反向思考</h2><p>这就要搬出和深搜常绑定的一个词——“回溯”。我们一路深搜到叶子节点，我们要从终点走到起点。面对只有一个节点，你当然知道你最少需要多少士兵，你最大能获得多少价值。我们用<code>dp[x][i]</code>表示第x节点用掉i个士兵获得的最大的价值。如果当前节点最少需要j个士兵，那么dp[x][j～m]的初始值就是当前节点的价值量。毕竟人少了不行，但是人多了是肯定可以的。</p><p>当两个叶子汇聚到一个父节点应该怎么转移呢？我们需要就将人分成两部分，一部分x个人给一个叶子，一部分y个人给另一个（或者另好几个）叶子，父节点用的人数就是<code>x+y+i</code>个人。因为我们已经知道了每个节点用多少人能够获得多少价值，我们可以枚举所有情况来进行更新最优解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> pre[mxlen*<span class="number">2</span>],last[mxlen],other[mxlen*<span class="number">2</span>],l;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    l++;</span><br><span class="line">    pre[l] = last[x];</span><br><span class="line">    last[x] = l;</span><br><span class="line">    other[l] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dp[mxlen][mxlen];</span><br><span class="line"><span class="type">bool</span> vis[mxlen];</span><br><span class="line"><span class="type">int</span> bugs[mxlen],brains[mxlen];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">    <span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="built_in">sizeof</span>(last));</span><br><span class="line">    <span class="built_in">memset</span>(other,<span class="number">0</span>,<span class="built_in">sizeof</span>(other));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 向上取整</span></span><br><span class="line">    <span class="type">int</span> needed = (bugs[x]+<span class="number">19</span>)/<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=needed;i&lt;=m;i++)&#123;</span><br><span class="line">        dp[x][i] = brains[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=last[x];p;p=pre[p])&#123;</span><br><span class="line">        <span class="type">int</span> y = other[p];</span><br><span class="line">        <span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = m;i&gt;=needed;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i-needed;j++)&#123;</span><br><span class="line">                <span class="comment">//第x节点消耗i个士兵能获得的最大价值</span></span><br><span class="line">                dp[x][i] = <span class="built_in">max</span>(dp[x][i],dp[x][i-j]+dp[y][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">-1</span>&amp;&amp;m==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">prepare</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;bugs[i],&amp;brains[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">add</span>(x,y);</span><br><span class="line">            <span class="built_in">add</span>(y,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        cout&lt;&lt;dp[<span class="number">1</span>][m]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深搜 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDOJ 1010 Tempter of the Bone 深搜&amp;剪枝</title>
      <link href="/2024/09/12/HDOJ-1010-Tempter-of-the-Bone-%E6%B7%B1%E6%90%9C-%E5%89%AA%E6%9E%9D/"/>
      <url>/2024/09/12/HDOJ-1010-Tempter-of-the-Bone-%E6%B7%B1%E6%90%9C-%E5%89%AA%E6%9E%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="细心和智慧并存的解答"><a href="#细心和智慧并存的解答" class="headerlink" title="细心和智慧并存的解答"></a>细心和智慧并存的解答</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1010">题目链接</a> </p><p>题的大致意思是能不能从起点经过T时间精准到达终点，图中有一些障碍不能走，走过的格子也不能再走。</p><p>其中数据是最大7*7的迷宫，最多50个迷宫。</p><h2 id="智慧之处——精准的剪枝"><a href="#智慧之处——精准的剪枝" class="headerlink" title="智慧之处——精准的剪枝"></a>智慧之处——精准的剪枝</h2><p>类似全排列的深搜时间复杂度是O(n!)，7*7的数据是过不去的。  </p><p>首先就是普通地剪枝：</p><ul><li>如果时间已经大于T，就不用再走了</li><li>如果已经有正确答案，要及时地退出搜索</li></ul><p>然后是奇偶剪枝，这里参考了<a href="https://blog.csdn.net/code_pang/article/details/8839432">其他博客</a>  </p><p>这里我重新画了一张图，如下：</p><p><img src="https://images.whff521.top/maze.jpg" alt="maze"></p><p>图中的S可以代表任何你走到的位置，不一定是起点。就如图中的红色和蓝色路径，这两条路径是最少需要的时间。如果剩余时间少于最短路径长度，那么是一定不能到达终点的。  </p><p>既然时间不够一定不能到达，时间刚好和剩余最少时间相等也能到达，那么还剩一种情况，就是时间大于剩余最少时间。这也应该是大概率会遇到的情况。根据题意我们只能在第T秒精准到达终点，我们时间多出来的怎么办呢？——我们需要在终点周围“<strong>徘徊</strong>”。  </p><p>如图中的绿色和黄色箭头所示，你比最短路径多走出来的路径，一定是先“出去”，再“回来”。多走的路径是“对称的”，那多出来的路径长度一定是偶数。  </p><p>这就是奇偶性剪枝。加上这个剪枝就能过所有的测试数据。</p><h2 id="细心之处——多数据下数组的重复利用"><a href="#细心之处——多数据下数组的重复利用" class="headerlink" title="细心之处——多数据下数组的重复利用"></a>细心之处——多数据下数组的重复利用</h2><p>尽管我写过无数个全排列暴力骗过不少10分、20分。但是在这道题上还是因为粗心而浪费了不少时间。  </p><p>在做杭电这前十道题的时候我就发现基本都是多数据的形式。所以除了输入会重新填入数据的数组外，其他数据都需要进行“<strong>初始化</strong>”。</p><p>但是即使我清空了<code>vis</code>数据，我发现代码运行的答案竟然是错误的（样例是能过的）。  </p><p>原因就是这道题毕竟不是全排列，vis数组不能只在dfs的for循环中去设置。<strong>你的起点在你走出第一步后就再也不能回来了</strong>。</p><p><code>vis[startX][startY]=true;</code></p><p>代码： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> mp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> n,m,T;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">string ans;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> startX,startY,endX,endY;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="string">&quot;YES&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(step&gt;T) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mp[x][y]==<span class="string">&#x27;D&#x27;</span>&amp;&amp;step==T)&#123;</span><br><span class="line">        ans = <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余时间小于到终点的最短距离</span></span><br><span class="line">    <span class="keyword">if</span>(T-step&lt;(<span class="built_in">abs</span>(x-endX)+<span class="built_in">abs</span>(y-endY)))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剩余时间剪去最短距离不是偶数</span></span><br><span class="line">    <span class="keyword">if</span>((T-step-(<span class="built_in">abs</span>(x-endX)+<span class="built_in">abs</span>(y-endY)))%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> nx = x+dx[i];</span><br><span class="line">        <span class="type">int</span> ny = y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(nx&gt;=<span class="number">1</span>&amp;&amp;nx&lt;=n&amp;&amp;ny&gt;=<span class="number">1</span>&amp;&amp;ny&lt;=m&amp;&amp;!vis[nx][ny]&amp;&amp;mp[nx][ny]!=<span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">            vis[nx][ny]=<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(nx,ny,step+<span class="number">1</span>);</span><br><span class="line">            vis[nx][ny]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;T);</span><br><span class="line">        <span class="keyword">if</span>(!n&amp;&amp;!m&amp;&amp;!T) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                cin&gt;&gt;mp[i][j];</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">                    startX=i;</span><br><span class="line">                    startY=j;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                    endX=i;</span><br><span class="line">                    endY=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">        <span class="comment">// vis记得清空</span></span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="comment">// 起点要标记为已访问 </span></span><br><span class="line">        vis[startX][startY]=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(startX,startY,<span class="number">0</span>);</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深搜 </tag>
            
            <tag> 剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDOJ 1007 Quoit Design 圆环设计</title>
      <link href="/2024/09/11/HDOJ-1007-Quoit-Design-%E5%9C%86%E7%8E%AF%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/09/11/HDOJ-1007-Quoit-Design-%E5%9C%86%E7%8E%AF%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一道经典的分治"><a href="#一道经典的分治" class="headerlink" title="一道经典的分治"></a>一道经典的分治</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1007">题目链接</a></p><p>题意是套圈游戏要设计一款尺寸最大的圆环，满足圆环不会一次套中两个物品。每个物品有一个摆放坐标。我们要求的是这些物品中相邻最近的两个物品之间的距离，这个距离就是我们要求的圆环的直径。  </p><p>这个类型网上常称为<code>寻找最近点对问题</code>。  </p><p>数据是十万（1e5），分治算法时间复杂度是<code>O(nlogn)</code>，刚好能够跑完。</p><p>分治的思想就是我们先将所有点按照横坐标从小到大排序，然后将点分成左右两部分，也就是图中的<code>L</code>和<code>R</code>区域，这样我们就可以分别求两边的距离最小值。当然在中间线的<code>mid</code>部分也是需要求距离的。</p><p>在算完两边的距离最小值<code>d</code>后，我们将中间线向左和向右扩展<code>d</code>长度，组成<code>mid</code>的领域。可以知道如果领域再扩大增加的点并不会形成更优的答案。这里需要注意，我们的<code>L</code>和<code>R</code>区域是以中间线为界，也就是说<code>mid</code>区域其实是叠加在两边区域之上的。</p><p><img src="https://images.whff521.top/fenzhi.jpg" alt="fenzhi"></p><p>虽然中间区域的点已经会排除掉一些点，但是直接用双重循环找最短距离会超时。这是因为如果点都在中间密集的话时间复杂度会接近<code>O(n*n)</code>。</p><p>所以我们需要把中间点按照<code>y</code>的从小到大排序，在循环中如果两点纵坐标之间的距离已经大于<code>d</code>的时候及时跳出循环，完成剪枝。在<a href="http://oi-wiki.com/geometry/nearest-points/">oi-wiki</a>中有证明，这里的满足条件的点不会超过7。</p><p>边界问题：自己与自己之间距离设置成足够大的值，如果区间只有两个点，则直接计算两点之间距离。</p><p><strong>PS: 函数命名不要用distance，会和C++库中函数重名而导致CE</strong> </p><p>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;points[mxlen];</span><br><span class="line"><span class="comment">// sort by x</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpx</span><span class="params">(node qw,node er)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(qw.x==er.x) <span class="keyword">return</span> qw.y&lt;er.y;</span><br><span class="line">    <span class="keyword">return</span> qw.x&lt;er.x;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort by y</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpy</span><span class="params">(node qw,node er)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(qw.y==er.y) <span class="keyword">return</span> qw.x&lt;er.x;</span><br><span class="line">    <span class="keyword">return</span> qw.y&lt;er.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// count the distance between two points</span></span><br><span class="line"><span class="comment">// name can not be distance, because there is a function named distance in cmath</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(node qw,node er)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((qw.x-er.x)*(qw.x-er.x)+(qw.y-er.y)*(qw.y-er.y));</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">node temp[mxlen];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="number">1e20</span>;</span><br><span class="line">    <span class="comment">// if there are only two points</span></span><br><span class="line">    <span class="keyword">if</span>(l+<span class="number">1</span>==r) <span class="keyword">return</span> <span class="built_in">dis</span>(points[l],points[r]);</span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">min</span>(<span class="built_in">solve</span>(l,mid),<span class="built_in">solve</span>(mid+<span class="number">1</span>,r));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort by y, otherwise the code will TLE</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid;i&gt;=l&amp;&amp;points[mid].x-points[i].x&lt;d;i--) temp[len++] = points[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=r&amp;&amp;points[i].x-points[mid].x&lt;d;i++) temp[len++] = points[i];</span><br><span class="line">    <span class="built_in">sort</span>(temp+<span class="number">1</span>,temp+len,cmpy);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len&amp;&amp;temp[j].y-temp[i].y&lt;d;j++)&#123;</span><br><span class="line">            d = <span class="built_in">min</span>(d,<span class="built_in">dis</span>(temp[i],temp[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;points[i].x,&amp;points[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(points+<span class="number">1</span>,points+n+<span class="number">1</span>,cmpx);</span><br><span class="line">        <span class="type">double</span> ans = <span class="built_in">solve</span>(<span class="number">1</span>,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,ans/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更有效地解决括号匹配问题</title>
      <link href="/2024/08/26/%E6%9B%B4%E6%9C%89%E6%95%88%E5%9C%B0%E8%A7%A3%E5%86%B3%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/26/%E6%9B%B4%E6%9C%89%E6%95%88%E5%9C%B0%E8%A7%A3%E5%86%B3%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>这是力扣上一道非常简单的问题，是经典的解决括号匹配问题。当然做法是用一个栈即可解决问题。<br><a href="https://leetcode.cn/problems/valid-parentheses/description/?envType=study-plan-v2&amp;envId=2024-spring-sprint-100">有效的括号</a></p><p>这是我的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="type">Character</span> <span class="variable">nowC</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(nowC==<span class="string">&#x27;(&#x27;</span>||nowC==<span class="string">&#x27;&#123;&#x27;</span>||nowC==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                st.push(nowC);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(st.empty())&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> st.pop();</span><br><span class="line">                <span class="keyword">if</span>((nowC==<span class="string">&#x27;)&#x27;</span>&amp;&amp;c!=<span class="string">&#x27;(&#x27;</span>)||(nowC==<span class="string">&#x27;]&#x27;</span>&amp;&amp;c!=<span class="string">&#x27;[&#x27;</span>)||(nowC==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp;c!=<span class="string">&#x27;&#123;&#x27;</span>))&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!st.empty()) flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显然我的代码是可以不费力的通过测试的。但是我还是去看了一眼题解。 </p><p>这是力扣官方题解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character, Character&gt; pairs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Character&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">            put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (pairs.containsKey(ch)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/valid-parentheses/solutions/373578/you-xiao-de-gua-hao-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></p><p>想必大家已经能够看到官方题解和我的代码有着一个明显的差别，那就是题解用了另一个数据结构——<code>Map</code>。  </p><p>用到<code>Map</code>的理由也是非常的简单，就是判断小括号，中括号，大括号匹配的时候，用<code>Map</code>的<code>key-value</code>一一对应能够完美解决。这里的操作看似画蛇添足，但是代码在拓展性上大大增强，只需要更改键值对的内容，就可以把代码扩展到任意匹配问题。  </p><p>还有一点值得一提，就是<code>java</code>中的<code>stack</code>实际上就是<code>vector</code>的一种。整体来看，双端队列能够实现栈的所有功能，且适用范围更加广泛，所以大多数定义栈的时候都会直接用<code>Deque</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 括号匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的免费图床方案</title>
      <link href="/2024/07/08/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A%E6%96%B9%E6%A1%88/"/>
      <url>/2024/07/08/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="博客的免费图床方案（Cloudflare-R2-PicGo）"><a href="#博客的免费图床方案（Cloudflare-R2-PicGo）" class="headerlink" title="博客的免费图床方案（Cloudflare R2 + PicGo）"></a>博客的免费图床方案（Cloudflare R2 + PicGo）</h1><p><a href="https://www.pseudoyu.com/zh/2024/06/30/free_image_hosting_system_using_r2_webp_cloud_and_picgo/">参考博客</a>  </p><p>这个博客写的已经非常详细清楚了，这里不再赘述实现步骤。  </p><p>这里记录一下我是怎么发现这篇博客的。  </p><p>在一个很无聊的时间段，我打开了<code>Inoreader</code>看RSS订阅的博客列表有没有更新，其中有一篇少数派的博客吸引了我，<a href="https://sspai.com/post/90223">是这个博客</a>。</p><p><img src="http://images.whff521.top/Screenshot%202024-07-08%20at%2020.10.44.png" alt="sspai">  </p><p>这里博主提到了<a href="https://x.com/pseudo_yu">他的推特账号</a>。其中很近的时间里他发布了上面提到的免费图床方案的博文。  </p><p>这篇博客解决了我正在苦恼的问题，那就是博文中图片的插入。如果是只有一个github pages的静态网站还好说，直接传在相对文件夹里即可。但是如果面对多平台，比如我还想在csdn中发布，那就变得很麻烦，因为markdown里写的相对路径将不可用，最直接的办法就是更改每个图片链接。  </p><p>然而如果是有自己的图床就很方便了，不用担心网络上的图片会突然失效，多平台发布也不用更改自己的截图路径。上方的图片就是用我自己实现的图库。  </p><p>事实上这个免费解决方案是相对于已经使用过CloudFlare和买过且用过域名的人看的。有一些点没有提及。首先你如果想用R2的话你最好有一张VISA卡进行账户的认证。还有对于公共的域名，如果想用自己的域名，首先这个域名的DNS的NameServer需要改成CloudFlare的，也就是说这里的自定义域名只能是在CloudFlare里进行代理的域名，当然有免费计划可以用。  </p><p>还有关于PicGo这个软件，对于Mac用户来说，你可能会遇到一个问题，就是安装后系统不让你打开并使用这个软件，系统会提示你把它扔进垃圾桶里，因为里面的证书不对。这里解决方案是<a href="https://youngjuning.js.org/bd534125c87e/?highlight=picgo#%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F">来自这个博客</a>  </p><p>终端输入：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xattr -r -d com.apple.quarantine 你的APP路径</span><br></pre></td></tr></table></figure></p><p>APP 路径的获取方法：</p><p>打开 “访达”（Finder）进入 “应用程序” 目录，找到该软件图标，将图标拖到终端窗口，最终的命令类似:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xattr -r -d com.apple.quarantine <span class="string">&#x27;/Applications/PicGo.app&#x27;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> 博客 </tag>
            
            <tag> 图床 </tag>
            
            <tag> PicGo </tag>
            
            <tag> Cloudflare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eloquent JavaScript 09 Exercises</title>
      <link href="/2024/06/22/Eloquent-JavaScript-09-Exercises/"/>
      <url>/2024/06/22/Eloquent-JavaScript-09-Exercises/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><a href="https://eloquentjavascript.net/09_regexp.html">To the book page</a>  </p><h2 id="Regexp-golf"><a href="#Regexp-golf" class="headerlink" title="Regexp golf"></a>Regexp golf</h2><p>注意这里如果写对的话，应该什么都不会输出。  </p><p>正则表达式中的<code>\b</code>是单词边界的标志，它用来匹配一个单词的边界。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill in the regular expressions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则表达式应该匹配“car”和“cat”，但不匹配其他字符串。</span></span><br><span class="line"><span class="title function_">verify</span>(<span class="regexp">/ca[rt]/</span>,</span><br><span class="line">       [<span class="string">&quot;my car&quot;</span>, <span class="string">&quot;bad cats&quot;</span>],</span><br><span class="line">       [<span class="string">&quot;camper&quot;</span>, <span class="string">&quot;high art&quot;</span>]);</span><br><span class="line"><span class="comment">// 正则表达式应该匹配“pop”和“prop”，但不匹配其他字符串。</span></span><br><span class="line"><span class="title function_">verify</span>(<span class="regexp">/pr?op/</span>,</span><br><span class="line">       [<span class="string">&quot;pop culture&quot;</span>, <span class="string">&quot;mad props&quot;</span>],</span><br><span class="line">       [<span class="string">&quot;plop&quot;</span>, <span class="string">&quot;prrrop&quot;</span>]);</span><br><span class="line"><span class="comment">// 正则表达式应该匹配“ferret”，“ferry”和“ferrari”，但不匹配其他字符串。</span></span><br><span class="line"><span class="title function_">verify</span>(<span class="regexp">/ferr(et|y|ari)/</span>,</span><br><span class="line">       [<span class="string">&quot;ferret&quot;</span>, <span class="string">&quot;ferry&quot;</span>, <span class="string">&quot;ferrari&quot;</span>],</span><br><span class="line">       [<span class="string">&quot;ferrum&quot;</span>, <span class="string">&quot;transfer A&quot;</span>]);</span><br><span class="line"><span class="comment">// 正则表达式应该匹配以“ious”结尾的任何单词。</span></span><br><span class="line"><span class="title function_">verify</span>(<span class="regexp">/\b\w*ious\b/</span>,</span><br><span class="line">       [<span class="string">&quot;how delicious&quot;</span>, <span class="string">&quot;spacious room&quot;</span>],</span><br><span class="line">       [<span class="string">&quot;ruinous&quot;</span>, <span class="string">&quot;consciousness&quot;</span>]);</span><br><span class="line"><span class="comment">// 正则表达式应该匹配空白字符后跟一个句号、逗号、冒号或分号。</span></span><br><span class="line"><span class="title function_">verify</span>(<span class="regexp">/\s[.,;:]/</span>,</span><br><span class="line">       [<span class="string">&quot;bad punctuation .&quot;</span>],</span><br><span class="line">       [<span class="string">&quot;escape the period&quot;</span>]);</span><br><span class="line"><span class="comment">// 正则表达式应该匹配长度大于六个字母的单词。</span></span><br><span class="line"><span class="title function_">verify</span>(<span class="regexp">/\b\w&#123;7,&#125;\b/</span>,</span><br><span class="line">       [<span class="string">&quot;Siebentausenddreihundertzweiundzwanzig&quot;</span>],</span><br><span class="line">       [<span class="string">&quot;no&quot;</span>, <span class="string">&quot;three small words&quot;</span>]);</span><br><span class="line"><span class="comment">// 正则表达式应该匹配不包含字母“e”或“E”的单词。</span></span><br><span class="line"><span class="title function_">verify</span>(<span class="regexp">/\b[a-df-zA-DF-Z]+\b/</span>,</span><br><span class="line">       [<span class="string">&quot;red platypus&quot;</span>, <span class="string">&quot;wobbling nest&quot;</span>],</span><br><span class="line">       [<span class="string">&quot;earth bed&quot;</span>, <span class="string">&quot;bedrøvet abe&quot;</span>, <span class="string">&quot;BEET&quot;</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">verify</span>(<span class="params">regexp, yes, no</span>) &#123;</span><br><span class="line">  <span class="comment">// Ignore unfinished exercises</span></span><br><span class="line">  <span class="keyword">if</span> (regexp.<span class="property">source</span> == <span class="string">&quot;...&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> str <span class="keyword">of</span> yes) <span class="keyword">if</span> (!regexp.<span class="title function_">test</span>(str)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Failure to match &#x27;<span class="subst">$&#123;str&#125;</span>&#x27;`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> str <span class="keyword">of</span> no) <span class="keyword">if</span> (regexp.<span class="title function_">test</span>(str)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Unexpected match for &#x27;<span class="subst">$&#123;str&#125;</span>&#x27;`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Quoting-style"><a href="#Quoting-style" class="headerlink" title="Quoting style"></a>Quoting style</h2><p>将句子中的单引号换成双引号，但是单词缩写不能变，比如“aren’t”  </p><p>这里调试了半天，因为我错误的将<code>|</code>写成中文的<code>｜</code>了。。。  </p><ul><li><code>(^|\W)</code>：匹配开头或非字母字符后面的单引号。</li><li><code>(\W|$)</code>：匹配单引号后面紧跟非字母字符或字符串结尾。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;&#x27;I&#x27;m the cook,&#x27; he said, &#x27;it&#x27;s my job.&#x27;&quot;</span>;</span><br><span class="line"><span class="comment">// Change this call.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(text.<span class="title function_">replace</span>(<span class="regexp">/(^|\W)&#x27;|&#x27;(\W|$)/g</span>,<span class="string">&#x27;$1&quot;$2&#x27;</span>));</span><br><span class="line"><span class="comment">// → &quot;I&#x27;m the cook,&quot; he said, &quot;it&#x27;s my job.&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Numbers-again"><a href="#Numbers-again" class="headerlink" title="Numbers again"></a>Numbers again</h2><p>为了编写一个匹配JavaScript风格数字的正则表达式，我们需要支持以下特性：</p><ul><li>可选的正负号</li><li>可选的十进制点</li><li>指数表示法（e或E），以及可选的正负号</li></ul><p>以下是我们可以遵循的步骤：</p><ol><li><strong>可选的正负号</strong>：<code>[+-]?</code></li><li><strong>整数和小数部分</strong>：<ul><li>整数部分：<code>\d*</code></li><li>小数部分：<code>\.\d+</code></li></ul></li><li><strong>指数部分</strong>：<code>e[+-]?\d+</code></li></ol><p>将这些部分组合在一起，我们得到一个正则表达式来匹配JavaScript风格的数字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="regexp">/^[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> str <span class="keyword">of</span> [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;-1&quot;</span>, <span class="string">&quot;+15&quot;</span>, <span class="string">&quot;1.55&quot;</span>, <span class="string">&quot;.5&quot;</span>, <span class="string">&quot;5.&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;1.3e2&quot;</span>, <span class="string">&quot;1E-4&quot;</span>, <span class="string">&quot;1e+12&quot;</span>]) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!number.<span class="title function_">test</span>(str)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Failed to match &#x27;<span class="subst">$&#123;str&#125;</span>&#x27;`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> str <span class="keyword">of</span> [<span class="string">&quot;1a&quot;</span>, <span class="string">&quot;+-1&quot;</span>, <span class="string">&quot;1.2.3&quot;</span>, <span class="string">&quot;1+1&quot;</span>, <span class="string">&quot;1e4.5&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;.5.&quot;</span>, <span class="string">&quot;1f5&quot;</span>, <span class="string">&quot;.&quot;</span>]) &#123;</span><br><span class="line">  <span class="keyword">if</span> (number.<span class="title function_">test</span>(str)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Incorrectly accepted &#x27;<span class="subst">$&#123;str&#125;</span>&#x27;`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li><code>^[+-]?</code>：匹配开头的可选正负号。</li><li><code>(\d+(\.\d*)?|\.\d+)</code>：匹配整数或小数部分。<ul><li><code>\d+(\.\d*)?</code>：匹配整数部分，后面跟着可选的小数部分。例如，<code>123</code>或<code>123.456</code>。</li><li><code>|\.\d+</code>：或者匹配只有小数点和小数部分。例如，<code>.456</code>。</li></ul></li><li><code>([eE][+-]?\d+)?</code>：匹配可选的指数部分。<ul><li><code>[eE]</code>：匹配<code>e</code>或<code>E</code>。</li><li><code>[+-]?</code>：匹配可选的正负号。</li><li><code>\d+</code>：匹配一或多个数字。</li></ul></li><li><code>$</code>：匹配字符串的结尾。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年Android项目实现高德导航</title>
      <link href="/2024/06/21/2024%E5%B9%B4Android%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%BE%B7%E5%AF%BC%E8%88%AA/"/>
      <url>/2024/06/21/2024%E5%B9%B4Android%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%BE%B7%E5%AF%BC%E8%88%AA/</url>
      
        <content type="html"><![CDATA[<h1 id="使用高德SDK实现导航功能"><a href="#使用高德SDK实现导航功能" class="headerlink" title="使用高德SDK实现导航功能"></a>使用高德SDK实现导航功能</h1><p><a href="https://blog.csdn.net/weixin_46974030/article/details/134059600">参考博客</a>  </p><p><a href="https://github.com/WHFF521/AMAP-Android-Navigation">Github仓库直达</a>  </p><p>这是今天企业实训的一个小作业，实际上我从昨天就开始尝试申请key然后下载官方Demo开始实验。本来是要做flutter项目，但是高德官方里flutter教程只有显示地图和定位功能，没有导航功能，导航功能官方只有Android的教程。今天也是用Android原生进行编写的。至于怎么整合到flutter项目里目前还不知道。。。</p><h2 id="1-官网下载SDK"><a href="#1-官网下载SDK" class="headerlink" title="1. 官网下载SDK"></a>1. 官网下载SDK</h2><p>我也尝试过直接gradle引入包的操作，但是直接引入的会缺少<code>AmapNaviParams</code>。官网也一直强调有个什么东西开源了所以提供的包里移除了一些东西（不知道到底是什么）。  </p><p><a href="https://lbs.amap.com/api/android-sdk/download">官网SDK下载地址</a>  </p><p>我下载的是导航合包：</p><p><img src="/images/Android/gaodeSDK.png" alt="SDK">  </p><h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a>2. 创建项目</h2><p>直接Android Studio创建一个java，Groovy的项目即可。  </p><p>设置里需要设置生成所有Gradle Task：  </p><p><img src="/images/Android/openALLTask.png" alt="set generate all tasks">  </p><p>这样你就可以靠点击这里直接获得你项目的SHA1的值，申请key的时候需要这个。</p><p><img src="/images/Android/signing.png" alt="signing">  </p><p>点击上图位置你就可以在终端看见你的SHA1值。在我这里release和debug的SHA1的值是一样的。  </p><h2 id="3-导入你下载的SDK"><a href="#3-导入你下载的SDK" class="headerlink" title="3. 导入你下载的SDK"></a>3. 导入你下载的SDK</h2><p>在app的<code>build.gradle</code>的<code>dependencies</code>里添加一行<br><code>implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])</code>  </p><p>在上方和<code>compileOptions</code>同级的位置添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        jniLibs.srcDirs = [&#x27;libs&#x27;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="/images/Android/SouceSet.png" alt="souceSet">  </p><p>同时下载的SDK如图放在app文件夹下的libs文件夹下。</p><p>同步一下即导入完成。</p><h2 id="添加权限和你的KEY"><a href="#添加权限和你的KEY" class="headerlink" title="添加权限和你的KEY"></a>添加权限和你的KEY</h2><p>这里需要在manifest文件里添加一些权限，你的key和一个服务。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--允许访问网络，必选权限--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--允许获取粗略位置，若用GPS实现定位小蓝点功能则必选--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_COARSE_LOCATION&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--允许获取设备和运营商信息，用于问题排查和网络定位，若无gps但仍需实现定位小蓝点功能则此权限必选--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_PHONE_STATE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--允许获取网络状态，用于网络定位，若无gps但仍需实现定位小蓝点功能则此权限必选--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--允许获取wifi网络信息，用于网络定位，若无gps但仍需实现定位小蓝点功能则此权限必选--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_WIFI_STATE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--允许获取wifi状态改变，用于网络定位，若无gps但仍需实现定位小蓝点功能则此权限必选--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CHANGE_WIFI_STATE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--允许写入扩展存储，用于数据缓存，若无此权限则写到私有目录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--允许读设备等信息，用于问题排查--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--允许访问网络，必选权限--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--允许读设备等信息，用于问题排查--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_PHONE_STATE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--允许获取网络状态--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--允许获取wifi网络信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_WIFI_STATE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--允许写入扩展存储，用于搜索结果缓存，若无此权限则写到私有目录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--允许读设备等信息，用于问题排查--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_FINE_LOCATION&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_COARSE_LOCATION&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>然后application下添加你的key和一个服务，之后还要用到一个高德自己的activity，这里顺便一起声明了,这些和你的启动Activity是同级的：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;com.amap.api.v2.apikey&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;你的key&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">meta-data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;com.amap.api.location.APSService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.amap.api.navi.AmapRouteActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@android:style/Theme.NoTitleBar&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:configChanges</span>=<span class="string">&quot;orientation|keyboardHidden|screenSize|navigation&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="继续之前"><a href="#继续之前" class="headerlink" title="继续之前"></a>继续之前</h2><p>首先你的key应该按照官网已经申请成功了，这里我把我的项目传到github上。如果想要源码请直接跳转下载。</p><p><a href="https://github.com/WHFF521/AMAP-Android-Navigation">我的仓库</a>  </p><h2 id="展示图"><a href="#展示图" class="headerlink" title="展示图"></a>展示图</h2><div style="display: flex;gap: 10px;">  <img src="/images/Android/navi-mainpage.jpg" alt="description" width="300" height="600">  <img src="/images/Android/navigating.jpg" alt="description" width="300" height="600"></div><h2 id="相对于参考博客做的代码替换"><a href="#相对于参考博客做的代码替换" class="headerlink" title="相对于参考博客做的代码替换"></a>相对于参考博客做的代码替换</h2><p>由于有一些APi在最新的SDK中已经失效，这里重点写一下相对于参考博客代码中的不同：</p><p>MainActivity中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configureMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (aMap == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        MyLocationStyle myLocationStyle;</span><br><span class="line">        myLocationStyle = <span class="keyword">new</span> <span class="title class_">MyLocationStyle</span>();<span class="comment">//初始化定位蓝点样式类myLocationStyle.myLocationType(MyLocationStyle.LOCATION_TYPE_LOCATION_ROTATE);//连续定位、且将视角移动到地图中心点，定位点依照设备方向旋转，并且会跟随设备移动。（1秒1次定位）如果不设置myLocationType，默认也会执行此种模式。</span></span><br><span class="line">        myLocationStyle.interval(<span class="number">2000</span>); <span class="comment">//设置连续定位模式下的定位间隔，只在连续定位模式下生效，单次定位模式下不会生效。单位为毫秒。</span></span><br><span class="line">        aMap.setMyLocationStyle(myLocationStyle);<span class="comment">//设置定位蓝点的Style</span></span><br><span class="line"><span class="comment">//aMap.getUiSettings().setMyLocationButtonEnabled(true);设置默认定位按钮是否显示，非必需设置。</span></span><br><span class="line">        aMap.setMyLocationEnabled(<span class="literal">true</span>);<span class="comment">// 设置为true表示启动显示定位蓝点，false表示隐藏定位蓝点并不进行定位，默认是false。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>这个函数中的MyLocationStyle需要进行替换。</p><p>由于参考博客中并没有完整的代码，你需要在MainActivity中添加：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOCATION_PERMISSION_REQUEST_CODE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><br>作为这个code的声明和初始化。  </p><p>我在实际编写的时候，Android Studio不能自动import关于manifest的库，会导致申请权限的代码中爆红一片。你需要引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.Manifest;</span><br></pre></td></tr></table></figure><p>其他应该没有什么变化。</p><h2 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h2><p>这是这个project中的核心文件，其中按钮绑定的跳转函数那里是重点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.btnGotoNavi).setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                <span class="comment">// 无起终点启动导航</span></span><br><span class="line">                <span class="type">AmapNaviParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmapNaviParams</span>(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, AmapNaviType.DRIVER, AmapPageType.ROUTE);</span><br><span class="line">                AmapNaviPage.getInstance().showRouteActivity(getApplicationContext(), params, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>这里直接跳转到高德包里的一个activity中，可以进行导航等行为，这个是调用<code>AmapRouteActivity</code>，之前已在manifest中声明。当然也可以进行有起终点启动导航。<a href="https://lbs.amap.com/api/android-navi-sdk/guide/navi-component/basic-functions">官网文档</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//起点</span></span><br><span class="line"><span class="type">Poi</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poi</span>(<span class="string">&quot;北京首都机场&quot;</span>, <span class="keyword">new</span> <span class="title class_">LatLng</span>(<span class="number">40.080525</span>,<span class="number">116.603039</span>), <span class="string">&quot;B000A28DAE&quot;</span>);</span><br><span class="line"><span class="comment">//途经点</span></span><br><span class="line">List&lt;Poi&gt; poiList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">poiList.add(<span class="keyword">new</span> <span class="title class_">Poi</span>(<span class="string">&quot;故宫&quot;</span>, <span class="keyword">new</span> <span class="title class_">LatLng</span>(<span class="number">39.918058</span>,<span class="number">116.397026</span>), <span class="string">&quot;B000A8UIN8&quot;</span>));</span><br><span class="line"><span class="comment">//终点</span></span><br><span class="line"><span class="type">Poi</span> <span class="variable">end</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poi</span>(<span class="string">&quot;北京大学&quot;</span>, <span class="keyword">new</span> <span class="title class_">LatLng</span>(<span class="number">39.941823</span>,<span class="number">116.426319</span>), <span class="string">&quot;B000A816R6&quot;</span>);</span><br><span class="line"><span class="comment">// 组件参数配置</span></span><br><span class="line"><span class="type">AmapNaviParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmapNaviParams</span>(start, poiList, end, AmapNaviType.DRIVER, AmapPageType.ROUTE);  </span><br><span class="line"><span class="comment">// 启动组件</span></span><br><span class="line">AmapNaviPage.getInstance().showRouteActivity(getApplicationContext(), params, <span class="literal">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="记录开发环境和调试手机"><a href="#记录开发环境和调试手机" class="headerlink" title="记录开发环境和调试手机"></a>记录开发环境和调试手机</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Android Studio Jellyfish | 2023.3.1 Patch 1</span><br><span class="line">Build #AI-233.14808.21.2331.11842104, built on May 15, 2024</span><br><span class="line">Runtime version: 17.0.10+0-17.0.10b1087.21-11572160 aarch64</span><br><span class="line">VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.</span><br><span class="line">macOS 14.5</span><br><span class="line">GC: G1 Young Generation, G1 Old Generation</span><br><span class="line">Memory: 2048M</span><br><span class="line">Cores: 8</span><br><span class="line">Metal Rendering is ON</span><br><span class="line">Registry:</span><br><span class="line">  ide.experimental.ui=true</span><br><span class="line">Non-Bundled Plugins:</span><br><span class="line">  Dart (233.15271)</span><br><span class="line">  io.flutter (79.0.2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>手机是vivo iqoo，android11。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eloquent JavaScript 08 Exercises</title>
      <link href="/2024/06/19/Eloquent-JavaScript-08-Exercises/"/>
      <url>/2024/06/19/Eloquent-JavaScript-08-Exercises/</url>
      
        <content type="html"><![CDATA[<h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p><a href="https://eloquentjavascript.net/08_error.html">To the book page</a>  </p><h2 id="Retry"><a href="#Retry" class="headerlink" title="Retry"></a>Retry</h2><p>大概率触发MultiplicatorUnitFailure错误，承接直到运行成功并返回结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MultiplicatorUnitFailure</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">primitiveMultiply</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MultiplicatorUnitFailure</span>(<span class="string">&quot;Klunk&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reliableMultiply</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ans = <span class="title function_">primitiveMultiply</span>(a,b);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="keyword">if</span>(e <span class="keyword">instanceof</span> <span class="title class_">MultiplicatorUnitFailure</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reliableMultiply</span>(<span class="number">8</span>, <span class="number">8</span>));</span><br><span class="line"><span class="comment">// → 64</span></span><br></pre></td></tr></table></figure><h2 id="The-locked-box"><a href="#The-locked-box" class="headerlink" title="The locked box"></a>The locked box</h2><p>先开锁，不管之后干什么都要在函数执行完毕返回前锁上盒子，因为中间操作可能抛出异常导致后面函数不执行，用finally执行关闭函数即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> box = <span class="keyword">new</span> <span class="keyword">class</span> &#123;</span><br><span class="line">  locked = <span class="literal">true</span>;</span><br><span class="line">  #content = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unlock</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="property">locked</span> = <span class="literal">false</span>; &#125;</span><br><span class="line">  <span class="title function_">lock</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="property">locked</span> = <span class="literal">true</span>;  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">content</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">locked</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Locked!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withBoxUnlocked</span>(<span class="params">body</span>) &#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  box.<span class="title function_">unlock</span>();</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="title function_">body</span>();</span><br><span class="line">  &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    box.<span class="title function_">lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">withBoxUnlocked</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  box.<span class="property">content</span>.<span class="title function_">push</span>(<span class="string">&quot;gold piece&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">withBoxUnlocked</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Pirates on the horizon! Abort!&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Error raised: &quot;</span> + e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="property">locked</span>);</span><br><span class="line"><span class="comment">// → true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eloquent JavaScript 07 robot</title>
      <link href="/2024/06/19/Eloquent-JavaScript-07-robot/"/>
      <url>/2024/06/19/Eloquent-JavaScript-07-robot/</url>
      
        <content type="html"><![CDATA[<h1 id="robot"><a href="#robot" class="headerlink" title="robot"></a>robot</h1><p><a href="https://eloquentjavascript.net/07_robot.html">To the book page</a><br>代码解释由AI生成。  </p><h2 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h2><h3 id="数据结构和图的构建"><a href="#数据结构和图的构建" class="headerlink" title="数据结构和图的构建"></a>数据结构和图的构建</h3><p>首先定义了村庄中各个地点之间的道路：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> roads = [</span><br><span class="line">    <span class="string">&quot;Alice&#x27;s House-Bob&#x27;s House&quot;</span>,   <span class="string">&quot;Alice&#x27;s House-Cabin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Alice&#x27;s House-Post Office&quot;</span>,   <span class="string">&quot;Bob&#x27;s House-Town Hall&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Daria&#x27;s House-Ernie&#x27;s House&quot;</span>, <span class="string">&quot;Daria&#x27;s House-Town Hall&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Ernie&#x27;s House-Grete&#x27;s House&quot;</span>, <span class="string">&quot;Grete&#x27;s House-Farm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Grete&#x27;s House-Shop&quot;</span>,          <span class="string">&quot;Marketplace-Farm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Marketplace-Post Office&quot;</span>,     <span class="string">&quot;Marketplace-Shop&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Marketplace-Town Hall&quot;</span>,       <span class="string">&quot;Shop-Town Hall&quot;</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>接着，定义 <code>buildGraph</code> 函数来构建图：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildGraph</span>(<span class="params">edges</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> graph = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">// 创建一个空对象作为图</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">addEdge</span>(<span class="params"><span class="keyword">from</span>, to</span>) &#123; <span class="comment">// 定义一个添加边的函数</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">from</span> <span class="keyword">in</span> graph) &#123;</span><br><span class="line">        graph[<span class="keyword">from</span>].<span class="title function_">push</span>(to); <span class="comment">// 如果节点已经存在，直接添加边</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        graph[<span class="keyword">from</span>] = [to]; <span class="comment">// 如果节点不存在，创建新数组并添加边</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [<span class="keyword">from</span>, to] <span class="keyword">of</span> edges.<span class="title function_">map</span>(<span class="function"><span class="params">r</span> =&gt;</span> r.<span class="title function_">split</span>(<span class="string">&quot;-&quot;</span>))) &#123;</span><br><span class="line">      <span class="title function_">addEdge</span>(<span class="keyword">from</span>, to); <span class="comment">// 添加双向边</span></span><br><span class="line">      <span class="title function_">addEdge</span>(to, <span class="keyword">from</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph; <span class="comment">// 返回构建好的图</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> roadGraph = <span class="title function_">buildGraph</span>(roads);</span><br></pre></td></tr></table></figure><h3 id="村庄状态类"><a href="#村庄状态类" class="headerlink" title="村庄状态类"></a>村庄状态类</h3><p><code>VillageState</code> 类表示村庄的状态，包括机器人的位置和包裹的位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VillageState</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">place, parcels</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">place</span> = place; <span class="comment">// 机器人当前所在的位置</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">parcels</span> = parcels; <span class="comment">// 包裹列表，每个包裹有一个位置和目标地址</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="title function_">move</span>(<span class="params">destination</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!roadGraph[<span class="variable language_">this</span>.<span class="property">place</span>].<span class="title function_">includes</span>(destination)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>; <span class="comment">// 如果目的地不在当前地点的邻居中，返回当前状态</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> parcels = <span class="variable language_">this</span>.<span class="property">parcels</span>.<span class="title function_">map</span>(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (p.<span class="property">place</span> != <span class="variable language_">this</span>.<span class="property">place</span>) <span class="keyword">return</span> p; <span class="comment">// 如果包裹不在当前位置，不做改变</span></span><br><span class="line">          <span class="keyword">return</span> &#123;<span class="attr">place</span>: destination, <span class="attr">address</span>: p.<span class="property">address</span>&#125;; <span class="comment">// 否则将包裹移动到目的地</span></span><br><span class="line">        &#125;).<span class="title function_">filter</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">place</span> != p.<span class="property">address</span>); <span class="comment">// 过滤掉已送达的包裹</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VillageState</span>(destination, parcels); <span class="comment">// 返回新的村庄状态</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行机器人"><a href="#运行机器人" class="headerlink" title="运行机器人"></a>运行机器人</h3><p><code>runRobot</code> 函数模拟机器人运行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runRobot</span>(<span class="params">state, robot, memory</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> turn = <span class="number">0</span>;; turn++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state.<span class="property">parcels</span>.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 如果所有包裹都已送达，结束循环</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> action = <span class="title function_">robot</span>(state, memory); <span class="comment">// 调用机器人函数，获取下一步动作</span></span><br><span class="line">      state = state.<span class="title function_">move</span>(action.<span class="property">direction</span>); <span class="comment">// 移动到下一步位置</span></span><br><span class="line">      memory = action.<span class="property">memory</span>; <span class="comment">// 更新机器人的记忆</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> turn; <span class="comment">// 返回所用的回合数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机机器人"><a href="#随机机器人" class="headerlink" title="随机机器人"></a>随机机器人</h3><p><code>randomRobot</code> 随机选择一个方向移动：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">randomPick</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> choice = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * array.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">return</span> array[choice]; <span class="comment">// 从数组中随机选择一个元素</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randomRobot</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">direction</span>: <span class="title function_">randomPick</span>(roadGraph[state.<span class="property">place</span>])&#125;; <span class="comment">// 随机选择一个邻居方向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预定义路径机器人"><a href="#预定义路径机器人" class="headerlink" title="预定义路径机器人"></a>预定义路径机器人</h3><p><code>routeRobot</code> 按照预定义的路径移动：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mailRoute = [</span><br><span class="line">    <span class="string">&quot;Alice&#x27;s House&quot;</span>, <span class="string">&quot;Cabin&quot;</span>, <span class="string">&quot;Alice&#x27;s House&quot;</span>, <span class="string">&quot;Bob&#x27;s House&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Town Hall&quot;</span>, <span class="string">&quot;Daria&#x27;s House&quot;</span>, <span class="string">&quot;Ernie&#x27;s House&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Grete&#x27;s House&quot;</span>, <span class="string">&quot;Shop&quot;</span>, <span class="string">&quot;Grete&#x27;s House&quot;</span>, <span class="string">&quot;Farm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Marketplace&quot;</span>, <span class="string">&quot;Post Office&quot;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">routeRobot</span>(<span class="params">state, memory</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (memory.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      memory = mailRoute; <span class="comment">// 如果记忆为空，初始化为预定义路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">direction</span>: memory[<span class="number">0</span>], <span class="attr">memory</span>: memory.<span class="title function_">slice</span>(<span class="number">1</span>)&#125;; <span class="comment">// 按照路径顺序移动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="目标导向机器人"><a href="#目标导向机器人" class="headerlink" title="目标导向机器人"></a>目标导向机器人</h3><p><code>goalOrientedRobot</code> 根据包裹的位置和目标地址找到最佳路径：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findRoute</span>(<span class="params">graph, <span class="keyword">from</span>, to</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> work = [&#123;<span class="attr">at</span>: <span class="keyword">from</span>, <span class="attr">route</span>: []&#125;];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; work.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123;at, route&#125; = work[i];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> place <span class="keyword">of</span> graph[at]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (place == to) <span class="keyword">return</span> route.<span class="title function_">concat</span>(place); <span class="comment">// 找到目标地点，返回路径</span></span><br><span class="line">        <span class="keyword">if</span> (!work.<span class="title function_">some</span>(<span class="function"><span class="params">w</span> =&gt;</span> w.<span class="property">at</span> == place)) &#123;</span><br><span class="line">          work.<span class="title function_">push</span>(&#123;<span class="attr">at</span>: place, <span class="attr">route</span>: route.<span class="title function_">concat</span>(place)&#125;); <span class="comment">// 将新的位置加入工作队列</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">goalOrientedRobot</span>(<span class="params">&#123;place, parcels&#125;, route</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (route.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> parcel = parcels[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> (parcel.<span class="property">place</span> != place) &#123;</span><br><span class="line">        route = <span class="title function_">findRoute</span>(roadGraph, place, parcel.<span class="property">place</span>); <span class="comment">// 找到包裹位置的路径</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        route = <span class="title function_">findRoute</span>(roadGraph, place, parcel.<span class="property">address</span>); <span class="comment">// 找到包裹目标地址的路径</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">direction</span>: route[<span class="number">0</span>], <span class="attr">memory</span>: route.<span class="title function_">slice</span>(<span class="number">1</span>)&#125;; <span class="comment">// 返回下一步方向和剩余路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效率机器人"><a href="#效率机器人" class="headerlink" title="效率机器人"></a>效率机器人</h3><p><code>efficientRobot</code> 根据所有包裹找到最短路径，以提高效率：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">efficientRobot</span>(<span class="params">&#123;place, parcels&#125;, route</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (route.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> routes = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> parcel <span class="keyword">of</span> parcels) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parcel.<span class="property">place</span> != place) &#123;</span><br><span class="line">            routes.<span class="title function_">push</span>(<span class="title function_">findRoute</span>(roadGraph, place, parcel.<span class="property">place</span>)); <span class="comment">// 找到包裹位置的路径</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            routes.<span class="title function_">push</span>(<span class="title function_">findRoute</span>(roadGraph, place, parcel.<span class="property">address</span>)); <span class="comment">// 找到包裹目标地址的路径</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        route = routes.<span class="title function_">reduce</span>(<span class="function">(<span class="params">shortest, current</span>) =&gt;</span> </span><br><span class="line">        shortest.<span class="property">length</span> &lt; current.<span class="property">length</span> ? shortest : current <span class="comment">// 选择最短路径</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">direction</span>: route[<span class="number">0</span>], <span class="attr">memory</span>: route.<span class="title function_">slice</span>(<span class="number">1</span>)&#125;; <span class="comment">// 返回下一步方向和剩余路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="机器人比较"><a href="#机器人比较" class="headerlink" title="机器人比较"></a>机器人比较</h3><p><code>compareRobots</code> 用于比较两个机器人的性能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compareRobots</span>(<span class="params">robot1, memory1, robot2, memory2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> totalTurns1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> totalTurns2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> state = <span class="title class_">VillageState</span>.<span class="title function_">random</span>(); <span class="comment">// 随机生成初始状态</span></span><br><span class="line">      totalTurns1 += <span class="title function_">runRobot</span>(state, robot1, memory1); <span class="comment">// 运行第一个机器人</span></span><br><span class="line">      totalTurns2 += <span class="title function_">runRobot</span>(state, robot2, memory2); <span class="comment">// 运行第二个机器人</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Robot 1 average turns: <span class="subst">$&#123;totalTurns1 / <span class="number">100</span>&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Robot 2 average turns: <span class="subst">$&#123;totalTurns2 / <span class="number">100</span>&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，比较目标导向机器人和效率机器人的表现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">compareRobots</span>(goalOrientedRobot, [], efficientRobot, []);</span><br></pre></td></tr></table></figure><p>这段代码会运行两个机器人各100次，比较它们完成任务所需的平均回合数。</p><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><h3 id="Measuring-a-robot"><a href="#Measuring-a-robot" class="headerlink" title="Measuring a robot"></a>Measuring a robot</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行机器人并计算所需回合数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">runRobotCount</span>(<span class="params">state, robot, memory</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> turn = <span class="number">0</span>;; turn++) &#123; <span class="comment">// 从0开始记录回合数</span></span><br><span class="line">    <span class="keyword">if</span> (state.<span class="property">parcels</span>.<span class="property">length</span> == <span class="number">0</span>) &#123; <span class="comment">// 如果所有包裹都已送达</span></span><br><span class="line">      <span class="keyword">return</span> turn; <span class="comment">// 返回总回合数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> action = <span class="title function_">robot</span>(state, memory); <span class="comment">// 获取机器人下一步的动作</span></span><br><span class="line">    state = state.<span class="title function_">move</span>(action.<span class="property">direction</span>); <span class="comment">// 根据机器人的指示移动</span></span><br><span class="line">    memory = action.<span class="property">memory</span>; <span class="comment">// 更新机器人的记忆</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个机器人的表现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compareRobots</span>(<span class="params">robot1, memory1, robot2, memory2</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> totalTurns1 = <span class="number">0</span>, totalTurns2 = <span class="number">0</span>; <span class="comment">// 初始化两个机器人所用的总回合数</span></span><br><span class="line">  <span class="keyword">let</span> tasks = <span class="number">100</span>; <span class="comment">// 设置任务数量为100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tasks; i++) &#123; <span class="comment">// 循环运行100次</span></span><br><span class="line">    <span class="keyword">let</span> state = <span class="title class_">VillageState</span>.<span class="title function_">random</span>(); <span class="comment">// 随机生成初始状态</span></span><br><span class="line">    totalTurns1 += <span class="title function_">runRobotCount</span>(state, robot1, memory1); <span class="comment">// 运行第一个机器人并累计回合数</span></span><br><span class="line">    totalTurns2 += <span class="title function_">runRobotCount</span>(state, robot2, memory2); <span class="comment">// 运行第二个机器人并累计回合数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出每个机器人完成任务所需的平均回合数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Robot 1 averaged <span class="subst">$&#123;totalTurns1 / tasks&#125;</span> turns per task`</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Robot 2 averaged <span class="subst">$&#123;totalTurns2 / tasks&#125;</span> turns per task`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较预定义路径机器人和目标导向机器人的表现</span></span><br><span class="line"><span class="title function_">compareRobots</span>(routeRobot, [], goalOrientedRobot, []);</span><br></pre></td></tr></table></figure><h3 id="Robot-efficiency"><a href="#Robot-efficiency" class="headerlink" title="Robot efficiency"></a>Robot efficiency</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到从起点到多个目标中最短的路线</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findShortestRoute</span>(<span class="params">graph, <span class="keyword">from</span>, goals</span>) &#123;</span><br><span class="line">  <span class="comment">// 对每个目标调用 findRoute 函数，返回所有路径</span></span><br><span class="line">  <span class="keyword">let</span> routes = goals.<span class="title function_">map</span>(<span class="function"><span class="params">goal</span> =&gt;</span> <span class="title function_">findRoute</span>(graph, <span class="keyword">from</span>, goal));</span><br><span class="line">  <span class="comment">// 通过 reduce 方法找到最短的路径</span></span><br><span class="line">  <span class="keyword">return</span> routes.<span class="title function_">reduce</span>(<span class="function">(<span class="params">shortest, current</span>) =&gt;</span> </span><br><span class="line">    shortest.<span class="property">length</span> &lt; current.<span class="property">length</span> ? shortest : current</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效机器人，选择最优路径来传递包裹</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">efficientRobot</span>(<span class="params">&#123;place, parcels&#125;, route</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (route.<span class="property">length</span> == <span class="number">0</span>) &#123; <span class="comment">// 如果当前没有预定的路径</span></span><br><span class="line">    <span class="keyword">let</span> routes = []; <span class="comment">// 存储所有可能的路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> parcel <span class="keyword">of</span> parcels) &#123; <span class="comment">// 遍历每个包裹</span></span><br><span class="line">      <span class="keyword">if</span> (parcel.<span class="property">place</span> != place) &#123;</span><br><span class="line">        <span class="comment">// 如果包裹还没被捡起，找到去包裹位置的路径</span></span><br><span class="line">        routes.<span class="title function_">push</span>(<span class="title function_">findRoute</span>(roadGraph, place, parcel.<span class="property">place</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果包裹已捡起，找到去目标地址的路径</span></span><br><span class="line">        routes.<span class="title function_">push</span>(<span class="title function_">findRoute</span>(roadGraph, place, parcel.<span class="property">address</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择所有路径中最短的一条</span></span><br><span class="line">    route = routes.<span class="title function_">reduce</span>(<span class="function">(<span class="params">shortest, current</span>) =&gt;</span> </span><br><span class="line">      shortest.<span class="property">length</span> &lt; current.<span class="property">length</span> ? shortest : current</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回机器人下一步的方向和更新后的记忆</span></span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">direction</span>: route[<span class="number">0</span>], <span class="attr">memory</span>: route.<span class="title function_">slice</span>(<span class="number">1</span>)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">runRobotAnimation</span>(<span class="title class_">VillageState</span>.<span class="title function_">random</span>(), efficientRobot, []);</span><br></pre></td></tr></table></figure><h3 id="Persistent-group"><a href="#Persistent-group" class="headerlink" title="Persistent group"></a>Persistent group</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PGroup</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">members</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">members</span> = members; <span class="comment">// 初始化成员列表</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加新成员</span></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">has</span>(value)) <span class="keyword">return</span> <span class="variable language_">this</span>; <span class="comment">// 如果成员已经存在，返回当前对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PGroup</span>(<span class="variable language_">this</span>.<span class="property">members</span>.<span class="title function_">concat</span>(value)); <span class="comment">// 否则，创建新对象并添加新成员</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除成员</span></span><br><span class="line">  <span class="title function_">delete</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">has</span>(value)) <span class="keyword">return</span> <span class="variable language_">this</span>; <span class="comment">// 如果成员不存在，返回当前对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PGroup</span>(<span class="variable language_">this</span>.<span class="property">members</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">m</span> =&gt;</span> m !== value)); <span class="comment">// 否则，创建新对象并删除指定成员</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查成员是否存在</span></span><br><span class="line">  <span class="title function_">has</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">members</span>.<span class="title function_">includes</span>(value); <span class="comment">// 返回成员是否在列表中</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个静态属性，表示一个空的 PGroup 实例</span></span><br><span class="line">  <span class="keyword">static</span> empty = <span class="keyword">new</span> <span class="title class_">PGroup</span>([]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试实现</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">PGroup</span>.<span class="property">empty</span>.<span class="title function_">add</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">// 向空组添加 &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">let</span> ab = a.<span class="title function_">add</span>(<span class="string">&quot;b&quot;</span>); <span class="comment">// 向包含 &#x27;a&#x27; 的组添加 &#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> b = ab.<span class="title function_">delete</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">// 从包含 &#x27;a&#x27; 和 &#x27;b&#x27; 的组删除 &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="title function_">has</span>(<span class="string">&quot;b&quot;</span>)); <span class="comment">// → true  检查 &#x27;b&#x27; 是否存在</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">has</span>(<span class="string">&quot;b&quot;</span>)); <span class="comment">// → false 检查 &#x27;b&#x27; 是否存在</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="title function_">has</span>(<span class="string">&quot;a&quot;</span>)); <span class="comment">// → false 检查 &#x27;a&#x27; 是否存在</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eloquent JavaScript 06 Exercises</title>
      <link href="/2024/06/17/Eloquent-JavaScript-06-Exercises/"/>
      <url>/2024/06/17/Eloquent-JavaScript-06-Exercises/</url>
      
        <content type="html"><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p><a href="https://eloquentjavascript.net/06_object.html">To the book page</a>  </p><h2 id="A-vector-type"><a href="#A-vector-type" class="headerlink" title="A vector type"></a>A vector type</h2><p>封装一个类，实现坐标的加减法，以及get属性的length返回坐标离原点的距离。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vec</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x,y</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">plus</span>(<span class="params">other</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Vec</span>(<span class="variable language_">this</span>.<span class="property">x</span>+other.<span class="property">x</span>,<span class="variable language_">this</span>.<span class="property">y</span>+other.<span class="property">y</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">minus</span>(<span class="params">other</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Vec</span>(<span class="variable language_">this</span>.<span class="property">x</span>-other.<span class="property">x</span>,<span class="variable language_">this</span>.<span class="property">y</span>-other.<span class="property">y</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">length</span>()&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="variable language_">this</span>.<span class="property">x</span>**<span class="number">2</span>+<span class="variable language_">this</span>.<span class="property">y</span>**<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Vec</span>(<span class="number">1</span>, <span class="number">2</span>).<span class="title function_">plus</span>(<span class="keyword">new</span> <span class="title class_">Vec</span>(<span class="number">2</span>, <span class="number">3</span>)));</span><br><span class="line"><span class="comment">// → Vec&#123;x: 3, y: 5&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Vec</span>(<span class="number">1</span>, <span class="number">2</span>).<span class="title function_">minus</span>(<span class="keyword">new</span> <span class="title class_">Vec</span>(<span class="number">2</span>, <span class="number">3</span>)));</span><br><span class="line"><span class="comment">// → Vec&#123;x: -1, y: -1&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Vec</span>(<span class="number">3</span>, <span class="number">4</span>).<span class="property">length</span>);</span><br><span class="line"><span class="comment">// → 5</span></span><br></pre></td></tr></table></figure><h2 id="Groups"><a href="#Groups" class="headerlink" title="Groups"></a>Groups</h2><p>封装一个Group类，实现相当于Set的功能。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Group</span> &#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">members</span> = [];  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">value</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="title function_">has</span>(value))&#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">members</span>.<span class="title function_">push</span>(value);  </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">delete</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">members</span> = <span class="variable language_">this</span>.<span class="property">members</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">member</span> =&gt;</span> member!==value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">members</span>.<span class="title function_">includes</span>(value);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">from</span>(<span class="params">iterable</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> group = <span class="keyword">new</span> <span class="title class_">Group</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> iterable)&#123;</span><br><span class="line">      group.<span class="title function_">add</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> group;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> group = <span class="title class_">Group</span>.<span class="title function_">from</span>([<span class="number">10</span>, <span class="number">20</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(group.<span class="title function_">has</span>(<span class="number">10</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(group.<span class="title function_">has</span>(<span class="number">30</span>));</span><br><span class="line"><span class="comment">// → false</span></span><br><span class="line">group.<span class="title function_">add</span>(<span class="number">10</span>);</span><br><span class="line">group.<span class="title function_">delete</span>(<span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(group.<span class="title function_">has</span>(<span class="number">10</span>));</span><br><span class="line"><span class="comment">// → false</span></span><br></pre></td></tr></table></figure><h2 id="Iterable-groups"><a href="#Iterable-groups" class="headerlink" title="Iterable groups"></a>Iterable groups</h2><p>让上面的数组类可迭代。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your code here (and the code from the previous exercise)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Group</span> &#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">members</span> = [];  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">value</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="title function_">has</span>(value))&#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">members</span>.<span class="title function_">push</span>(value);  </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">delete</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">members</span> = <span class="variable language_">this</span>.<span class="property">members</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">member</span> =&gt;</span> member!==value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">members</span>.<span class="title function_">includes</span>(value);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">from</span>(<span class="params">iterable</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> group = <span class="keyword">new</span> <span class="title class_">Group</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> iterable)&#123;</span><br><span class="line">      group.<span class="title function_">add</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> group;</span><br><span class="line">  &#125;</span><br><span class="line">   [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()&#123;</span><br><span class="line">     <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">let</span> members = <span class="variable language_">this</span>.<span class="property">members</span>;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">       <span class="title function_">next</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(index &lt; members.<span class="property">length</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;<span class="attr">value</span>:members[index++],<span class="attr">done</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">true</span>&#125;;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="title class_">Group</span>.<span class="title function_">from</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>])) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// → a</span></span><br><span class="line"><span class="comment">// → b</span></span><br><span class="line"><span class="comment">// → c</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eloquent JavaScript 05 Exercises</title>
      <link href="/2024/06/17/Eloquent-JavaScript-05-Exercises/"/>
      <url>/2024/06/17/Eloquent-JavaScript-05-Exercises/</url>
      
        <content type="html"><![CDATA[<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>记录一下这本书的习题的答案，这是第五章的练习。</p><p><a href="https://eloquentjavascript.net/05_higher_order.html">To the book page</a>  </p><h2 id="Flattening"><a href="#Flattening" class="headerlink" title="Flattening"></a>Flattening</h2><p>将包含数组的数组展开，即只有一对中括号的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrays = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>]];</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line"><span class="keyword">let</span> combineArrays = arrays.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator,currentArray</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator.<span class="title function_">concat</span>(currentArray);</span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(combineArrays);</span><br><span class="line"><span class="comment">// → [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h2 id="Your-own-loop"><a href="#Your-own-loop" class="headerlink" title="Your own loop"></a>Your own loop</h2><p>如果不能满足条件（testAct）就不能继续循环。下一次循环要用新的值（updateAct），每次循环需要执行一定的操作（bodyAct）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loop</span>(<span class="params">value, testAct, updateAct,bodyAct</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_">testAct</span>(value)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="title function_">bodyAct</span>(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">loop</span>(<span class="title function_">updateAct</span>(value),testAct,updateAct,bodyAct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">loop</span>(<span class="number">3</span>, <span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">0</span>, <span class="function"><span class="params">n</span> =&gt;</span> n - <span class="number">1</span>, <span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// → 3</span></span><br><span class="line"><span class="comment">// → 2</span></span><br><span class="line"><span class="comment">// → 1</span></span><br></pre></td></tr></table></figure><h2 id="Everything"><a href="#Everything" class="headerlink" title="Everything"></a>Everything</h2><p>判断数组中所有元素是否都满足一定的条件，和some函数相反。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">every</span>(<span class="params">array, test</span>) &#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="keyword">for</span>(item <span class="keyword">of</span> array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_">test</span>(item))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//   return !array.some(element=&gt;!test(element));</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">every</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], <span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">10</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">every</span>([<span class="number">2</span>, <span class="number">4</span>, <span class="number">16</span>], <span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">10</span>));</span><br><span class="line"><span class="comment">// → false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">every</span>([], <span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">10</span>));</span><br><span class="line"><span class="comment">// → true</span></span><br></pre></td></tr></table></figure><h2 id="Dominant-writing-direction"><a href="#Dominant-writing-direction" class="headerlink" title="Dominant writing direction"></a>Dominant writing direction</h2><p>找出文字中最主要的读法方向。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dominantDirection</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">    <span class="keyword">let</span> counted = <span class="title function_">countBy</span>(text,<span class="function"><span class="params">char</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="title function_">characterScript</span>(char.<span class="title function_">codePointAt</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> script ? script.<span class="property">direction</span> : <span class="string">&quot;none&quot;</span>;</span><br><span class="line">  &#125;).<span class="title function_">filter</span>(<span class="function">(<span class="params">&#123;name&#125;</span>) =&gt;</span> name!=<span class="string">&quot;none&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(counted.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;ltr&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> counted.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a.<span class="property">count</span>&gt;b.<span class="property">count</span>?<span class="attr">a</span>:b).<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">dominantDirection</span>(<span class="string">&quot;Hello!&quot;</span>));</span><br><span class="line"><span class="comment">// → ltr</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">dominantDirection</span>(<span class="string">&quot;Hey, مساء الخير&quot;</span>));</span><br><span class="line"><span class="comment">// → rtl</span></span><br></pre></td></tr></table></figure><p>这是<code>countBy</code>,作用是返回数组中满足要求的数量，groupName作为函数名称调用，返回属于当前item所属于的组名称，在这里有两个组别，分别是true组和false组，然后将所在组的数量加1:  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countBy</span>(<span class="params">items, groupName</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> counts = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> items) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="title function_">groupName</span>(item);</span><br><span class="line">    <span class="keyword">let</span> known = counts.<span class="title function_">find</span>(c = c.<span class="property">name</span> == name);</span><br><span class="line">    <span class="keyword">if</span> (!known) &#123;</span><br><span class="line">      counts.<span class="title function_">push</span>(&#123;name, <span class="attr">count</span>: <span class="number">1</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      known.<span class="property">count</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> counts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">countBy</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">2</span>));</span><br><span class="line"><span class="comment">// → [&#123;name: false, count: 2&#125;, &#123;name: true, count: 3&#125;]</span></span><br></pre></td></tr></table></figure><p>这是<code>characterScript</code>，作用是判断code属于哪一种语言。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">characterScript</span>(<span class="params">code</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> script <span class="keyword">of</span> <span class="variable constant_">SCRIPTS</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (script.<span class="property">ranges</span>.<span class="title function_">some</span>(<span class="function">(<span class="params">[<span class="keyword">from</span>, to]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> code &gt;= <span class="keyword">from</span> &amp;&amp; code &lt; to;</span><br><span class="line">    &#125;)) &#123;</span><br><span class="line">      <span class="keyword">return</span> script;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">characterScript</span>(<span class="number">121</span>));</span><br><span class="line"><span class="comment">// → &#123;name: &quot;Latin&quot;, …&#125;</span></span><br></pre></td></tr></table></figure></p><p><code>SCRIPTS</code>类型的格式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Coptic&quot;</span>,</span><br><span class="line">  <span class="attr">ranges</span>: [[<span class="number">994</span>, <span class="number">1008</span>], [<span class="number">11392</span>, <span class="number">11508</span>], [<span class="number">11513</span>, <span class="number">11520</span>]],</span><br><span class="line">  <span class="attr">direction</span>: <span class="string">&quot;ltr&quot;</span>,</span><br><span class="line">  <span class="attr">year</span>: -<span class="number">200</span>,</span><br><span class="line">  <span class="attr">living</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">link</span>: <span class="string">&quot;https://en.wikipedia.org/wiki/Coptic_alphabet&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Github Desktop简化你的推送流程</title>
      <link href="/2024/06/12/%E7%94%A8github-Desktop%E7%AE%80%E5%8C%96%E4%BD%A0%E7%9A%84%E6%8E%A8%E9%80%81%E6%B5%81%E7%A8%8B/"/>
      <url>/2024/06/12/%E7%94%A8github-Desktop%E7%AE%80%E5%8C%96%E4%BD%A0%E7%9A%84%E6%8E%A8%E9%80%81%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="用Github-Desktop简化你的推送流程"><a href="#用Github-Desktop简化你的推送流程" class="headerlink" title="用Github Desktop简化你的推送流程"></a>用Github Desktop简化你的推送流程</h1><p><a href="https://desktop.github.com/">Github Desktop官方网站</a></p><h2 id="1-第三方仓库克隆"><a href="#1-第三方仓库克隆" class="headerlink" title="1. 第三方仓库克隆"></a>1. 第三方仓库克隆</h2><h3 id="选择file-gt-clone-repository"><a href="#选择file-gt-clone-repository" class="headerlink" title="选择file-&gt;clone repository,"></a>选择file-&gt;clone repository,</h3><p><img src="https://images.whff521.top/chooseclone.png" alt="chooseClone"></p><h3 id="通过URL克隆你的仓库"><a href="#通过URL克隆你的仓库" class="headerlink" title="通过URL克隆你的仓库"></a>通过URL克隆你的仓库</h3><p>选择URL，里面填你的第三方仓库的https克隆链接，注意要填写公网地址而不是内网地址。  </p><p><img src="https://images.whff521.top/writeURL.png" alt="writeURL"></p><p><strong>注意选择你保存仓库的本地位置</strong>  </p><p>点击clone后应该会弹出让你输入用户名和密码，如果是gitlab，直接输入你登录gitlab的用户名和密码。  </p><p>到此为止应该是可以克隆仓库到本地了。之后的操作，和一般的git操作是一致的，不过是有了图形化的界面，不用输入繁琐的命令。</p><h2 id="2-add-和-commit"><a href="#2-add-和-commit" class="headerlink" title="2. add 和 commit"></a>2. add 和 commit</h2><p>直接到app界面，一旦仓库有文件更改，app界面会罗列出你更新文件的内容，需要你进行commit操作。  </p><p><img src="https://images.whff521.top/commit.png" alt="commit"></p><h2 id="3-push"><a href="#3-push" class="headerlink" title="3. push"></a>3. push</h2><p>处理完所有的commit后就可以进行推送了，直接点击界面右边的push origin 即可。</p><p><img src="https://images.whff521.top/push.png" alt="push"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chess For Three</title>
      <link href="/2024/05/22/check-for-three/"/>
      <url>/2024/05/22/check-for-three/</url>
      
        <content type="html"><![CDATA[<h1 id="Chess-For-Three"><a href="#Chess-For-Three" class="headerlink" title="Chess For Three"></a>Chess For Three</h1><p>这是Codeforces Round 945 (Div. 2) 第一题。  </p><p><a href="https://codeforces.com/contest/1973/problem/A">题目链接</a>  </p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>三个人玩游戏，每局两个人玩。赢得人得2分，输的人得0分。平局每个人得1分。会给你三个人的最终得分，问最多平局多少局。</p><h2 id="重点记录"><a href="#重点记录" class="headerlink" title="重点记录"></a>重点记录</h2><p>这里题确实不难，但是有一个样例因为没有给怎么算的导致我一直以为样例给错了。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 4 5</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>3分4分5分，最大平局数是6。  </p><p>我最一开始想的是a和b平局3次，b还剩一局和c平局，这是4次。a和c平局3次，b和c平局2次，这是5次。<br>但是样例给的是6次。</p><p>6次的情况应该是<strong>c和a平局2次，c和b平局3次，a和b平局1次</strong>，这样就是6次。这真的是太amazing了。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>可以直接暴力枚举a和b，a和c，b和c平局次数，然后判断分数是否合法。除去平局的分数，剩下的分数应该<code>left%2==0</code>。  </p><p>但是还有结论， <code>min((p1+p2+p3)/2,p1+p2)</code>，这里保证<code>p1&lt;=p2&lt;=p3</code>。  </p><p>先考虑合不合法，三个数加一起如果是偶数就一定合法。  </p><p>其次，如果<code>p1+p2&lt;=p3</code>，那么情况应该是a和c平局p1次，b和c平局p2次。这就是最大的平局数。  </p><p>如果<code>p1+p2&gt;p3</code>，相当于<code>p1&gt;p3-p2</code>。a可以和c玩p3-p2次，相当于a剩余分数为<code>p1-(p3-p2)</code>，这个分数一定是偶数。a还可以和b和c分别玩<code>(p1-(p3-p2))/2</code>次。这里a和其他人的平局数就是p1。b和c还可以平局<code>p2-(p1-(p3-p2))/2)</code>次。加一起就是<code>(p1+p2+p3)/2</code>。</p><p>标程核心：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; (v[<span class="number">0</span>] + v[<span class="number">1</span>] + v[<span class="number">2</span>] - <span class="built_in">max</span>(<span class="number">0</span>, v[<span class="number">2</span>] - v[<span class="number">0</span>] - v[<span class="number">1</span>])) / <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure></p><p>暴力正解：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> p1,p2,p3;</span><br><span class="line">        cin&gt;&gt;p1&gt;&gt;p2&gt;&gt;p3;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// i d12,j d13,k d23</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">30</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">30</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">30</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p1-i-j&gt;=<span class="number">0</span>&amp;&amp;(p1-i-j)%<span class="number">2</span>==<span class="number">0</span> &amp;&amp;</span><br><span class="line">                       p2-i-k&gt;=<span class="number">0</span>&amp;&amp;(p2-i-k)%<span class="number">2</span>==<span class="number">0</span> &amp;&amp;</span><br><span class="line">                       p3-j-k&gt;=<span class="number">0</span>&amp;&amp;(p3-j-k)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                        ans = <span class="built_in">max</span>(ans,i+j+k);    </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans!=<span class="number">-1</span>) cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prison Escape</title>
      <link href="/2024/05/17/Prison-Escape/"/>
      <url>/2024/05/17/Prison-Escape/</url>
      
        <content type="html"><![CDATA[<h1 id="Prison-Escape"><a href="#Prison-Escape" class="headerlink" title="Prison Escape"></a>Prison Escape</h1><p>这是<code>codechef starter 134 div4</code>的第六题。<br><a href="https://www.codechef.com/problems/PRISON">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>NxM的01矩阵，0代表罪犯，1代表守卫者。罪犯可以上下左右移动，计算罪犯最少需要经过几个守卫者才能逃出这个矩阵。我们要求出这些罪犯里边经过最少守卫者数量的最大值。<br>数据范围：<code>T 1000，N和M 3e5，NxM&lt;3e5</code>。</p><h2 id="赛时回顾"><a href="#赛时回顾" class="headerlink" title="赛时回顾"></a>赛时回顾</h2><p>一眼最短路，但是看见数据范围就没有去写代码。我觉得每个0点去执行最短路算法应该会超时。或者直接每个0进行bfs应该也会超时。</p><h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p><strong>有个东西叫多源最短路</strong>。实际上我应该换位思考，不是去求0到边界的最短路，而是边界到0的最短路。多源最短路有两种方法，一是设置虚拟节点连接到所有源，二是直接把所有源节点压入队列中，不需要理会。</p><p>所以实际上这个题目是典型的<code>0-1BFS</code>问题。我们只需要将所有边界节点压入队列中，然后一点点向内更新距离即可。最后答案就是<code>d[i][j]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> n,m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        string a[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">d</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,INT_MAX));</span><br><span class="line">        deque&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; dq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>||i==n<span class="number">-1</span>||j==m<span class="number">-1</span>)&#123;</span><br><span class="line">                    d[i][j]=a[i][j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(d[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                        dq.<span class="built_in">push_front</span>(&#123;i,j&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> dq.<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> x = dq.<span class="built_in">front</span>().first;</span><br><span class="line">            <span class="type">int</span> y = dq.<span class="built_in">front</span>().second;</span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> xx = x+dx[i];</span><br><span class="line">                <span class="type">int</span> yy = y+dy[i];</span><br><span class="line">                <span class="keyword">if</span>(xx&lt;<span class="number">0</span>||yy&lt;<span class="number">0</span>||xx&gt;=n||yy&gt;=m) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> weight = a[xx][yy]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(d[x][y]+weight&lt;d[xx][yy])&#123;</span><br><span class="line">                    d[xx][yy]=d[x][y]+weight;</span><br><span class="line">                    <span class="keyword">if</span>(weight==<span class="number">0</span>)&#123;</span><br><span class="line">                        dq.<span class="built_in">push_front</span>(&#123;xx,yy&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> dq.<span class="built_in">push_back</span>(&#123;xx,yy&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01BFS </tag>
            
            <tag> 多源最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3 out 1 in</title>
      <link href="/2024/05/16/3-out-1-in/"/>
      <url>/2024/05/16/3-out-1-in/</url>
      
        <content type="html"><![CDATA[<h1 id="3out1in"><a href="#3out1in" class="headerlink" title="3out1in"></a>3out1in</h1><p><a href="https://www.codechef.com/problems/OKLAMA">题目链接</a>  </p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>这是<code>codechef starter 134 div4</code>的第五题。  </p><p>给你一个数组B，里面包含M个数字，其中M必定为奇数。操作是选出三个数字a,b,c, 这三个数字从数组里剔除，数组中重新加入成员<code>a+b-c</code>。可以看出来每一次操作会让数组少两个元素，问最后剩下一个元素的最大值是多少。其中有多个询问，询问内容是如果只有前k个元素，剩下的最后一个元素最大值是多少。</p><h2 id="赛时回顾"><a href="#赛时回顾" class="headerlink" title="赛时回顾"></a>赛时回顾</h2><p>我在第一次做这道题的时候就直接考虑到了用优先队列。显然最优解是每次选两个最大值，然后减去最小值。原数组我用数组<code>a</code>存储，每次将前<code>k</code>个元素送入优先队列和数组<code>b</code>中，数组<code>b</code>进行排序用来获得最小值，优先队列获取最大值。成功拿到30分的部分分，其他测试会超时。</p><h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>官方题解思路让我恍然大悟。<strong>永远记得可以用空间换取时间</strong>。既然可以用一个优先队列，那么我们就可以用两个优先队列。虽然我们不知道给出的qurey里<code>k</code>的值是多少，但是我们可以用<code>ans</code>数组记录所有对应k值的答案。  </p><p>首先就要考虑随着数组元素的增加，状态是如何转移的。我们可以将现有元素分成两组，一个是<code>samll</code>组，一个是<code>large</code>组。<code>small</code>组是所有会被减去的数字，<code>large</code>组是所有会被加上的数字。每次需要两个<code>large</code>组的元素相加，一个<code>small</code>组的元素被减，但是得到的数字还应该被保留在<code>large</code>数组里。可以推断出，<code>large</code>数组元素个数应该永远比<code>small</code>数组多1。</p><p>事实上我们并不需要将真的每次操作得到的数字压到优先队列里面。因为每个数字只有两种可能，被赋予加号，代表和其他元素相加，被赋予减号，代表被减去。符号确定后所有元素的和是不会变的。我们只需要计算现在<code>small</code>组里元素的总和<code>sumin</code>，<code>large</code>组里元素的总和<code>sumax</code>，然后答案就是<code>sumax-sumin</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[mxlen];</span><br><span class="line">ll ans[mxlen];</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;ll&gt; pqmin;</span><br><span class="line">    priority_queue&lt;ll&gt; pqmax;</span><br><span class="line">    ll sumin = <span class="number">0</span>;</span><br><span class="line">    ll sumax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pqmin.<span class="built_in">push</span>(a[i]);</span><br><span class="line">        sumin+=a[i];</span><br><span class="line">        <span class="comment">//这里表达式的意思是pqmin.size()要永远少一个</span></span><br><span class="line">        <span class="keyword">while</span>(pqmin.<span class="built_in">size</span>()&gt;=pqmax.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ll mi = pqmin.<span class="built_in">top</span>();</span><br><span class="line">            pqmin.<span class="built_in">pop</span>();</span><br><span class="line">            pqmax.<span class="built_in">push</span>(-mi);</span><br><span class="line">            sumax+=mi;</span><br><span class="line">            sumin-=mi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!pqmin.<span class="built_in">empty</span>()&amp;&amp;pqmin.<span class="built_in">top</span>()&gt;-pqmax.<span class="built_in">top</span>())&#123;</span><br><span class="line">            ll mi = pqmin.<span class="built_in">top</span>();</span><br><span class="line">            ll ma = -pqmax.<span class="built_in">top</span>();</span><br><span class="line">            pqmin.<span class="built_in">pop</span>(); pqmax.<span class="built_in">pop</span>();</span><br><span class="line">            pqmin.<span class="built_in">push</span>(ma);</span><br><span class="line">            pqmax.<span class="built_in">push</span>(-mi);</span><br><span class="line">            sumin = sumin-mi+ma;</span><br><span class="line">            sumax = sumax-ma+mi;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans[i]=sumax-sumin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        cin&gt;&gt;k;</span><br><span class="line">            cout&lt;&lt;ans[k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 944 (Div. 4) 回顾</title>
      <link href="/2024/05/11/Codeforces-Round-944-Div-4-%E5%9B%9E%E9%A1%BE/"/>
      <url>/2024/05/11/Codeforces-Round-944-Div-4-%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-944-Div-4-回顾"><a href="#Codeforces-Round-944-Div-4-回顾" class="headerlink" title="Codeforces Round 944 (Div. 4) 回顾"></a>Codeforces Round 944 (Div. 4) 回顾</h1><h2 id="比赛回顾"><a href="#比赛回顾" class="headerlink" title="比赛回顾"></a>比赛回顾</h2><p>赛中是AC了前四题，E答案错误，F超时。可以说是做到了最后五分钟，排名是6000多。  </p><p><a href="https://codeforces.com/contest/1971">比赛链接</a>  </p><p><a href="https://codeforces.com/blog/entry/129364">官方题解链接</a>  </p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>AB就直接跳过了，纯签到。 </p><h3 id="C-Clock-and-Strings"><a href="#C-Clock-and-Strings" class="headerlink" title="C. Clock and Strings"></a>C. Clock and Strings</h3><p>C题意思是给出表中两对数字，看每对数字连接的线是否相交。我的思路是只要一条线的一个端点在另一条线的区间内，切另一端在区间外即可断定这两条线是相交的。</p><p>为了更好的进行区分，我进行了排序，其中满足<code>a&lt;c a&lt;b c&lt;d</code>。</p><p>我觉得不能直接去写，表上的数字是1到12，对于一条线，一个端点是1，另一个端点是10，其中11和12其实是在线的包围内的，所以我给所有小于6的数字加了12，区间变成了6到17，然后判断是否<code>c</code>在<code>a</code>和<code>b</code>之间,<code>d</code>在<code>a</code>和<code>b</code>之外。<br>但是我今天才发现我的判断语句竟然是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((a&lt;c&amp;&amp;c&lt;b)||(a&lt;d&amp;&amp;d&lt;b)) cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>我究竟是怎么过了这题的所有数据，只判断了一端在区间内就过了，根本没看是否另一端是否在区间外。。。  </p><p>官方题解就很有意思，他是从1到12遍历，记录一个字符串，如果碰到第一条线的端点，字符串就加一个’a’，碰到另一条线的端点，字符串就加一个’b’，这样如果答案是’abab’或者’baba’就说明有一条线的端点在另一条线区间内而且另一端点在区间外，非常巧妙。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a, b, c, d;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == a || i == b) &#123;s += <span class="string">&quot;a&quot;</span>;&#125;</span><br><span class="line"><span class="keyword">if</span> (i == c || i == d) &#123;s += <span class="string">&quot;b&quot;</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; (s == <span class="string">&quot;abab&quot;</span> || s == <span class="string">&quot;baba&quot;</span> ? <span class="string">&quot;YES\n&quot;</span> : <span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-Binary-Cut"><a href="#D-Binary-Cut" class="headerlink" title="D. Binary Cut"></a>D. Binary Cut</h3><p>将01数组剪切成最少的组，使能够让这些组自由组合后成为一个0全部在前面，1全部在后面的数组。  </p><p>很遗憾我的AC代码被场后Hack数据卡掉了。这里思路就是相邻的1或者0分成一组，这样就分成了很多个1的组合和很多个0的组合，但是有一点需要注意，因为最终我们需要的数组是0在前1在后，所以如果有<code>01</code>出现的话，我们可以少分一组，比如<code>10001</code>我们不是分成三组<code>1</code>、<code>000</code>、<code>1</code>,而是<code>1</code>和<code>0001</code>两组。因为分界点只有一个，所以如果有一个<code>01</code>出现，答案我们减去1即可。  </p><p>同样这题的官方题解也很有趣。他在判断是否有<code>01</code>出现时采用了位运算，<del>而不是像我一样写丑陋的if语句</del>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> ex = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; (<span class="type">int</span>)(s.<span class="built_in">size</span>()); i++) &#123;</span><br><span class="line">res += (s[i] != s[i + <span class="number">1</span>]);</span><br><span class="line">ex |= (s[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res - ex &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Find-the-Car"><a href="#E-Find-the-Car" class="headerlink" title="E. Find the Car"></a>E. Find the Car</h3><p>这题就是很简单的物理里的算速度的题目。给出k个路上的点，然后给出到达每个点的时间，其中设定每两点之间的速度是常数，也就是每一段路都是匀速。我们需要找到到达某一个点（不一定是给出的点）所花费的时间。但是比赛时我以为给出的时间是前一个点到下一个点的时间，所以用前缀和算的时间，样例竟然都过了。。。。注意我们要先用二分找到问的点是哪两个已知点之间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="type">int</span> n,k,q;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k&gt;&gt;q;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">a</span><span class="params">(k+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">b</span><span class="params">(k+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">sum</span><span class="params">(k+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            cin&gt;&gt;b[i];</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">            <span class="type">int</span> pos;</span><br><span class="line">            cin&gt;&gt;pos;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">1</span>,r=k;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[mid]&gt;=pos)&#123;</span><br><span class="line">                    r=mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    l=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            b[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            l--;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ans= <span class="number">0</span>;</span><br><span class="line">            ans = b[l]+((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)pos-a[l])*(b[r]-b[l])/(a[r]-a[l]);</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F-Circle-Perimeter"><a href="#F-Circle-Perimeter" class="headerlink" title="F. Circle Perimeter"></a>F. Circle Perimeter</h3><p>在笛卡尔坐标系中找到与原点的直线距离大于r小于r+1的点的个数。  </p><p>因为数据很大不能纯暴力找。坐标系都是对称的，所以只需要算第一象限加y轴或者x轴然后答案x4即可。  </p><p>官方题解的意思是x轴0到1遍历，先将y坐标设置为r。显然x只会越来越大，如果想要满足要求y就必须越来越小。先将y控制到点到原点距离小于r+1的高度，然后y继续减的同时ans++，直到距离小于r，x增加后继续此操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> r;</span><br><span class="line">    cin &gt;&gt; r;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> height = r;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i*i+height*height &gt;= (r+<span class="number">1</span>)*(r+<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            height--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cop = height;</span><br><span class="line">        <span class="keyword">while</span>(i*i+cop*cop &gt;= r*r &amp;&amp; cop &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cop--;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans*<span class="number">4</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="G-XOUR"><a href="#G-XOUR" class="headerlink" title="G. XOUR"></a>G. XOUR</h3><p>这题就是给你n个数字，如果两个数之间XOR操作后小于等于4，那么这两个数是可以换位置的。求换位后字典序最小的数列。  </p><p>先把所有数字以二进制的方式看待，不难发现如果两个数XOR操作后如果小于等于4，说明除了后两位，其他位置的0或者1是完全一样的，这样才能让前面的数异或后变成0。我们需要把所有除了后两位前面位全部相同的数字分到一个组里面，这样一个组里面的数字位置是可以随意互换的。</p><p>官方题解非常巧妙地运用了C++的STL。使用了一个map，key是<code>a[i]&gt;&gt;2</code>，value是一个<code>priority_queue</code>，这样就可以将所有前面位一样的存在一个优先队列里面。在取数字的时候，排在队列前面的就是一个组里面字典序最小的数字。注意，优先队列默认是大根堆，所以我们需要存的是每个数的相反数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    map&lt;<span class="type">int</span>, priority_queue&lt;<span class="type">int</span>&gt;&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        mp[a[i]&gt;&gt;<span class="number">2</span>].<span class="built_in">push</span>(-a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; -mp[a[i]&gt;&gt;<span class="number">2</span>].<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        mp[a[i]&gt;&gt;<span class="number">2</span>].<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="H-±1"><a href="#H-±1" class="headerlink" title="H. ±1"></a>H. ±1</h3><p>这是一个关于<a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">SAT</a>的题目，暂时不会。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装完整版Xcode后我的C++万能库不见了</title>
      <link href="/2024/05/11/%E5%AE%89%E8%A3%85%E5%AE%8C%E6%95%B4%E7%89%88Xcode%E5%90%8E%E6%88%91%E7%9A%84C-%E4%B8%87%E8%83%BD%E5%BA%93%E4%B8%8D%E8%A7%81%E4%BA%86/"/>
      <url>/2024/05/11/%E5%AE%89%E8%A3%85%E5%AE%8C%E6%95%B4%E7%89%88Xcode%E5%90%8E%E6%88%91%E7%9A%84C-%E4%B8%87%E8%83%BD%E5%BA%93%E4%B8%8D%E8%A7%81%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h1 id="安装完整版Xcode后我的C-万能库不见了"><a href="#安装完整版Xcode后我的C-万能库不见了" class="headerlink" title="安装完整版Xcode后我的C++万能库不见了"></a>安装完整版Xcode后我的C++万能库不见了</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天因为安装了<code>flutter</code>的原因，因为这个需要完整版<code>Xcode</code>，之前都是安装的命令行版本的，所以直接去苹果应用商店安装了。但是万万没想到的是，完整版<code>Xcode</code>竟然更改了我使用的<code>Clang</code>地址。他更改到了<code>Applications</code>文件夹下的完整版<code>Xcode</code>里面。看来是<code>Xcode</code>自带了<code>Clang</code>然后就直接更改了默认地址。  </p><p>好巧不巧昨天<code>codeforces Round 944</code>开赛前三分钟我才发现了问题。因为我的万能库引用不能用了。还好我有在博客写过<a href="https://blog.whff521.xyz/2024/04/13/mac%E7%94%B5%E8%84%91vscode%E7%9A%84c-%E8%BF%90%E8%A1%8C%E9%85%8D%E7%BD%AE/">mac电脑vscode的c++运行配置</a>。所以只花了五分钟就添加好了万能库文件。不过我所经历的和上篇文章有所不同。所以在此记录一下。  </p><h2 id="在完整Xcode里添加万能库文件"><a href="#在完整Xcode里添加万能库文件" class="headerlink" title="在完整Xcode里添加万能库文件"></a>在完整<code>Xcode</code>里添加万能库文件</h2><ol><li>同样是在终端里输入<code>echo | g++ -v -x c++ -E -</code>, 其中<code>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include</code>是我们要修改的路径。</li><li>修改include文件夹的访问权限为读写。<code>sudo chmod 777 /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include</code>。</li><li>创建<code>bits</code>文件夹并进入。<code>mkdir bits</code>, <code>cd bits/</code>。这里电脑会提示消息，因为我终端用的是<code>Iterm2</code>，提示我这个软件想要修改<code>Applications</code>文件里的东西，是否给权限，点开消息在设置里允许就可以。</li><li>创建<code>stdc++.h</code>，<code>touch stdc++.h</code></li><li>这里如果直接 <code>open stdc++.h</code> 的话会发现默认是<code>Xcode</code>打开的，想使用<code>Vscode</code>打开使用<code>code stdc++.h</code>即可。同样系统会消息提示是否给权限修改，选择允许即可。</li><li>将代码复制粘帖即可。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ includes used for precompiling -*- C++ -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copyright (C) 2003-2014 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file is part of the GNU ISO C++ Library.  This library is free</span></span><br><span class="line"><span class="comment">// software; you can redistribute it and/or modify it under the</span></span><br><span class="line"><span class="comment">// terms of the GNU General Public License as published by the</span></span><br><span class="line"><span class="comment">// Free Software Foundation; either version 3, or (at your option)</span></span><br><span class="line"><span class="comment">// any later version.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// This library is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment">// GNU General Public License for more details.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Under Section 7 of GPL version 3, you are granted additional</span></span><br><span class="line"><span class="comment">// permissions described in the GCC Runtime Library Exception, version</span></span><br><span class="line"><span class="comment">// 3.1, as published by the Free Software Foundation.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// You should have received a copy of the GNU General Public License and</span></span><br><span class="line"><span class="comment">// a copy of the GCC Runtime Library Exception along with this program;</span></span><br><span class="line"><span class="comment">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</span></span><br><span class="line"><span class="comment">// &lt;http://www.gnu.org/licenses/&gt;.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/** @file stdc++.h</span></span><br><span class="line"><span class="comment"> *  This is an implementation file for a precompiled header.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 17.4.1.2 Headers</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GLIBCXX_NO_ASSERT</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cfloat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ciso646&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csetjmp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ccomplex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cfenv&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cinttypes&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdbool&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctgmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cwchar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cwctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iosfwd&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;istream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;streambuf&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;valarray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;scoped_allocator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;system_error&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeindex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>因为是直接在应用文件夹里改的，不知道以后更新软件后会不会消失，不过到时候在说吧，添加方法也比较简单。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将本机ipv6地址复制到粘贴板脚本</title>
      <link href="/2024/05/08/%E5%B0%86%E6%9C%AC%E6%9C%BAipv6%E5%9C%B0%E5%9D%80%E5%A4%8D%E5%88%B6%E5%88%B0%E7%B2%98%E8%B4%B4%E6%9D%BF%E8%84%9A%E6%9C%AC/"/>
      <url>/2024/05/08/%E5%B0%86%E6%9C%AC%E6%9C%BAipv6%E5%9C%B0%E5%9D%80%E5%A4%8D%E5%88%B6%E5%88%B0%E7%B2%98%E8%B4%B4%E6%9D%BF%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="将本机ipv6地址复制到粘贴板脚本"><a href="#将本机ipv6地址复制到粘贴板脚本" class="headerlink" title="将本机ipv6地址复制到粘贴板脚本"></a>将本机ipv6地址复制到粘贴板脚本</h1><p>准确的来说是将windows主机的ipv6地址复制到粘贴板上的<code>powershell</code>脚本。因为有时候需要远程连接我自己的R9000p，所以与其每次开机去命令行运行<code>ipconfig</code>，不如直接复制到粘贴板里，这样就可以直接打开邮件将地址发送出去。本来想写一个一件发送ipv6地址到指定邮箱的脚本，但是好像很麻烦，就算了。代码由chatgpt生成，再根据我的实际情况改写的。  </p><h2 id="设备配置"><a href="#设备配置" class="headerlink" title="设备配置"></a>设备配置</h2><p>windows为win11，由于学校校园网比较特殊，使用的是拨号上网，拨号名称我设置成了<code>DIANXIN</code>。  </p><p>在命令行中运行<code>ipconfig</code>后会显示很多网络适配器，其中我需要的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Windows IP Configuration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PPP adapter DIANXIN:</span><br><span class="line"></span><br><span class="line">Connection-specific DNS Suffix  . :</span><br><span class="line">IPv6 Address. . . . . . . . . . . : 240e:360:40b:200:XXXX:XXXX:fc48:XXX</span><br><span class="line">Link-local IPv6 Address . . . . . : fe80::XXXX:XXXX:fc48:XXX%64</span><br><span class="line">IPv4 Address. . . . . . . . . . . : XXX.XX.XXX.XX</span><br><span class="line">Subnet Mask . . . . . . . . . . . : 255.255.255.XXX</span><br><span class="line">Default Gateway . . . . . . . . . : XXXX::ce1a:XXXX:XXXX:bf80%64</span><br></pre></td></tr></table></figure><p>其中<code>IPv6 Address</code>是我想要的。</p><h2 id="脚本代码"><a href="#脚本代码" class="headerlink" title="脚本代码"></a>脚本代码</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取网络适配器的全局 IPv6 地址</span></span><br><span class="line"><span class="variable">$ipv6Addresses</span> = (<span class="built_in">Get-NetIPAddress</span> <span class="literal">-AddressFamily</span> IPv6 | </span><br><span class="line">                  <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.InterfaceAlias <span class="operator">-eq</span> <span class="string">&quot;DIANXIN&quot;</span> <span class="operator">-and</span> <span class="variable">$_</span>.PrefixOrigin <span class="operator">-ne</span> <span class="string">&quot;LinkLayerAddress&quot;</span> &#125;).IPAddress</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第二个全局 IPv6 地址</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$ipv6Addresses</span>.Count <span class="operator">-ge</span> <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="variable">$ipv6Address</span> = <span class="variable">$ipv6Addresses</span>[<span class="number">1</span>]  <span class="comment"># 第二个地址的索引为 1</span></span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;Second IPv6 Address: <span class="variable">$ipv6Address</span>&quot;</span></span><br><span class="line">    <span class="variable">$ipv6Address</span> | <span class="built_in">Set-Clipboard</span>  <span class="comment"># 将 IPv6 地址复制到剪贴板</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;Second IPv6 Address not found for specified network adapter.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><ol><li><p><code>$ipv6Addresses = (Get-NetIPAddress -AddressFamily IPv6 | Where-Object &#123; $_.InterfaceAlias -eq &quot;DIANXIN&quot; -and $_.PrefixOrigin -ne &quot;LinkLayerAddress&quot; &#125;).IPAddress</code>：<br>这行代码获取特定网络适配器（InterfaceAlias为”DIANXIN”）的全局 IPv6 地址，并将结果存储在 <code>$ipv6Addresses</code> 变量中。</p></li><li><p><code>if ($ipv6Addresses.Count -ge 2) &#123;</code>：<br>这是一个条件语句，用于检查变量 <code>$ipv6Addresses</code> 中存储的 IPv6 地址数量是否至少为 2。</p></li><li><p><code>$ipv6Address = $ipv6Addresses[1]</code>：<br>如果存在至少两个 IPv6 地址，那么这行代码将第二个 IPv6 地址（索引为 1）存储在 <code>$ipv6Address</code> 变量中。</p></li><li><p><code>Write-Host &quot;Second IPv6 Address: $ipv6Address&quot;</code>：<br>这行代码输出第二个 IPv6 地址到控制台，并在前面添加一条消息 “Second IPv6 Address: “。</p></li><li><p><code>$ipv6Address | Set-Clipboard</code>：<br>这行代码将第二个 IPv6 地址复制到剪贴板中，以便将其粘贴到其他应用程序中使用。</p></li><li><p><code>&#125; else &#123;</code>：<br>这是条件语句的结尾，用于处理当 IPv6 地址数量小于 2 时的情况。</p></li><li><p><code>Write-Host &quot;Second IPv6 Address not found for specified network adapter.&quot;</code>：<br>如果 IPv6 地址数量小于 2，那么这行代码输出一条消息到控制台，提示找不到第二个 IPv6 地址。</p></li><li><p><code>Read-Host -Prompt &quot;Press Enter to exit&quot;</code>：<br>这行代码在脚本执行完毕后等待用户按下 Enter 键，以保持 PowerShell 会话处于打开状态。</p></li></ol><p>因为脚本会获取到两个<code>ipv6</code>地址，一个内网地址和一个外网地址，外网地址是第二个，所以选择了第二个地址。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ipv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project 1: Data Structures</title>
      <link href="/2024/05/05/Project-1-Data-Structures/"/>
      <url>/2024/05/05/Project-1-Data-Structures/</url>
      
        <content type="html"><![CDATA[<h1 id="Project-1-Data-Structures"><a href="#Project-1-Data-Structures" class="headerlink" title="Project 1: Data Structures"></a>Project 1: Data Structures</h1><h2 id="类值的相等判断永远用-equals-而不是"><a href="#类值的相等判断永远用-equals-而不是" class="headerlink" title="类值的相等判断永远用.equals()而不是=="></a><strong>类值的相等判断永远用<code>.equals()</code>而不是<code>==</code></strong></h2><p>花了近两天的时间终于是把Probject 1 完成了，完成了<code>LinkedListDeque</code>和<code>ArrayDeque</code>两种实现的<code>Deque</code>。在此就不再赘述数据结构的实现方法，<a href="https://github.com/WHFF521/skeleton-sp21/tree/master/proj1">代码地址</a>  </p><p>那么我要写一些什么呢？写一些我遇到的问题和bug。  </p><p><strong>这个bug实在是令人火大，这本是不应该出现的错误</strong>  </p><p>正如二级标题所说的，<strong>类值的相等判断永远用<code>.equals()</code>而不是<code>==</code></strong>。而且值得铭记的是，<strong>测试文件一定要扩大数据规模</strong>，因为扩大规模真的会发现意想不到的错误。</p><p>事情的起因是<code>public boolean equals(Object o)</code>这个函数，对于一个自己实现的数据类，这个方法是很有<code>Override</code>的必要的。因为两种数据类基本一样，这里我只用<code>LinkedListDeque</code>举例。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* check if two deques are equal</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> true if they are equal, false otherwise</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Deque)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Deque&lt;?&gt; other = (Deque&lt;?&gt;) o;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.size() != other.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.get(i)!=other.get(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是有bug的，我写的时候这种是真的很难注意到。你有可能也没有注意到，接下来是<code>get()</code>函数的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the item at the given index, if no such item exists, return null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="built_in">this</span>.size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> sentinal.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里其实就已经能看清楚问题所在了，<code>get()</code>函数返回的是类型<code>T</code>，是任意封装类，并不是基础数据类型。众所周知Java在比对类是否相等时，<code>==</code>操作符默认是比对类的地址是否一致，也就是看对方是否是自己。显然我们并不想这么做，我们需要比对的是内部存储的值是否相等。就像十张百元钞票和另外十张百元钞票，都是一千元，代表的价值是相同的，而不是因为钞票编号不同所以表示这两堆钞票是不相等的。  </p><p>相信学习过CS61B课程的同学都已经有了写测试代码的好习惯。我也是如此，但是很遗憾的是尽管我写了<code>junit</code>测试，也并没有查出来这个bug。以下是我一开始写的测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testEquals</span><span class="params">()</span> &#123;</span><br><span class="line">    LinkedListDeque&lt;Integer&gt; lld1 = <span class="keyword">new</span> <span class="title class_">LinkedListDeque</span>&lt;&gt;();</span><br><span class="line">    LinkedListDeque&lt;Integer&gt; lld2 = <span class="keyword">new</span> <span class="title class_">LinkedListDeque</span>&lt;&gt;();</span><br><span class="line">    assertTrue(lld1.equals(lld2));</span><br><span class="line">    lld1.addFirst(<span class="number">1</span>);</span><br><span class="line">    assertFalse(lld1.equals(lld2));</span><br><span class="line">    lld2.addFirst(<span class="number">1</span>);</span><br><span class="line">    assertTrue(lld1.equals(lld2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，测试很容易的通过了。这是为什么呢？这里就要引入大名鼎鼎的<code>IntegerCache</code>了。</p><blockquote><p><code>IntegerCache</code>是Java中的一个类，它是用于缓存Integer对象的一个内部类。在Java中，由于Integer是不可变对象，一些整数值在一定范围内是经常使用的，为了提高性能和节省内存，Java使用了IntegerCache来缓存一些常用的整数对象。<br>在Java中，对于数值在[-128, 127]范围内的Integer对象，如果通过自动装箱的方式创建，会直接使用<code>IntegerCache</code>中已经存在的对象，而不是每次创建新的对象。这样做可以避免频繁创建新的Integer对象，提高了性能和节省了内存。<br>例如，当你通过<code>Integer.valueOf()</code>方法创建一个整数值在[-128, 127]范围内的Integer对象时，如果该值在<code>IntegerCache</code>中已经存在，则直接返回缓存中的对象，而不会创建新的对象。<br>但是需要注意的是，这种缓存机制只适用于整数值在[-128, 127]范围内的情况，超出这个范围的整数值仍然会创建新的Integer对象。</p></blockquote><p>因为<code>IntegerCache</code>的原因，虽然我向两个<code>Deque</code>分别塞入了<code>Ingeter 1</code>，但是实际上这两个1地址是一样的，<del>编号一样的钞票真的不是假钞吗😂</del></p><p>所以正确的测试应该扩大数据规模：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testEquals</span><span class="params">()</span> &#123;</span><br><span class="line">    LinkedListDeque&lt;Integer&gt; lld1 = <span class="keyword">new</span> <span class="title class_">LinkedListDeque</span>&lt;&gt;();</span><br><span class="line">    LinkedListDeque&lt;Integer&gt; lld2 = <span class="keyword">new</span> <span class="title class_">LinkedListDeque</span>&lt;&gt;();</span><br><span class="line">    assertTrue(lld1.equals(lld2));</span><br><span class="line">    lld1.addFirst(<span class="number">1</span>);</span><br><span class="line">    assertFalse(lld1.equals(lld2));</span><br><span class="line">    lld2.addFirst(<span class="number">1</span>);</span><br><span class="line">    assertTrue(lld1.equals(lld2));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        lld1.addFirst(i);</span><br><span class="line">        lld2.addFirst(i);</span><br><span class="line">    &#125;</span><br><span class="line">    assertTrue(lld1.equals(lld2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样因为数据超过了128，显然以前的代码是无法通过这个代码的。在这里贴出修改后正确的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Deque)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Deque&lt;?&gt; other = (Deque&lt;?&gt;) o;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.size() != other.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.size(); i++) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="built_in">this</span>.get(i);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> other.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!a.equals(b)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用<code>T</code>本身的<code>equals()</code>方法即可，<del>这样即使还是通不过测试的话那也不是咱们代码的错了</del>。</p><h2 id="style-问题"><a href="#style-问题" class="headerlink" title="style 问题"></a>style 问题</h2><p>这个<code>Project 1</code>还挺有意思的，实现完数据类后还要用自己写的数据类去弹吉他。但是在此项目中，code 的 style 有严格的要求，第一次交代码的时候一共 640 points 因为 style 没有按照要求竟然扣了大约 84 points，。。。。<br>但是大可不必阅读那长长的 style 要求，只需要把 IDEA 的自动格式化代码打开即可。具体位置是<code>Settings -&gt; Tools -&gt; Actions on Save -&gt; Reformat code</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS61B 21sp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 943 (Div. 3) A-E solutions</title>
      <link href="/2024/05/03/Codeforces-Round-943-Div-3-A-E-solutions/"/>
      <url>/2024/05/03/Codeforces-Round-943-Div-3-A-E-solutions/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-943-Div-3"><a href="#Codeforces-Round-943-Div-3" class="headerlink" title="Codeforces Round 943 (Div. 3)"></a>Codeforces Round 943 (Div. 3)</h1><p>In this competition, I just got three Accepted.<br><strong><a href="https://codeforces.com/contest/1968">Competition Address</a></strong></p><h2 id="A-Maximize"><a href="#A-Maximize" class="headerlink" title="A. Maximize?"></a>A. Maximize?</h2><p>The meaning of the question is to find maximum of gcd(x,y)+y when gives you x.<br>My solution is to  have a linear search. Enough to pass this question.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;x;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">gcd</span>(i,x)+i&gt;ans)&#123;</span><br><span class="line">                temp = i;</span><br><span class="line">                ans = <span class="built_in">gcd</span>(i,x)+i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;temp&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>But the real answer is <code>x-1</code>,it need some mathematical derivations。</p><h2 id="B-Prefiquence"><a href="#B-Prefiquence" class="headerlink" title="B. Prefiquence"></a>B. Prefiquence</h2><p>Give you two 01 strings named a and b, find the max length of prefix of a which is a subsequence of b.<br>I worte a Binary search and passed it.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len&gt;b.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        temp+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;b.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;=temp.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(b[j]==temp[k])&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==temp.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> lena,lenb;</span><br><span class="line">        cin&gt;&gt;lena&gt;&gt;lenb;</span><br><span class="line">        </span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        string temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=lena;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>But last night I must have something wrong in my head. It obviously didn’t need a binary search. The better solution is to use two iterators and linear search.<br>The better code is below.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> lena,lenb;</span><br><span class="line">        cin&gt;&gt;lena&gt;&gt;lenb;</span><br><span class="line">        </span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;lena&amp;&amp;j&lt;lenb)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="C-Assembly-via-Remainders"><a href="#C-Assembly-via-Remainders" class="headerlink" title="C. Assembly via Remainders"></a>C. Assembly via Remainders</h2><p>An array: x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub>, find any array a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>, that a<sub>i</sub>%a<sub>i-1</sub> = x<sub>i</sub>, i : 2~n.  </p><p>Solution: take a number that is bigger than any number in x array, the number is a<sub>1</sub>, and next is a<sub>1</sub>+x<sub>2</sub>…<br>Notice that 1 &lt;= x<sub>i</sub> &lt;= 500, you can just take 501 as the first number.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x[<span class="number">550</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="type">int</span> mi=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;x[i];</span><br><span class="line">            mi = <span class="built_in">max</span>(x[i],mi);</span><br><span class="line">        &#125;</span><br><span class="line">        x[<span class="number">1</span>]=mi+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            x[i]=x[i<span class="number">-1</span>]+x[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;x[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="D-Permutation-Game"><a href="#D-Permutation-Game" class="headerlink" title="D. Permutation Game"></a>D. Permutation Game</h2><p>A permutation of length 𝑛 is an array consisting of 𝑛 distinct integers from 1 to 𝑛 in arbitrary order.  </p><p>Two people, Bodya and Sasha, play the game which has k turns. Both of them are trying to win. Each turn, they get score in their current position. They can decide to move from x to p<sub>x</sub> or stay in current position.  </p><p>Of course you will get the first position of them.  </p><p>The key of the solution is that you move from x to p<sub>x</sub>,it’s acturally a circle. What we need to do is to traverse this circle once. ans = max (ans,sum<sub>i</sub> + (k-i)a<sub>pos<sub>i</sub>&lt;/sub&gt;).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">score</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;p,vector&lt;<span class="type">int</span>&gt;&amp;a,<span class="type">int</span> pos,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(p.size())</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(!vis[pos]&amp;&amp;k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        vis[pos]=<span class="literal">true</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,sum+<span class="number">1LL</span>*k*a[pos]);</span><br><span class="line">        sum+=a[pos];</span><br><span class="line">        pos=p[pos];</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> n,k,pb,ps;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k&gt;&gt;pb&gt;&gt;ps;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span>,<span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;pi:p)&#123;</span><br><span class="line">            cin&gt;&gt;pi;</span><br><span class="line">            pi-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ai:a)&#123;</span><br><span class="line">            cin&gt;&gt;ai;</span><br><span class="line">        &#125;</span><br><span class="line">        ll Bodya=<span class="built_in">score</span>(p,a,pb<span class="number">-1</span>,k);</span><br><span class="line">        ll Sasha=<span class="built_in">score</span>(p,a,ps<span class="number">-1</span>,k);</span><br><span class="line">cout&lt;&lt;(Bodya&gt;Sasha?<span class="string">&quot;Bodya\n&quot;</span>:Bodya&lt;Sasha?<span class="string">&quot;Sasha\n&quot;</span>:<span class="string">&quot;Draw\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Cells-Arrangement"><a href="#E-Cells-Arrangement" class="headerlink" title="E. Cells Arrangement"></a>E. Cells Arrangement</h2><p>A n*n grid, find n cells that maximize Manhattan distances between any pair of the cells.<br>Official solutions:  </p><blockquote><p>Can you generalize the pattern? We put 𝑛−2 cells on the main diagonal. Then put two cells at (𝑛−1,𝑛) and (𝑛,𝑛).<br>But why does it work? Interesting fact, that in such way we generate all possible Manhattan distances.<br>Odd distances are generated between cells from the main diagonal and (𝑛−1,𝑛).<br>Even distances are generated between cells from the main diagonal and (𝑛,𝑛). </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Equal-XOR-Segments"><a href="#F-Equal-XOR-Segments" class="headerlink" title="F. Equal XOR Segments"></a>F. <a href="https://codeforces.com/contest/1968/problem/F">Equal XOR Segments</a></h2><p>Too hard for me to understand,sorry.</p><h2 id="G1-Division-LCP-easy-version"><a href="#G1-Division-LCP-easy-version" class="headerlink" title="G1. Division + LCP (easy version)"></a>G1. <a href="https://codeforces.com/contest/1968/problem/G1">Division + LCP (easy version)</a></h2><p>Too hard for me to understand,sorry.</p><h2 id="G2-Division-LCP-hard-version"><a href="#G2-Division-LCP-hard-version" class="headerlink" title="G2. Division + LCP (hard version)"></a>G2. <a href="https://codeforces.com/contest/1968/problem/G2">Division + LCP (hard version)</a></h2><p>Too hard for me to understand,sorry.</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spotify美化</title>
      <link href="/2024/04/25/spotify%E7%BE%8E%E5%8C%96/"/>
      <url>/2024/04/25/spotify%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="基于spicetify-cli对Spotify进行客制化"><a href="#基于spicetify-cli对Spotify进行客制化" class="headerlink" title="基于spicetify-cli对Spotify进行客制化"></a>基于<code>spicetify-cli</code>对Spotify进行客制化</h1><h2 id="什么是spicetify-cli"><a href="#什么是spicetify-cli" class="headerlink" title="什么是spicetify-cli"></a>什么是<code>spicetify-cli</code></h2><ul><li><a href="https://github.com/spicetify/spicetify-cli">spicetify仓库地址</a>  </li><li><a href="https://spicetify.app/docs/getting-started">官网Doc</a>  <blockquote><p>Command-line tool to customize the official Spotify client. Supports Windows, MacOS and Linux.</p></blockquote></li></ul><p>仓库readme明确说明了这是用于定制官方客户端的命令行工具。但是在官网Doc的安装教程里面却没有说清楚，这样会带来很多的麻烦。</p><h2 id="在安装之前你必须要做的事情："><a href="#在安装之前你必须要做的事情：" class="headerlink" title="在安装之前你必须要做的事情："></a>在安装之前你必须要做的事情：</h2><ul><li>确保电脑已经<strong>安装了spotify官方客户端</strong>，因为spicetify只是美化工具而不包含客户端</li><li>确保已经<strong>登陆了个人账号</strong>，新安装的spotify客户端在登陆之前<code>prefs</code>文件并不会创建，会导致spicetify找不到路径而报错。</li><li>默认你已经解决了所有关于网络的问题</li></ul><h2 id="macOS安装步骤"><a href="#macOS安装步骤" class="headerlink" title="macOS安装步骤"></a>macOS安装步骤</h2><p>若安装步骤有问题或者是其他操作系统，你可以直接去官网Doc查看最新的安装步骤。</p><ul><li><p>Spicetify CLI(工具本身)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://raw.githubusercontent.com/spicetify/spicetify-cli/master/install.sh | sh</span><br></pre></td></tr></table></figure></li><li><p>Spicetify Marketplace(在ui中显示市场，一定程度上减轻命令行操作)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://raw.githubusercontent.com/spicetify/spicetify-marketplace/main/resources/install.sh | sh</span><br></pre></td></tr></table></figure></li><li><p>卸载命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spicetify restore</span><br><span class="line">rm -rf ~/.spicetify</span><br><span class="line">rm -rf ~/.config/spicetify</span><br></pre></td></tr></table></figure><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><p>在此贴出我<a href="https://www.cnblogs.com/hui-tong/p/18065055">参考的博客</a>。  </p></li><li><p>我使用的主题：<code>Sleek</code><br><img src="https://raw.githubusercontent.com/spicetify/spicetify-themes/master/Sleek/wealthy.png" alt="Sleek"></p></li><li><p>我使用的插件：</p><ul><li><code>lyrics-plus</code> 歌词强化，从各种源中搜寻当前歌的歌词。  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spicetify config custom_apps lyrics-plus   </span><br><span class="line">spicetify apply</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="让mac拥有桌面歌词"><a href="#让mac拥有桌面歌词" class="headerlink" title="让mac拥有桌面歌词"></a>让mac拥有桌面歌词</h2><p><a href="https://github.com/ddddxxx/LyricsX">LyricsX</a><br>直接用<code>homebrew</code>安装：<code>brew install --cask lyricsx</code>。<br>安装后，打开，点击右上角<code>LyricsX</code>图标，选择<code>Preferences</code>，将默认音乐播放器改为<code>spotify</code>即可，播放歌曲的时候会自动匹配。<br><img src="https://raw.githubusercontent.com/ddddxxx/LyricsX/master/docs/img/desktop_lyrics.gif" alt="lyricsx"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spotify </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为博客添加RSS，sitemap和本地搜索</title>
      <link href="/2024/04/23/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0RSS%EF%BC%8Csitemap%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2/"/>
      <url>/2024/04/23/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0RSS%EF%BC%8Csitemap%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="博客的一些配置总结"><a href="#博客的一些配置总结" class="headerlink" title="博客的一些配置总结"></a>博客的一些配置总结</h1><h2 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加RSS</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>在<code>_config.yml</code> 里添加：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">hub:</span></span><br><span class="line">  <span class="attr">content:</span></span><br><span class="line">  <span class="attr">content_limit:</span> <span class="number">140</span></span><br><span class="line">  <span class="attr">content_limit_delim:</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">icon.png</span></span><br><span class="line">  <span class="attr">autodiscovery:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">template:</span></span><br></pre></td></tr></table></figure><br>其中<code>limit</code>指源里保存的文章个数，<code>content_limit</code>指summary的长度。<br>如果想要添加RSS图标，可在<code>butterfly</code>主题配置文件<code>_config.yml</code>里，<code>social:</code>后添加<code>fas fa-rss: /atom.xml || RSS || &#39;#f26522&#39;</code>,这样RSS图标就会出现在右边头像下边</p><h2 id="添加sitemap"><a href="#添加sitemap" class="headerlink" title="添加sitemap"></a>添加sitemap</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>根目录<code>_config.yml</code>里添加：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugin:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo-generator-feed</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo-generator-sitemap</span></span><br></pre></td></tr></table></figure><br>配置成功标志：generate后生成<code>sitemap.xml</code></p><h2 id="添加本地搜索"><a href="#添加本地搜索" class="headerlink" title="添加本地搜索"></a>添加本地搜索</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>我用的<code>butterfly</code>主题，直接在主题配置文件里更改：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">CDN:</span></span><br></pre></td></tr></table></figure></p><h2 id="webhook"><a href="#webhook" class="headerlink" title="webhook"></a>webhook</h2><p>在此贴出参考博客<a href="https://blog.haysc.tech/hexo-feed-setup/">here</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project 0: 2048</title>
      <link href="/2024/04/22/Project-0-2048/"/>
      <url>/2024/04/22/Project-0-2048/</url>
      
        <content type="html"><![CDATA[<h1 id="Project-0-2048"><a href="#Project-0-2048" class="headerlink" title="Project 0: 2048"></a><a href="https://sp21.datastructur.es/materials/proj/proj0/proj0">Project 0: 2048</a></h1><p>在这里贴一个线上2048的网站，<a href="https://play2048.co/">link</a><br><strong>整体代码仓库：<a href="https://github.com/WHFF521/skeleton-sp21">github</a></strong></p><h2 id="TASK-1-emptySpaceExists-Board-b"><a href="#TASK-1-emptySpaceExists-Board-b" class="headerlink" title="TASK 1: emptySpaceExists(Board b)"></a>TASK 1: emptySpaceExists(Board b)</h2><p>简单来说就是检测面板上是否还有没有数的地方。直接O(n)遍历。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns true if at least one space on the Board is empty.</span></span><br><span class="line"><span class="comment"> *  Empty spaces are stored as null.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">emptySpaceExists</span><span class="params">(Board b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> b.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b.tile(i,j)==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="TASK-2-maxTileExists-Board-b"><a href="#TASK-2-maxTileExists-Board-b" class="headerlink" title="TASK 2: maxTileExists(Board b)"></a>TASK 2: maxTileExists(Board b)</h2><p>是否有数字已经等于2048。和上面一样遍历即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true if any tile is equal to the maximum valid value.</span></span><br><span class="line"><span class="comment"> * Maximum valid value is given by MAX_PIECE. Note that</span></span><br><span class="line"><span class="comment"> * given a Tile object t, we get its value with t.value().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">maxTileExists</span><span class="params">(Board b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> b.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b.tile(i,j)==<span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(b.tile(i,j).value()==MAX_PIECE) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="TASK-3-atLeastOneMoveExists-Board-b"><a href="#TASK-3-atLeastOneMoveExists-Board-b" class="headerlink" title="TASK 3: atLeastOneMoveExists(Board b)"></a>TASK 3: atLeastOneMoveExists(Board b)</h2><p>用户起码还能再走一步的检测函数。首先就是如果有空格子一定可以走，其次是如果有相邻的数相同也可以走。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true if there are any valid moves on the board.</span></span><br><span class="line"><span class="comment"> * There are two ways that there can be valid moves:</span></span><br><span class="line"><span class="comment"> * 1. There is at least one empty space on the board.</span></span><br><span class="line"><span class="comment"> * 2. There are two adjacent tiles with the same value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">atLeastOneMoveExists</span><span class="params">(Board b)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dx = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] dy = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> b.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b.tile(i,j)==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i+dx[k];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> j+dy[k];</span><br><span class="line">                    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=length||y&lt;<span class="number">0</span>||y&gt;=length) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(b.tile(x,y)==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(b.tile(x,y).value()==b.tile(i,j).value()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="TASK4-Main-Task-Building-the-Game-Logic"><a href="#TASK4-Main-Task-Building-the-Game-Logic" class="headerlink" title="TASK4: Main Task: Building the Game Logic"></a>TASK4: Main Task: Building the Game Logic</h2><p>最主要的逻辑部分。主要实现了根据不同方向进行<code>move</code>操作，使得数字向指定方向移动并合并。<br>主要规则：  </p><ul><li>在一次整体移动中，如果两个数合并过了，那么就不能和其他数字进行合并。</li><li>每一次合并得到的值也是玩家得到的分数。  </li></ul><p><strong>解决方案：</strong>  </p><ol><li>分四个方向进行，先完成<code>NORTH</code>方向的移动，其他方向照猫画虎即可。</li><li>根据移动方向选择遍历的次序，如向上移动，我们需要从最上方一行进行遍历，移动后保证最上方没有空格子出现。</li><li>对于已经合并的位置进行标记，用<code>merge[][]</code>进行了标记。</li><li>对于每个已经移动的方块，要及时<code>break</code>退出</li><li>由于向指定方向移动的时候只有在搜索到有数字的格子才进行判断并移动，用<code>nullTileRow</code>和<code>nullTileCol</code>进行记录空格子的位置，防止格子的指定方向上只有空格子的方向而没有进行移动的情况发生。</li><li>每当<code>move</code>执行都要更改<code>changed</code>为<code>true</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Tilt the board toward SIDE. Return true iff this changes the board.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. If two Tile objects are adjacent in the direction of motion and have</span></span><br><span class="line"><span class="comment"> *    the same value, they are merged into one Tile of twice the original</span></span><br><span class="line"><span class="comment"> *    value and that new value is added to the score instance variable</span></span><br><span class="line"><span class="comment"> * 2. A tile that is the result of a merge will not merge again on that</span></span><br><span class="line"><span class="comment"> *    tilt. So each move, every tile will only ever be part of at most one</span></span><br><span class="line"><span class="comment"> *    merge (perhaps zero).</span></span><br><span class="line"><span class="comment"> * 3. When three adjacent tiles in the direction of motion have the same</span></span><br><span class="line"><span class="comment"> *    value, then the leading two tiles in the direction of motion merge,</span></span><br><span class="line"><span class="comment"> *    and the trailing tile does not.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tilt</span><span class="params">(Side side)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> changed;</span><br><span class="line">    changed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Modify this.board (and perhaps this.score) to account</span></span><br><span class="line">    <span class="comment">// for the tilt to the Side SIDE. If the board changed, set the</span></span><br><span class="line">    <span class="comment">// changed local variable to true.</span></span><br><span class="line">    <span class="type">boolean</span>[][] merge = <span class="keyword">new</span> <span class="title class_">boolean</span>[board.size()][board.size()];</span><br><span class="line">    <span class="keyword">if</span>(side==Side.NORTH)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; board.size(); col++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> board.size()-<span class="number">1</span>; row &gt;= <span class="number">0</span>; row--)&#123;</span><br><span class="line">                <span class="type">Tile</span> <span class="variable">t</span> <span class="operator">=</span> board.tile(col, row);</span><br><span class="line">                <span class="keyword">if</span>(t!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> nullTileRow=row;</span><br><span class="line">                    <span class="type">boolean</span> tchanged=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> row+<span class="number">1</span>; k &lt;=<span class="number">3</span>; k++)&#123;</span><br><span class="line">                        <span class="type">Tile</span> <span class="variable">above</span> <span class="operator">=</span> board.tile(col, k);</span><br><span class="line">                        <span class="keyword">if</span>(above==<span class="literal">null</span>)&#123;</span><br><span class="line">                            nullTileRow = k;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">if</span>(above.value()!=t.value()||merge[col][k])&#123;</span><br><span class="line">                                <span class="keyword">if</span>(k-<span class="number">1</span>!=row)&#123;</span><br><span class="line">                                    board.move(col,k-<span class="number">1</span>,t);</span><br><span class="line">                                    changed = <span class="literal">true</span>;</span><br><span class="line">                                    tchanged=<span class="literal">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                board.move(col,k,t);</span><br><span class="line">                                merge[col][k]=<span class="literal">true</span>;</span><br><span class="line">                                <span class="built_in">this</span>.score += t.value()*<span class="number">2</span>;</span><br><span class="line">                                changed = <span class="literal">true</span>;</span><br><span class="line">                                tchanged=<span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!tchanged)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(nullTileRow!=row) &#123;</span><br><span class="line">                            board.move(col,nullTileRow,t);</span><br><span class="line">                            changed = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(side==Side.SOUTH)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; board.size(); col++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; board.size(); row++)&#123;</span><br><span class="line">                <span class="type">Tile</span> <span class="variable">t</span> <span class="operator">=</span> board.tile(col, row);</span><br><span class="line">                <span class="keyword">if</span>(t!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> nullTileRow=row;</span><br><span class="line">                    <span class="type">boolean</span> tchanged=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> row-<span class="number">1</span>; k &gt;=<span class="number">0</span>; k--)&#123;</span><br><span class="line">                        <span class="type">Tile</span> <span class="variable">above</span> <span class="operator">=</span> board.tile(col, k);</span><br><span class="line">                        <span class="keyword">if</span>(above==<span class="literal">null</span>)&#123;</span><br><span class="line">                            nullTileRow = k;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">if</span>(above.value()!=t.value()||merge[col][k])&#123;</span><br><span class="line">                                <span class="keyword">if</span>(k+<span class="number">1</span>!=row)&#123;</span><br><span class="line">                                    board.move(col,k+<span class="number">1</span>,t);</span><br><span class="line">                                    changed = <span class="literal">true</span>;</span><br><span class="line">                                    tchanged=<span class="literal">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                board.move(col,k,t);</span><br><span class="line">                                merge[col][k]=<span class="literal">true</span>;</span><br><span class="line">                                <span class="built_in">this</span>.score += t.value()*<span class="number">2</span>;</span><br><span class="line">                                changed = <span class="literal">true</span>;</span><br><span class="line">                                tchanged=<span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!tchanged)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(nullTileRow!=row) &#123;</span><br><span class="line">                            board.move(col,nullTileRow,t);</span><br><span class="line">                            changed = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(side==Side.WEST)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; board.size(); col++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> board.size()-<span class="number">1</span>; row &gt;= <span class="number">0</span>; row--)&#123;</span><br><span class="line">                <span class="type">Tile</span> <span class="variable">t</span> <span class="operator">=</span> board.tile(col, row);</span><br><span class="line">                <span class="keyword">if</span>(t!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> nullTileCol=col;</span><br><span class="line">                    <span class="type">boolean</span> tchanged=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> col-<span class="number">1</span>; k &gt;= <span class="number">0</span>; k--)&#123;</span><br><span class="line">                        <span class="type">Tile</span> <span class="variable">above</span> <span class="operator">=</span> board.tile(k, row);</span><br><span class="line">                        <span class="keyword">if</span>(above==<span class="literal">null</span>)&#123;</span><br><span class="line">                            nullTileCol = k;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">if</span>(above.value()!=t.value()||merge[k][row])&#123;</span><br><span class="line">                                <span class="keyword">if</span>(k+<span class="number">1</span>!=col)&#123;</span><br><span class="line">                                    board.move(k+<span class="number">1</span>,row,t);</span><br><span class="line">                                    changed = <span class="literal">true</span>;</span><br><span class="line">                                    tchanged=<span class="literal">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                board.move(k,row,t);</span><br><span class="line">                                merge[k][row]=<span class="literal">true</span>;</span><br><span class="line">                                <span class="built_in">this</span>.score += t.value()*<span class="number">2</span>;</span><br><span class="line">                                changed = <span class="literal">true</span>;</span><br><span class="line">                                tchanged=<span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!tchanged)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(nullTileCol!=col) &#123;</span><br><span class="line">                            board.move(nullTileCol,row,t);</span><br><span class="line">                            changed = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(side==Side.EAST)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> board.size()-<span class="number">1</span>; col &gt;= <span class="number">0</span>; col--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> board.size()-<span class="number">1</span>; row &gt;= <span class="number">0</span>; row--)&#123;</span><br><span class="line">                <span class="type">Tile</span> <span class="variable">t</span> <span class="operator">=</span> board.tile(col, row);</span><br><span class="line">                <span class="keyword">if</span>(t!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> nullTileCol=col;</span><br><span class="line">                    <span class="type">boolean</span> tchanged=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> col+<span class="number">1</span>; k &lt; board.size(); k++)&#123;</span><br><span class="line">                        <span class="type">Tile</span> <span class="variable">above</span> <span class="operator">=</span> board.tile(k, row);</span><br><span class="line">                        <span class="keyword">if</span>(above==<span class="literal">null</span>)&#123;</span><br><span class="line">                            nullTileCol = k;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">if</span>(above.value()!=t.value()||merge[k][row])&#123;</span><br><span class="line">                                <span class="keyword">if</span>(k-<span class="number">1</span>!=col)&#123;</span><br><span class="line">                                    board.move(k-<span class="number">1</span>,row,t);</span><br><span class="line">                                    changed = <span class="literal">true</span>;</span><br><span class="line">                                    tchanged=<span class="literal">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                board.move(k,row,t);</span><br><span class="line">                                merge[k][row]=<span class="literal">true</span>;</span><br><span class="line">                                <span class="built_in">this</span>.score += t.value()*<span class="number">2</span>;</span><br><span class="line">                                changed = <span class="literal">true</span>;</span><br><span class="line">                                tchanged=<span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!tchanged)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(nullTileCol!=col) &#123;</span><br><span class="line">                            board.move(nullTileCol,row,t);</span><br><span class="line">                            changed = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    checkGameOver();</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">        setChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>这是CS61B 21sp的第0个project，正如老师说的那样，思考过程的重要性是大于代码编写的。我完成这个项目也是花了几个小时的时间（从一开始看描述到完成，估计得6个多小时）。2048作为<code>Oier</code>们喜闻乐见的游戏，没想到我也能进行亲手编写。很期待接下来的project。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS61B 21sp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell 相关</title>
      <link href="/2024/04/16/shell-%E7%9B%B8%E5%85%B3/"/>
      <url>/2024/04/16/shell-%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://youtu.be/Z56Jmr9Z34Q?si=_VH1jttQRmA_-t82">Lecture 1: Course Overview + The Shell (2020)</a><br><a href="https://missing-semester-cn.github.io/2020/course-shell/">对应中文网站</a></p><ul><li><code>date</code> 查看时间</li><li><code>echo Hello\ World</code> 输出Hello World</li><li><code>echo $path</code>  查看电脑有哪些路径</li><li><code>which echo</code>  查看echo命令会执行哪里的文件</li><li><code>pwd</code> Print Working Directory，即打印当前工作目录</li><li><code>cd ./home</code>  打开当前目录下home文件夹</li><li><code>ls</code> “list” 的缩写，表示列出目录中的文件和子目录</li><li><code>cd</code> ||<code>cd ~</code>  take you home </li><li><code>cd -</code>  返回刚才所在文件夹，常用于cd ~ 后</li><li><code>ls -l</code> 长格式显示目录内容,包括文件权限、所有者、文件大小、最后修改时间等</li><li><code>mv file.txt newfile.txt</code> 重新命名文件</li><li><code>mv file.txt directory/</code> 移动文件到指定目录中</li><li><code>cp file.txt directory/</code> 复制文件到指定文件夹</li><li><code>cp file.txt directory/newfile.txt</code> 复制文件到指定文件夹并重命名</li><li><code>rm file.txt</code> 删除指定文件，不能删除文件夹及里面的内容</li><li><code>rm -r directory</code> 删除指定文件夹及其内容，能进行递归删除</li><li><code>rmdir</code> 仅能删除空文件夹</li><li><code>mkdir My\ Photos</code> 创建My Photos文件夹，或者用双引号包围带空格的名称<ul><li><code>mkdir My Photos</code> 创建My文件夹和Photos文件夹</li></ul></li><li><code>ctrl</code>+<code>l</code> clear your terminal and go back to the top</li><li><p><code>&gt; file</code>和<code>&lt; file</code><br>  <code>&gt; file</code> 和 <code>&lt;file</code> 重定向符号，用于输入和输出文件。</p><ul><li><p><code>&gt;</code> 符号用于将命令的输出重定向到一个文件中。例如，<code>ls &gt; file.txt</code> 将 <code>ls</code> 命令的输出写入到 <code>file.txt</code> 文件中，如果文件不存在则创建，如果文件已经存在则覆盖原有内容。</p></li><li><p><code>&lt;</code> 符号用于将一个文件的内容作为输入提供给命令。例如，<code>cat &lt; file.txt</code> 将 <code>file.txt</code> 文件的内容作为 <code>cat</code> 命令的输入，<code>cat</code> 命令会将文件的内容输出到终端上。</p></li></ul></li><li><code>cat filename</code> 显示一个文件的内容。  <ul><li><code>cat</code> 命令还有一些常用的选项，例如 <code>-n</code> 选项用于显示行号，<code>-b</code> 选项用于显示非空行的行号，<code>-E</code> 选项用于在每行的末尾显示一个 <code>$</code> 符号等。</li><li><code>cat &lt; hello.txt &gt; hello2.txt</code> 将<code>hello.txt</code>的内容覆盖写入<code>hello2.txt</code><br>-<code>cat &lt; hello.txt &gt;&gt; hello2.txt</code> 将内容append到<code>hello2.txt</code></li></ul></li><li><code>ls -l | tail -n1</code> 其中 <code>|</code> 组成命令行管道，用于将一个命令的输出作为另一个命令的输入</li><li><code>sudo su</code> 切换为root用户</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tarjan算法</title>
      <link href="/2024/04/15/tarjan%E7%AE%97%E6%B3%95/"/>
      <url>/2024/04/15/tarjan%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="tarjan-算法（Tarjan’s-strongly-connected-components-algorithm）"><a href="#tarjan-算法（Tarjan’s-strongly-connected-components-algorithm）" class="headerlink" title="tarjan 算法（Tarjan’s strongly connected components algorithm）"></a>tarjan 算法（Tarjan’s strongly connected components algorithm）</h1><p><a href="https://youtu.be/wUgWX0nc4NY?si=pbuZzimi3Nep-z36">很棒的解释视频</a></p><h2 id="简述算法"><a href="#简述算法" class="headerlink" title="简述算法"></a>简述算法</h2><p>Tarjan 算法是一种用于查找图中强连通分量的算法，由 Robert Tarjan 在 1972 年提出。强连通分量是指在有向图中，如果从顶点 u 到顶点 v 以及从顶点 v 到顶点 u 都存在一条路径，那么顶点 u 和顶点 v 是强连通的。</p><p>Tarjan 算法的核心思想是通过深度优先搜索（DFS）遍历图，并使用堆栈来追踪搜索过程中的顶点。在遍历的过程中，对每个顶点进行标记，记录其在搜索树中的深度和最小后向边的深度。如果发现某个顶点的后继节点指向了一个已经被访问过的顶点，那么这个顶点及其所有后继节点构成一个强连通分量。</p><p>Tarjan 算法的关键点在于维护一个栈，用来保存正在搜索的节点。当 DFS 遍历过程中发现一个节点的所有后继节点已经搜索完毕，并且该节点是当前 DFS 搜索树中的根节点时，可以将该节点以及其所有后继节点弹出栈，并将它们标记为一个强连通分量。</p><p>Tarjan 算法的时间复杂度为 O(V + E)，其中 V 表示图中的顶点数，E 表示图中的边数。由于只需要一次 DFS 遍历即可找到所有的强连通分量，因此 Tarjan 算法是一种高效的强连通分量查找算法。</p><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>首先什么是<strong>强连通分量</strong>。就是有向图中一些点，如果每两个点之间互相都有一条到达对方的道路，那么这些点就组成了强连通分量（Strongly Connected Component，简称 SCC）。  </p><p>我们可以想象为每一个SCC就是一个家庭，如果送报纸的话只需要给家庭中任意一个人就行了，因为他们每个人都可以在看完报纸后递给另一个家人。显然我们可以进行<strong>缩点</strong>了。从之前人与人之间的联系上升到家庭与家庭之间的关系。但是因为是有向图，SCC之间可能有边相连，但是是单向的，所以家庭之间并不能合并为同一个SCC。但是在一个家庭所有成员读完报纸后可以委托一个有出边的人去把报纸给邻居（另一个SCC）。  </p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>在此并不证明算法的正确性。现在只聊一聊算法是怎么实现的。  </p><p>首先就是<code>dfn[]</code>和<code>low[]</code>数组。对于图的遍历选择dfs（Depth-First Search）。<code>dfn[]</code>数组记录遍历点的次序。通常为每遍历到一个点，计数器+1，此点的<code>dfn</code>值即为计数器的值。而<code>low[]</code>数组则为记录该点以及其子节点最小的<code>dfn</code>值。  </p><p>如果我们想要知道每个SCC中成员都有谁，那么我们需要在遍历点的同时再将点压入栈<code>stack s</code>内。同时我们需要知道该点是否在栈内，定义一个记录数组<code>onStack[]</code>,如果节点<code>i</code>在栈内，那么<code>onStack[i]=1</code>。如果点的标值不是从<code>1~n</code>连续的，可能需要<code>hash</code>处理。</p><p>那么我们在回过头讨论<code>dfn</code>和<code>low</code>。对于不在栈内的节点，我们直接<code>low[u]=min(low[u],low[v])</code>进行更新。其中<code>u</code>为当前节点，<code>v</code>为<code>u</code>的子节点。对于已经在栈内的子节点，我们通过<code>low[u]=min(low[u],dfn[v])</code>更新。我们可以想象有向图中边一直往前冲，突然有一个边是往回走的，这样就会连接到刚才已经遍历过的点（可能形成一个环），但是这种边我们需要判断是否连接到了另一个SCC，所以我们需要记录点是否在栈内，如果在栈内说明两个点属于同一个SCC，所以可以更新，如果不在，就不能更新当前点的<code>low</code>值。  </p><p><strong>数据出栈</strong>。对于遍历完所有子节点的点来说，如果<code>dfn[u]==low[u]</code>那么说明这是一个SCC。栈内点一个个出栈直到当前点出栈，出栈的所有点即为一个SCC的所有点。定义<code>sccs[]</code>数组记录点所属于的SCC。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><p><a href="https://github.com/williamfiset/Algorithms/blob/da50861a53fc2f6642cfc7d82c285166f41d03e2/src/main/java/com/williamfiset/algorithms/graphtheory/TarjanSccSolverAdjacencyList.java">摘自github</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An implementation of Tarjan&#x27;s Strongly Connected Components algorithm using an adjacency list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Verified against:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;https://open.kattis.com/problems/equivalences</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;https://open.kattis.com/problems/runningmom</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;https://www.hackerearth.com/practice/algorithms/graphs/strongly-connected-components/tutorial</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Time complexity: O(V+E)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> William Fiset, william.alexandre.fiset@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.williamfiset.algorithms.graphtheory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.min;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TarjanSccSolverAdjacencyList</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">  <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; graph;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> solved;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> sccCount, id;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span>[] visited;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span>[] ids, low, sccs;</span><br><span class="line">  <span class="keyword">private</span> Deque&lt;Integer&gt; stack;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNVISITED</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TarjanSccSolverAdjacencyList</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (graph == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Graph cannot be null.&quot;</span>);</span><br><span class="line">    n = graph.size();</span><br><span class="line">    <span class="built_in">this</span>.graph = graph;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the number of strongly connected components in the graph.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sccCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!solved) solve();</span><br><span class="line">    <span class="keyword">return</span> sccCount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the connected components of this graph. If two indexes</span></span><br><span class="line">  <span class="comment">// have the same value then they&#x27;re in the same SCC.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] getSccs() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!solved) solve();</span><br><span class="line">    <span class="keyword">return</span> sccs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (solved) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    ids = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    low = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    sccs = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    Arrays.fill(ids, UNVISITED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ids[i] == UNVISITED) &#123;</span><br><span class="line">        dfs(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    solved = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> at)</span> &#123;</span><br><span class="line">    ids[at] = low[at] = id++;</span><br><span class="line">    stack.push(at);</span><br><span class="line">    visited[at] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> to : graph.get(at)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ids[to] == UNVISITED) &#123;</span><br><span class="line">        dfs(to);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (visited[to]) &#123;</span><br><span class="line">        low[at] = min(low[at], low[to]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       TODO(william): investigate whether the proper way to update the lowlinks</span></span><br><span class="line"><span class="comment">       is the following bit of code. From my experience this doesn&#x27;t seem to</span></span><br><span class="line"><span class="comment">       matter if the output is placed in a separate output array, but this needs</span></span><br><span class="line"><span class="comment">       further investigation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       if (ids[to] == UNVISITED) &#123;</span></span><br><span class="line"><span class="comment">         dfs(to);</span></span><br><span class="line"><span class="comment">         low[at] = min(low[at], low[to]);</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">       if (visited[to]) &#123;</span></span><br><span class="line"><span class="comment">         low[at] = min(low[at], ids[to]);</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// On recursive callback, if we&#x27;re at the root node (start of SCC)</span></span><br><span class="line">    <span class="comment">// empty the seen stack until back to root.</span></span><br><span class="line">    <span class="keyword">if</span> (ids[at] == low[at]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop(); ; node = stack.pop()) &#123;</span><br><span class="line">        visited[node] = <span class="literal">false</span>;</span><br><span class="line">        sccs[node] = sccCount;</span><br><span class="line">        <span class="keyword">if</span> (node == at) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      sccCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initializes adjacency list with n nodes.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">createGraph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Adds a directed edge from node &#x27;from&#x27; to node &#x27;to&#x27;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, <span class="type">int</span> from, <span class="type">int</span> to)</span> &#123;</span><br><span class="line">    graph.get(from).add(to);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Example usage: */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = createGraph(n);</span><br><span class="line"></span><br><span class="line">    addEdge(graph, <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">    addEdge(graph, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line">    addEdge(graph, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    addEdge(graph, <span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">    addEdge(graph, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    addEdge(graph, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    addEdge(graph, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    addEdge(graph, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    addEdge(graph, <span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">    addEdge(graph, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">    addEdge(graph, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    addEdge(graph, <span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line">    addEdge(graph, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">TarjanSccSolverAdjacencyList</span> <span class="variable">solver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TarjanSccSolverAdjacencyList</span>(graph);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] sccs = solver.getSccs();</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; multimap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!multimap.containsKey(sccs[i])) multimap.put(sccs[i], <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">      multimap.get(sccs[i]).add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prints:</span></span><br><span class="line">    <span class="comment">// Number of Strongly Connected Components: 3</span></span><br><span class="line">    <span class="comment">// Nodes: [0, 1, 2] form a Strongly Connected Component.</span></span><br><span class="line">    <span class="comment">// Nodes: [3, 7] form a Strongly Connected Component.</span></span><br><span class="line">    <span class="comment">// Nodes: [4, 5, 6] form a Strongly Connected Component.</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;Number of Strongly Connected Components: %d\n&quot;</span>, solver.sccCount());</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; scc : multimap.values()) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Nodes: &quot;</span> + scc + <span class="string">&quot; form a Strongly Connected Component.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p><a href="https://www.luogu.com.cn/problem/P2002">对应洛谷题目</a><br>如果SCC之间有边相邻，只需通知一个SCC即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mxlen = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> pre[mxlen],last[mxlen/<span class="number">5</span>],other[mxlen],l;</span><br><span class="line"><span class="type">int</span> cnt,sccCount;</span><br><span class="line"><span class="type">int</span> dfn[mxlen/<span class="number">5</span>],low[mxlen/<span class="number">5</span>],onStack[mxlen/<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> sccFlags[mxlen/<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> sccIndice[mxlen/<span class="number">5</span>];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    l++;</span><br><span class="line">    pre[l]=last[x];</span><br><span class="line">    last[x]=l;</span><br><span class="line">    other[l]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    dfn[x]=low[x]=cnt;</span><br><span class="line">    onStack[x]=<span class="number">1</span>;</span><br><span class="line">    s.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=last[x];p;p=pre[p])&#123;</span><br><span class="line">        <span class="type">int</span> y=other[p];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(onStack[y])&#123;</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">        sccCount++;</span><br><span class="line">        <span class="keyword">while</span>(s.<span class="built_in">top</span>()!=x)&#123;</span><br><span class="line">            sccIndice[s.<span class="built_in">top</span>()]=sccCount;</span><br><span class="line">            onStack[s.<span class="built_in">top</span>()]=<span class="number">0</span>;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        sccIndice[x]=sccCount;</span><br><span class="line">        onStack[x]=<span class="number">0</span>;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkPropagation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=last[i];p;p=pre[p])&#123;</span><br><span class="line">            <span class="type">int</span> y=other[p];</span><br><span class="line">            <span class="keyword">if</span>(sccIndice[i]!=sccIndice[y])&#123;</span><br><span class="line">                sccFlags[sccIndice[y]]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">add</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">checkPropagation</span>();</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sccCount;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!sccFlags[i]) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tarjan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>verbal advantage level 2 1-20</title>
      <link href="/2024/04/14/verbal-advantage-level-2-1-20/"/>
      <url>/2024/04/14/verbal-advantage-level-2-1-20/</url>
      
        <content type="html"><![CDATA[<h1 id="word-1-10"><a href="#word-1-10" class="headerlink" title="word 1-10"></a>word 1-10</h1><h2 id="word-1-advocate-提倡，拥护，主张"><a href="#word-1-advocate-提倡，拥护，主张" class="headerlink" title="word 1: advocate 提倡，拥护，主张"></a>word 1: <strong>advocate</strong> 提倡，拥护，主张</h2><p>Similarly, many are now aware of this polarized notion of the field and some have begun to advocate possible alternatives.</p><h2 id="word-2-delegate-委托，托付"><a href="#word-2-delegate-委托，托付" class="headerlink" title="word 2: delegate 委托，托付"></a>word 2: <strong>delegate</strong> 委托，托付</h2><p>However, these delegates saw their efforts as serving purposes beyond profit generation.</p><h2 id="word-3-unprecedented-前所未有的，史无前例的"><a href="#word-3-unprecedented-前所未有的，史无前例的" class="headerlink" title="word 3: unprecedented 前所未有的，史无前例的"></a>word 3: <strong>unprecedented</strong> 前所未有的，史无前例的</h2><p>With the surge of population and economic activity during the past two generations or so, the environment has come under unprecedented stress.</p><h2 id="word-4-poignant-尖锐的，强烈的，酸楚的"><a href="#word-4-poignant-尖锐的，强烈的，酸楚的" class="headerlink" title="word 4: poignant 尖锐的，强烈的，酸楚的"></a>word 4: <strong>poignant</strong> 尖锐的，强烈的，酸楚的</h2><p>The women’s stories are at once poignant and remarkable.</p><h2 id="word-5-nebulous-朦胧的，模糊的"><a href="#word-5-nebulous-朦胧的，模糊的" class="headerlink" title="word 5: nebulous 朦胧的，模糊的"></a>word 5: <strong>nebulous</strong> 朦胧的，模糊的</h2><p>The authors admit that their subject matter is nebulous and its meanings ambiguous.</p><h2 id="word-6-clandestine-秘密的，暗中的"><a href="#word-6-clandestine-秘密的，暗中的" class="headerlink" title="word 6: clandestine 秘密的，暗中的"></a>word 6: <strong>clandestine</strong> 秘密的，暗中的</h2><p>They have wanted war, they have been waging it upon us for three years, but in a clandestine, hypocritical, roundabout manner.</p><h2 id="word-7-tirade-（激烈的）长篇演说"><a href="#word-7-tirade-（激烈的）长篇演说" class="headerlink" title="word 7: tirade （激烈的）长篇演说"></a>word 7: <strong>tirade</strong> （激烈的）长篇演说</h2><p>The whole of his speech has been directed as a tirade against and an attack upon trade unionism.</p><h2 id="word-8-recur-重现"><a href="#word-8-recur-重现" class="headerlink" title="word 8: recur 重现"></a>word 8: <strong>recur</strong> 重现</h2><p>Yet in the midst of this diversity, at least four themes recur.</p><h2 id="word-9-tacit-缄默的，默许的"><a href="#word-9-tacit-缄默的，默许的" class="headerlink" title="word 9: tacit 缄默的，默许的"></a>word 9: <strong>tacit</strong> 缄默的，默许的</h2><p>There is a tacit but quite unjustified assumption in traditional grammar that nouns can appear in adjunct function only when accompanied by an explicit dependent.</p><h2 id="word-10-allegation-宣称，断言，指控"><a href="#word-10-allegation-宣称，断言，指控" class="headerlink" title="word 10: allegation 宣称，断言，指控"></a>word 10: <strong>allegation</strong> 宣称，断言，指控</h2><p>Surprisingly, the source for this serious allegation is not identified.</p><h1 id="word-11-20"><a href="#word-11-20" class="headerlink" title="word 11-20"></a>word 11-20</h1><h2 id="word-11-gullible-轻信的，易受骗的"><a href="#word-11-gullible-轻信的，易受骗的" class="headerlink" title="word 11: gullible 轻信的，易受骗的"></a>word 11: <strong>gullible</strong> 轻信的，易受骗的</h2><p>Not only are the public often assumed to be a trifle gullible, they are also portrayed as empty vessels.</p><h2 id="word-12-benign-和蔼的，良性的，吉利的"><a href="#word-12-benign-和蔼的，良性的，吉利的" class="headerlink" title="word 12: benign 和蔼的，良性的，吉利的"></a>word 12: <strong>benign</strong> 和蔼的，良性的，吉利的</h2><p>The chance of malignant degeneration in a benign papillioma is not well understood.</p><h2 id="word-13-peripheral-外围的，不重要的"><a href="#word-13-peripheral-外围的，不重要的" class="headerlink" title="word 13: peripheral 外围的，不重要的"></a>word 13: <strong>peripheral</strong> 外围的，不重要的</h2><p>The book contains a great deal of peripheral detail.</p><h2 id="word-14-rebuff-断然拒绝，回绝"><a href="#word-14-rebuff-断然拒绝，回绝" class="headerlink" title="word 14: rebuff 断然拒绝，回绝"></a>word 14: <strong>rebuff</strong> 断然拒绝，回绝</h2><p>She rebuffed all suggestions that she should resign.</p><h2 id="word-15-animosity-敌意，仇恨"><a href="#word-15-animosity-敌意，仇恨" class="headerlink" title="word 15: animosity 敌意，仇恨"></a>word 15: <strong>animosity</strong> 敌意，仇恨</h2><p>Of course we’re competitive, but there’s no personal animosity between us.</p><h2 id="word-16-tenuous-纤细的，脆弱的"><a href="#word-16-tenuous-纤细的，脆弱的" class="headerlink" title="word 16: tenuous 纤细的，脆弱的"></a>word 16: <strong>tenuous</strong> 纤细的，脆弱的</h2><p>The police have only found a tenuous connection between the two robberies.</p><h2 id="word-17-complacent-自满的，沾沾自喜的"><a href="#word-17-complacent-自满的，沾沾自喜的" class="headerlink" title="word 17: complacent 自满的，沾沾自喜的"></a>word 17: <strong>complacent</strong> 自满的，沾沾自喜的</h2><p>We can’t afford to become complacent about any of our products.</p><h2 id="word-18-acme-顶端，最高点"><a href="#word-18-acme-顶端，最高点" class="headerlink" title="word 18: acme 顶端，最高点"></a>word 18: <strong>acme</strong> 顶端，最高点</h2><p>To act on this world-famous stage is surely the acme of any actor’s career.</p><h2 id="word-19-defunct-失效的，不在世的"><a href="#word-19-defunct-失效的，不在世的" class="headerlink" title="word 19: defunct 失效的，不在世的"></a>word 19: <strong>defunct</strong> 失效的，不在世的</h2><p>(humorous) I think this TV is defunct!</p><h2 id="word-20-abet-支持，煽动，教唆"><a href="#word-20-abet-支持，煽动，教唆" class="headerlink" title="word 20: abet 支持，煽动，教唆"></a>word 20: <strong>abet</strong> 支持，煽动，教唆</h2><p>His accountant had aided and abetted him in the fraud.</p>]]></content>
      
      
      <categories>
          
          <category> VERBAL ADVANTAGE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac电脑vscode的c++运行配置</title>
      <link href="/2024/04/13/mac%E7%94%B5%E8%84%91vscode%E7%9A%84c-%E8%BF%90%E8%A1%8C%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/04/13/mac%E7%94%B5%E8%84%91vscode%E7%9A%84c-%E8%BF%90%E8%A1%8C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>最近换了电脑，vscode的环境是重新配的，遇到了些许问题。</p><h1 id="1-Code-Runner-对于C-的一些函数不识别"><a href="#1-Code-Runner-对于C-的一些函数不识别" class="headerlink" title="1. Code Runner 对于C++的一些函数不识别"></a>1. Code Runner 对于C++的一些函数不识别</h1><p>这是因为code runner默认执行命令里没有添加c++17的选项。<br>解决方案：  </p><ol><li>打开vscode设置，搜索<code>code runner</code>，找到<code>Code-runner: Executor Map</code>，点击<code>edit in settings.json</code>。</li><li>Find the <code>cpp</code> and add <code>-std=c++17</code> after <code>cd $dir &amp;&amp; g++</code> Like this <code>&quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ -std=c++17 $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;</code>  <h1 id="2-Code-Runner-运行C-是在OUTPUT里运行的，不能通过键盘输入数据"><a href="#2-Code-Runner-运行C-是在OUTPUT里运行的，不能通过键盘输入数据" class="headerlink" title="2. Code Runner 运行C++是在OUTPUT里运行的，不能通过键盘输入数据"></a>2. Code Runner 运行C++是在OUTPUT里运行的，不能通过键盘输入数据</h1>解决方案：<br>打开vscode设置，搜索<code>code runner</code>，勾选<code>Code-runner: Run In Terminal</code><h1 id="3-vscode-不识别-include-lt-bits-stdc-h-gt"><a href="#3-vscode-不识别-include-lt-bits-stdc-h-gt" class="headerlink" title="3. vscode 不识别#include&lt;bits/stdc++.h&gt;"></a>3. vscode 不识别<code>#include&lt;bits/stdc++.h&gt;</code></h1><h2 id="我有问过chatgpt关于为什么mac没有这个库，回答是这样的："><a href="#我有问过chatgpt关于为什么mac没有这个库，回答是这样的：" class="headerlink" title="我有问过chatgpt关于为什么mac没有这个库，回答是这样的："></a>我有问过chatgpt关于为什么mac没有这个库，回答是这样的：</h2><code>#include&lt;bits/stdc++.h&gt;</code> 是一个常用的 C++ 头文件，它包含了常用的标准库和一些常见的标准头文件。在一些编译器和环境中，这个头文件是存在的，但并不是所有的环境都支持它。</li></ol><p>在 macOS 上，通常使用的是 <strong>Clang</strong> 或者 GNU 编译器集合中的 Clang。Clang 是一个优秀的 C++ 编译器，它支持大多数 C++11、C++14、C++17 和部分 C++20 特性，但并不提供 <code>#include&lt;bits/stdc++.h&gt;</code> 这个头文件。</p><p>这个头文件通常出现在一些 Windows 平台上的编译器（比如 MinGW 和 Visual C++）中，用于方便包含所有标准库的头文件。但是在其他平台，比如 macOS 上，通常需要明确地包含所需的标准库头文件，例如 <code>&lt;iostream&gt;</code>, <code>&lt;vector&gt;</code>, <code>&lt;algorithm&gt;</code> 等。</p><p>所以，在 macOS 上编写 C++ 代码时，你需要根据具体需要，显式地包含你需要的标准库头文件，而不依赖于 <code>#include&lt;bits/stdc++.h&gt;</code>。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>实际上万能头不就是把所有库都import一遍而已。解决方案我看的这一篇<a href="https://www.cnblogs.com/lipoicyclic/p/14623307.html">博客</a>。我在此基础上优化了一部分步骤，更加简洁。</p><ol><li>终端中输入<code>echo | g++ -v -x c++ -E -</code>, 其中<code>/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include</code> 即为我们要找的路径。</li><li>修改include文件夹的访问权限为读写。<code>sudo chmod 777 /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include</code> </li><li>直接<code>cd /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include</code></li><li>创建<code>bits</code>文件夹并进入。<code>mkdir bits</code>,<code>cd bits/</code></li><li>创建<code>stdc++.h</code>，<code>touch stdc++.h</code> </li><li>打开刚刚创建的文件，<code>open stdc++.h</code>，这时应该是默认vscode进行打开的。进行编辑：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ includes used for precompiling -*- C++ -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copyright (C) 2003-2014 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file is part of the GNU ISO C++ Library.  This library is free</span></span><br><span class="line"><span class="comment">// software; you can redistribute it and/or modify it under the</span></span><br><span class="line"><span class="comment">// terms of the GNU General Public License as published by the</span></span><br><span class="line"><span class="comment">// Free Software Foundation; either version 3, or (at your option)</span></span><br><span class="line"><span class="comment">// any later version.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// This library is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment">// GNU General Public License for more details.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Under Section 7 of GPL version 3, you are granted additional</span></span><br><span class="line"><span class="comment">// permissions described in the GCC Runtime Library Exception, version</span></span><br><span class="line"><span class="comment">// 3.1, as published by the Free Software Foundation.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// You should have received a copy of the GNU General Public License and</span></span><br><span class="line"><span class="comment">// a copy of the GCC Runtime Library Exception along with this program;</span></span><br><span class="line"><span class="comment">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</span></span><br><span class="line"><span class="comment">// &lt;http://www.gnu.org/licenses/&gt;.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/** @file stdc++.h</span></span><br><span class="line"><span class="comment"> *  This is an implementation file for a precompiled header.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 17.4.1.2 Headers</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GLIBCXX_NO_ASSERT</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cfloat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ciso646&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csetjmp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ccomplex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cfenv&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cinttypes&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdbool&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctgmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cwchar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cwctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iosfwd&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;istream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;streambuf&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;valarray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;scoped_allocator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;system_error&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeindex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>最后保存退出即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
            <tag> mac </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面试准备整理(二)</title>
      <link href="/2024/04/11/java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E6%95%B4%E7%90%86-%E4%BA%8C/"/>
      <url>/2024/04/11/java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E6%95%B4%E7%90%86-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="1-缓存雪崩、缓存穿透、缓存击穿在实际中如何处理"><a href="#1-缓存雪崩、缓存穿透、缓存击穿在实际中如何处理" class="headerlink" title="1. 缓存雪崩、缓存穿透、缓存击穿在实际中如何处理"></a>1. 缓存雪崩、缓存穿透、缓存击穿在实际中如何处理</h2><p>名词解释：  </p><ol><li><p><strong>缓存雪崩（Cache Avalanche）</strong>：指在缓存中大量的缓存条目在同一时间段内失效或者过期，导致大量请求直接访问底层存储系统（如数据库），从而造成系统性能急剧下降或者崩溃的现象。</p></li><li><p><strong>缓存穿透（Cache Penetration）</strong>：指恶意或者非法的请求直接穿过缓存层，访问底层存储系统，因为缓存层无法命中任何缓存数据。通常是由于查询不存在的数据或者恶意构造的查询条件导致。</p></li><li><p><strong>缓存击穿（Cache Breakdown）</strong>：指在缓存中存在的数据，在即将过期或者失效时，被大量的请求同时访问，导致缓存失效，直接击穿缓存层，访问底层存储系统。</p></li></ol><p>如何处理这些问题：</p><ul><li><p><strong>缓存雪崩处理方法</strong>：</p><ul><li>设置合理的缓存失效时间，避免所有缓存同时失效。</li><li>实现缓存预热，在缓存失效前提前加载数据到缓存中。</li><li>使用多级缓存架构，如本地缓存和分布式缓存，降低单点故障风险。</li><li>引入缓存锁定机制，在缓存失效时只允许一个请求重新加载缓存数据，其他请求等待。</li></ul></li><li><p><strong>缓存穿透处理方法</strong>：</p><ul><li>对于查询数据库中不存在的数据，也将其缓存，但是设置一个较短的过期时间，避免攻击者频繁查询不存在的数据导致大量请求直接击穿缓存到达数据库。</li><li>使用布隆过滤器等技术对请求参数进行校验，过滤掉明显无效的请求。</li></ul></li><li><p><strong>缓存击穿处理方法</strong>：</p><ul><li>对于热点数据或者频繁访问的数据，可以设置永不过期，或者通过手动更新缓存来确保数据不会过期。</li><li>引入互斥锁或者分布式锁，保证在缓存失效时只有一个请求能够重新加载数据，其他请求等待。</li></ul></li></ul><p>以上处理方法可以根据具体场景和需求进行组合使用，以尽可能地减少缓存相关问题对系统稳定性和性能的影响。</p><h2 id="2-Mysql-的隔离级别有哪些？"><a href="#2-Mysql-的隔离级别有哪些？" class="headerlink" title="2. Mysql 的隔离级别有哪些？"></a>2. Mysql 的隔离级别有哪些？</h2><p>MySQL支持四种隔离级别，分别是：</p><ol><li><p><strong>读未提交（Read Uncommitted）</strong>：最低的隔离级别。在这个级别下，一个事务可以看到其他事务未提交的数据修改。这意味着其他事务对数据的修改可能会导致脏读（Dirty Read）问题。</p></li><li><p><strong>读已提交（Read Committed）</strong>：这是MySQL默认的隔离级别。在这个级别下，一个事务只能看到已经提交的数据修改。其他事务对数据的修改不会被当前事务看到，这可以避免脏读问题，但是可能导致不可重复读（Non-repeatable Read）问题。</p></li><li><p><strong>可重复读（Repeatable Read）</strong>：在这个级别下，一个事务在执行期间多次读取同一行数据时，得到的结果是一致的。即使其他事务对数据进行了修改，当前事务在同一事务内读取数据时也不会看到其他事务对数据的修改。这可以避免不可重复读问题，但是可能导致幻读（Phantom Read）问题。</p></li><li><p><strong>串行化（Serializable）</strong>：这是最高的隔离级别。在这个级别下，每个事务都会在一个独立的时间段内执行，彼此之间不会相互干扰。这可以避免脏读、不可重复读和幻读等所有并发问题，但是会降低并发性能，因为事务需要串行执行。</p></li></ol><p>选择合适的隔离级别取决于应用的需求以及对并发性能和数据一致性的要求。</p><h2 id="3-mysql的复制原理是什么？"><a href="#3-mysql的复制原理是什么？" class="headerlink" title="3. mysql的复制原理是什么？"></a>3. mysql的复制原理是什么？</h2><p>MySQL的复制是指将一个MySQL数据库的数据复制到另一个MySQL实例上的过程，其基本原理如下：</p><ol><li><p><strong>主从复制架构</strong>：MySQL复制基于主从（Master-Slave）架构。在这种架构中，一个MySQL实例作为主服务器（Master），负责接收客户端的写操作（INSERT、UPDATE、DELETE等），而其他MySQL实例作为从服务器（Slave），负责接收主服务器的写操作并复制其数据。</p></li><li><p><strong>二进制日志（Binary Log）</strong>：主服务器上的数据更改操作会被记录到二进制日志中，这些日志记录了对数据的所有修改操作，包括对数据的增、删、改等。二进制日志是主从复制的关键，从服务器通过读取主服务器上的二进制日志来获取需要复制的数据变更。</p></li><li><p><strong>复制线程</strong>：从服务器上会启动一个复制线程（Replication Thread），该线程负责连接到主服务器，并获取主服务器上的二进制日志。从服务器上的复制线程会解析主服务器上的二进制日志，并将其中的数据变更操作应用到自己的数据库中，从而保持与主服务器上相同的数据状态。</p></li><li><p><strong>复制过程</strong>：复制过程分为两个阶段。首先是复制的初始化阶段，从服务器连接到主服务器并请求二进制日志的位置，然后从服务器根据主服务器上的二进制日志位置开始复制数据。其次是复制的持续阶段，从服务器持续地读取主服务器上的二进制日志，将数据变更操作应用到自己的数据库中，保持与主服务器数据的一致性。</p></li></ol><p>通过以上原理，MySQL的复制实现了数据在不同MySQL实例之间的同步，从而提供了数据的备份、负载均衡以及故障恢复等功能。</p><h2 id="4-mysql聚簇和非聚簇索引的区别是什么"><a href="#4-mysql聚簇和非聚簇索引的区别是什么" class="headerlink" title="4. mysql聚簇和非聚簇索引的区别是什么"></a>4. mysql聚簇和非聚簇索引的区别是什么</h2><p>在MySQL中，聚簇索引和非聚簇索引是两种不同类型的索引结构，它们在数据存储和访问方式上有着显著的区别。</p><ol><li><p><strong>聚簇索引（Clustered Index）</strong>：</p><ul><li>聚簇索引中，索引和数据行存储在同一个B树（或B+树）结构中，也就是说索引的叶子节点包含了实际的数据行。在MySQL中，InnoDB存储引擎的主键索引就是一个聚簇索引。</li><li>由于<strong>数据行和索引在物理上存储在一起</strong>，因此通过聚簇索引进行数据检索时，可以直接定位到数据所在的磁盘页，减少了额外的IO操作，因此查询效率更高。</li><li>聚簇索引的缺点是，当表中的数据行被频繁更新时，可能导致数据页的分裂和重新组织，增加了维护索引的成本。</li></ul></li><li><p><strong>非聚簇索引（Non-Clustered Index）</strong>：</p><ul><li>非聚簇索引中，<strong>索引和数据行是分开存储的</strong>。索引的叶子节点包含了指向对应数据行的指针（或者叫引用），而数据行存储在另外的位置。在MySQL中，InnoDB存储引擎的普通索引（非主键索引）就是非聚簇索引。</li><li>当使用非聚簇索引进行数据检索时，首先通过索引找到对应数据行的指针，然后再根据指针访问实际的数据行，因此需要多一次IO操作，相比于聚簇索引来说，查询效率较低。</li><li>非聚簇索引的优点是，由于索引和数据行分开存储，当数据行发生更新时，不会影响到索引的结构，因此维护索引的成本相对较低。</li></ul></li></ol><p>总的来说，聚簇索引和非聚簇索引在数据存储和访问方式上有着明显的区别，选择合适的索引类型取决于应用的需求和查询模式。</p><h2 id="5-mysql索引的基本原理"><a href="#5-mysql索引的基本原理" class="headerlink" title="5. mysql索引的基本原理"></a>5. mysql索引的基本原理</h2><p>MySQL索引的基本原理是通过创建索引数据结构来加快数据库的查询速度。索引是一种特殊的数据结构，它存储了列值和这些列值对应的行的位置，使得数据库系统可以更快地定位和检索数据。</p><p>以下是MySQL索引的基本原理：</p><ol><li><p><strong>B-Tree索引</strong>：MySQL通常使用B-Tree（平衡树）索引来实现索引。B-Tree是一种多路搜索树，它能够快速地定位到指定值。B-Tree索引将数据按照排序规则存储在树结构中，使得每个节点都包含有序的键值对。这样一来，MySQL可以通过这个树结构快速地定位到所需的数据。</p></li><li><p><strong>唯一性</strong>：索引可以是唯一的或非唯一的。唯一索引确保索引列中的值是唯一的，这意味着在查询时可以通过索引快速定位到唯一的行。非唯一索引允许索引列中存在重复值，但同样可以加速查询。</p></li><li><p><strong>覆盖索引</strong>：当查询的列都包含在索引中时，MySQL可以直接从索引中获取所需的数据，而无需再去查找数据行。这样的索引称为覆盖索引，可以大大减少数据库访问的次数，从而提高查询性能。</p></li><li><p><strong>索引选择性</strong>：索引的选择性是指索引列中不同值的个数与表中记录总数的比值。选择性越高，意味着索引越能准确地过滤数据，从而提高查询效率。通常情况下，选择性在30%到70%之间是比较理想的。</p></li><li><p><strong>索引优化</strong>：对于大型表和频繁查询的列，建立索引可以显著提高查询性能。但过多的索引可能会增加插入、更新和删除操作的成本，因为每次修改数据都需要更新索引。因此，在建立索引时需要权衡查询性能和数据修改成本。</p></li></ol><p>综上所述，MySQL索引的基本原理是利用B-Tree等数据结构来加速数据的定位和检索，从而提高数据库的查询性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| Storage Engine | Permitted Indexes   |</span><br><span class="line">|----------------|----------------------|</span><br><span class="line">| Aria           | BTREE, RTREE         |</span><br><span class="line">| MyISAM         | BTREE, RTREE         |</span><br><span class="line">| InnoDB         | BTREE                |</span><br><span class="line">| MEMORY/HEAP    | HASH, BTREE          |</span><br></pre></td></tr></table></figure><p><strong>InnoDB存储引擎默认B+Tree索引</strong><br><strong>Memory存储引擎默认Hash索引</strong><br>MySQL支持多种存储引擎，每种引擎都有其自己的特点、优势和适用场景。以下是MySQL常见的几种存储引擎：</p><ol><li><p><strong>InnoDB</strong>：InnoDB是MySQL的默认存储引擎，也是最常用的存储引擎之一。它支持事务、行级锁定和外键约束，提供了较高的数据完整性和并发性能。InnoDB适用于需要较高并发性和数据完整性的应用场景，例如在线交易处理（OLTP）系统。</p></li><li><p><strong>MyISAM</strong>：MyISAM是MySQL的另一种常用存储引擎，它具有较高的插入和查询速度，适用于读密集型应用。但是，MyISAM不支持事务和行级锁定，并且在崩溃时数据恢复能力较差。因此，它适用于对数据完整性要求不高、读操作频繁、写操作较少的场景，例如数据仓库或日志分析系统。</p></li><li><p><strong>MEMORY (HEAP)</strong>：MEMORY存储引擎将表数据存储在内存中，因此具有非常高的读写速度。但是，由于数据存储在内存中，因此在重启服务器或关闭MySQL时，数据会丢失。MEMORY存储引擎适用于临时表、缓存表和需要快速访问的临时数据存储场景。</p></li><li><p><strong>CSV</strong>：CSV存储引擎将数据存储在逗号分隔值（CSV）格式的文件中，适用于数据交换和导入导出操作。</p></li><li><p><strong>Archive</strong>：Archive存储引擎用于存储大量历史数据，它采用压缩算法对数据进行压缩，从而节省存储空间。Archive存储引擎适用于只需偶尔访问的归档数据存储场景。</p></li><li><p><strong>NDB Cluster</strong>：NDB Cluster存储引擎是MySQL Cluster的一部分，它提供了高可用性、高性能和分布式存储的特性。NDB Cluster适用于需要分布式数据库和实时数据访问的应用场景，如电话网络、网络游戏等。</p></li></ol><p>每种存储引擎都有其独特的优势和适用场景，选择合适的存储引擎需要根据应用的需求和特点进行综合考虑。</p><h2 id="6-B-树在实现索引上的优势以及过程"><a href="#6-B-树在实现索引上的优势以及过程" class="headerlink" title="6. B+树在实现索引上的优势以及过程"></a>6. B+树在实现索引上的优势以及过程</h2><p>B+树是一种常用的数据结构，用于实现索引，特别是在数据库系统中。它具有以下优势：</p><ol><li><p><strong>高效的查找操作：</strong> B+树的结构使得在其中进行查找、插入和删除等操作的时间复杂度为O(log n)，其中n是数据的数量。这意味着无论数据量多大，操作的时间复杂度都是可控的，并且随着数据量增长的增长速率很慢。</p></li><li><p><strong>有序性：</strong> B+树是一种有序树，因此在范围查询时非常高效。例如，如果需要在一个有序的数据集合中查找所有在某个范围内的元素，那么B+树可以迅速定位到该范围内的所有数据。</p></li><li><p><strong>可预测的IO访问：</strong> B+树的结构使得在磁盘上进行IO访问时，访问的次数可预测且较少。这是因为B+树的节点通常大小固定，并且树的高度相对较低，这减少了需要在磁盘上进行的IO次数。</p></li><li><p><strong>支持范围查询和排序：</strong> 由于B+树是有序的，因此支持在范围内查询和排序操作。这对于数据库系统中许多类型的查询非常重要。</p></li></ol><p>B+树的实现过程通常分为插入、删除和查找等基本操作。下面是B+树的基本实现过程：</p><ol><li><p><strong>插入操作：</strong></p><ul><li>从根节点开始，沿着树向下遍历，找到合适的叶子节点。</li><li>如果叶子节点没有满，则将新元素插入其中，然后对树进行必要的调整以保持B+树的性质。</li><li>如果叶子节点已满，则进行分裂操作，将节点一分为二，并将中间值提升到父节点中。然后对树进行必要的调整以保持B+树的性质。</li></ul></li><li><p><strong>删除操作：</strong></p><ul><li>从根节点开始，沿着树向下遍历，找到要删除的元素所在的叶子节点。</li><li>如果叶子节点中存在要删除的元素，则删除该元素，并对树进行必要的调整以保持B+树的性质。</li><li>如果删除元素后，节点的元素个数小于某个阈值，则进行合并或者借用兄弟节点的操作，以保持树的平衡。</li></ul></li><li><p><strong>查找操作：</strong></p><ul><li>从根节点开始，沿着树向下遍历，根据节点中的键值进行比较，确定要查找的元素位于哪个子树中。</li><li>如果查找的元素位于叶子节点中，则直接在叶子节点中查找。</li><li>如果查找的元素不在叶子节点中，则继续向下遍历。</li></ul></li></ol><p>通过这些基本操作，B+树可以保持其有序性和平衡性，从而提供高效的索引支持。</p><h2 id="7-mysql锁的类型有哪些"><a href="#7-mysql锁的类型有哪些" class="headerlink" title="7. mysql锁的类型有哪些"></a>7. mysql锁的类型有哪些</h2><p><a href="https://juejin.cn/post/6931752749545553933">https://juejin.cn/post/6931752749545553933</a></p><h2 id="8-mysql为什么需要主从同步"><a href="#8-mysql为什么需要主从同步" class="headerlink" title="8. mysql为什么需要主从同步"></a>8. mysql为什么需要主从同步</h2><p>MySQL主从同步是一种数据库复制技术，通过在主数据库上的更改同步到一个或多个从数据库上，以确保数据的冗余备份、提高系统可用性、增加读取性能、以及提供灾难恢复能力。以下是主从同步的一些重要用途和原因：</p><ol><li><p><strong>数据备份和冗余：</strong> 主从同步可以在从数据库上创建主数据库的副本，从而实现数据的冗余备份。如果主数据库发生故障，从数据库可以快速接管服务，保证系统的可用性和数据的安全。</p></li><li><p><strong>读写分离：</strong> 主从同步允许在从数据库上进行读操作，从而分担主数据库的读取负载。这样可以提高系统的读取性能和并发处理能力。</p></li><li><p><strong>灾难恢复：</strong> 如果主数据库发生故障或数据丢失，从数据库可以作为备份数据源，用于灾难恢复和数据修复。</p></li><li><p><strong>分布式数据处理：</strong> 主从同步可以用于分布式数据处理，允许在不同地理位置或网络环境下的数据库之间同步数据，从而实现分布式计算和数据分析。</p></li><li><p><strong>数据库升级和迁移：</strong> 主从同步可以在数据库升级或迁移过程中保持数据的一致性，降低系统停机时间和风险。</p></li><li><p><strong>数据分发：</strong> 主从同步可以用于将数据分发到多个地理位置或不同的应用系统中，实现数据共享和数据集成。</p></li></ol><p>总之，MySQL主从同步是一种重要的数据库复制技术，可以提高系统的可用性、可靠性和性能，同时也可以为数据管理和应用开发提供更多的灵活性和便利性。</p><h2 id="9-mysql执行计划怎么看"><a href="#9-mysql执行计划怎么看" class="headerlink" title="9. mysql执行计划怎么看"></a>9. mysql执行计划怎么看</h2><p>在MySQL中，你可以使用<code>EXPLAIN</code>语句来查看查询的执行计划。执行计划是MySQL查询优化器根据表结构、索引情况等信息，预估的查询执行过程。通过执行计划，你可以了解查询是如何执行的，以及MySQL是如何选择使用索引、连接方式等来执行查询的。</p><p>下面是使用<code>EXPLAIN</code>语句查看执行计划的基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> your_condition;</span><br></pre></td></tr></table></figure><p>其中，<code>your_table</code>是要查询的表名，<code>your_condition</code>是查询条件。</p><p>执行该<code>EXPLAIN</code>语句后，MySQL会返回一张查询计划表，其中包含了查询的执行步骤、使用的索引、每一步的估算行数等信息。以下是一些常见的执行计划字段含义：</p><ul><li><code>id</code>: 查询执行步骤的顺序，从上到下递增。</li><li><code>select_type</code>: 查询的类型，如<code>SIMPLE</code>、<code>PRIMARY</code>、<code>SUBQUERY</code>等。</li><li><code>table</code>: 此行正在访问的表。</li><li><code>type</code>: 表示查询的访问类型，如<code>ALL</code>、<code>INDEX</code>、<code>RANGE</code>、<code>REF</code>等。访问类型的好坏决定了查询的性能。</li><li><code>possible_keys</code>: 可能用到的索引。</li><li><code>key</code>: 实际用到的索引。</li><li><code>key_len</code>: 索引的长度。</li><li><code>ref</code>: 表示哪个列或常量与索引一起使用。</li><li><code>rows</code>: 估计检索出的行数。</li><li><code>Extra</code>: 额外信息，如<code>Using where</code>、<code>Using index</code>等。</li></ul><p>通过分析执行计划，你可以评估查询的性能，优化查询语句以提高数据库的性能。通常的优化方式包括创建合适的索引、优化查询语句等。</p><h2 id="10-GC如何判断对象可以被回收"><a href="#10-GC如何判断对象可以被回收" class="headerlink" title="10. GC如何判断对象可以被回收"></a>10. GC如何判断对象可以被回收</h2><p>在Java中，垃圾收集器（Garbage Collector，GC）通过一些策略来判断对象是否可以被回收。下面是一些常见的判断对象是否可回收的条件：</p><ol><li><p><strong>引用计数法（Reference Counting）：</strong> 该方法并不常用，但是它是一种简单的垃圾回收算法。对象被分配一定数量的引用计数，当引用计数为零时，说明对象不再被引用，可以被回收。但这种方法不能解决循环引用问题。</p></li><li><p><strong>可达性分析（Reachability Analysis）：</strong> Java的主要垃圾收集器使用这种方式。可达性分析是基于“GC Roots”对象作为起始点，然后通过一系列的引用链（对象之间的引用关系）来判断对象是否可以被访问。如果对象不可通过任何引用链与“GC Roots”对象连接，那么它就是不可达的，可以被回收。</p></li><li><p><strong>标记-清除算法（Mark and Sweep）：</strong> 这是一种基于可达性分析的垃圾回收算法。在标记阶段，垃圾收集器标记所有与“GC Roots”对象直接或间接相连的对象。在清除阶段，垃圾收集器清除所有未标记的对象，即不可达的对象。</p></li><li><p><strong>复制算法（Copying）和标记-整理算法（Mark and Compact）：</strong> 这两种算法通常用于新生代和老年代的垃圾回收，其基本思想与标记-清除算法类似，但实现方式不同。复制算法将内存空间分为两部分，每次只使用其中一部分，当该部分内存满时，将存活对象复制到另一部分中，并清除非存活对象。标记-整理算法则是在标记-清除的基础上，将存活对象整理到内存的一端，以减少内存碎片。</p></li></ol><p>总的来说，GC判断对象是否可被回收的主要依据是对象是否可以被访问到，即对象是否可达。通过分析对象之间的引用关系，GC可以确定哪些对象不再被引用，从而将它们回收释放内存。</p><h2 id="11-JVM8为什么要增加元空间"><a href="#11-JVM8为什么要增加元空间" class="headerlink" title="11. JVM8为什么要增加元空间"></a>11. JVM8为什么要增加元空间</h2><p>Java 8 引入了元空间（Metaspace）以替代永久代（PermGen），主要出于以下几个原因：</p><ol><li><p><strong>解决永久代的限制：</strong> 永久代的大小在运行时是固定的，并且由于它是 JVM 内存中的一部分，因此其大小受到整个 JVM 堆大小的限制。这导致了在某些情况下永久代可能会发生内存溢出的问题，特别是在动态生成大量类或者字符串的场景下。</p></li><li><p><strong>更好的内存管理：</strong> 元空间不再是 JVM 内存的一部分，而是使用本地内存来存储类的元数据。这使得元空间的大小可以根据需要动态调整，而不受 JVM 堆大小的限制。这样可以更好地适应不同应用程序的内存需求。</p></li><li><p><strong>提高性能：</strong> 元空间的管理相比于永久代更为简单高效。在永久代中，类的元数据会被频繁地加载和卸载，而元空间采用了基于指针的内存分配方式，减少了垃圾回收的次数，提高了性能。</p></li><li><p><strong>避免永久代内存泄漏问题：</strong> 在永久代中，由于类的元数据存储在堆中，如果出现类加载器内存泄漏或者不正确使用 <code>ClassLoader</code>，容易导致永久代内存泄漏。而元空间将类的元数据存储在本地内存中，避免了这些问题。</p></li><li><p><strong>更好的垃圾回收机制：</strong> 元空间采用了与 Java 堆相同的垃圾回收机制，如并发标记-清除、并发标记-整理等，这使得垃圾回收更加灵活和高效。</p></li></ol><p>综上所述，引入元空间主要是为了解决永久代的限制，提高内存管理的灵活性和效率，从而提升 Java 应用程序的性能和稳定性。</p><h2 id="12-JVM内存模型如何分配的"><a href="#12-JVM内存模型如何分配的" class="headerlink" title="12. JVM内存模型如何分配的"></a>12. JVM内存模型如何分配的</h2><p>Java 虚拟机（JVM）内存模型包括了多个不同的区域，用于存储不同类型的数据和执行不同的操作。下面是 JVM 内存模型的主要分配区域：</p><ol><li><p><strong>堆（Heap）：</strong> 堆是 JVM 中最大的一块内存区域，用于存储对象实例和数组。堆是由所有线程共享的内存区域，在 JVM 启动时就被创建。堆的大小可以通过 JVM 参数进行调整，通常被划分为新生代和老年代。新生代包括了 Eden 空间和两个 Survivor 空间，而老年代则用于存放长期存活的对象。</p></li><li><p><strong>方法区（Method Area）：</strong> 方法区也被称为永久代（PermGen，Java 8 后被替代为元空间 Metaspace），用于存储类的结构信息、静态变量、常量池等数据。方法区是所有线程共享的内存区域，当类加载器加载类时，类的结构信息会被存储在方法区中。</p></li><li><p><strong>虚拟机栈（VM Stack）：</strong> 每个线程都有自己的虚拟机栈，用于存储方法调用的栈帧。栈帧包括了局部变量表、操作数栈、动态链接、方法返回地址等信息。虚拟机栈中的栈帧随着方法的调用和返回而动态地压栈和弹栈。</p></li><li><p><strong>本地方法栈（Native Method Stack）：</strong> 本地方法栈与虚拟机栈类似，用于执行本地方法（Native Method）的栈帧。与虚拟机栈不同的是，本地方法栈用于执行本地方法，而虚拟机栈用于执行 Java 方法。</p></li><li><p><strong>程序计数器（Program Counter Register）：</strong> 程序计数器是每个线程私有的，用于存储当前线程正在执行的 Java 字节码指令地址。在线程执行 Java 方法时，程序计数器会记录下一条需要执行的指令地址，当线程被切换时，程序计数器用于恢复线程执行状态。</p></li></ol><p>以上是 JVM 内存模型中的主要分配区域，不同的区域用于存储不同类型的数据和执行不同的操作。这些区域的内存分配和回收由 JVM 运行时系统自动管理，开发人员一般不需要显式地管理这些内存区域。</p><h2 id="13-JVM性能调优概述"><a href="#13-JVM性能调优概述" class="headerlink" title="13. JVM性能调优概述"></a>13. JVM性能调优概述</h2><p>JVM（Java虚拟机）性能调优是优化Java应用程序的性能，使其在吞吐量、响应时间、资源利用率等方面达到最佳状态的一系列操作。以下是对JVM性能调优的概述：</p><ol><li><p><strong>内存管理：</strong></p><ul><li>调整堆大小：根据应用程序的内存需求和性能目标，通过设置-Xms和-Xmx参数来调整堆大小，避免内存不足或过度使用内存的情况。</li><li>选择垃圾收集器：根据应用程序的特点和性能需求，选择合适的垃圾收集器，如串行收集器、并行收集器、CMS收集器、G1收集器等。</li><li>设置垃圾收集器参数：根据应用程序的特点和性能需求，通过设置垃圾收集器相关参数来调整垃圾收集器的行为，如堆大小、垃圾收集策略、线程数量等。</li></ul></li><li><p><strong>线程管理：</strong></p><ul><li>优化线程池配置：合理配置线程池的大小、队列大小、线程存活时间等参数，以提高线程的利用率和性能。</li><li>减少线程竞争：避免过度使用同步机制，减少线程之间的竞争，提高并发性能。</li></ul></li><li><p><strong>类加载优化：</strong></p><ul><li>预加载类：通过-Xbootclasspath参数预加载常用的类，加快类加载速度。</li><li>避免动态类加载：减少或避免使用反射和动态代理等动态类加载技术，以提高类加载性能。</li></ul></li><li><p><strong>代码优化：</strong></p><ul><li>减少对象创建：避免频繁创建和销毁对象，重用对象或者使用对象池来减少内存分配和垃圾回收开销。</li><li>使用高效的数据结构和算法：选择合适的数据结构和算法来提高程序的性能，如使用ArrayList代替LinkedList，使用HashMap代替Hashtable等。</li></ul></li><li><p><strong>I/O优化：</strong></p><ul><li>使用NIO代替传统的IO操作：使用Java的NIO（New I/O）提供的非阻塞IO功能来提高IO操作的性能。</li><li>使用缓冲流：使用缓冲流来减少IO操作的次数，提高IO操作的效率。</li></ul></li><li><p><strong>监控与调优：</strong></p><ul><li>使用JVM监控工具：使用JVisualVM、JConsole、VisualVM等监控工具来监控JVM的运行状态和性能指标，及时发现和解决性能瓶颈。</li><li>基准测试和性能分析：通过基准测试和性能分析工具来评估应用程序的性能，并找出影响性能的关键因素，进行针对性的调优。</li></ul></li></ol><p>综上所述，JVM性能调优涉及到多个方面，包括内存管理、线程管理、类加载优化、代码优化、I/O优化等，通过合理的调优措施可以提高Java应用程序的性能和稳定性。</p><h2 id="14-JVM有哪些垃圾回收器？实际中如何选择？"><a href="#14-JVM有哪些垃圾回收器？实际中如何选择？" class="headerlink" title="14. JVM有哪些垃圾回收器？实际中如何选择？"></a>14. JVM有哪些垃圾回收器？实际中如何选择？</h2><p>Java虚拟机（JVM）中有多种垃圾回收器，每种垃圾回收器都有不同的优缺点，适用于不同类型的应用场景。以下是常见的JVM垃圾回收器：</p><ol><li><p><strong>串行垃圾收集器（Serial Garbage Collector）：</strong> 串行垃圾收集器是最基本的垃圾收集器，它使用单个线程进行垃圾收集，适用于小型应用或者开发调试阶段。</p></li><li><p><strong>并行垃圾收集器（Parallel Garbage Collector）：</strong> 并行垃圾收集器也被称为吞吐量优先收集器，它使用多个线程进行垃圾收集，适用于多核服务器和多线程应用，以最大化吞吐量。</p></li><li><p><strong>并发标记清除收集器（Concurrent Mark-Sweep Garbage Collector，CMS GC）：</strong> CMS GC是一种低延迟垃圾收集器，它在尽量减少停顿时间的同时，还要保持较高的吞吐量，适用于对响应时间要求较高的应用。</p></li><li><p><strong>G1垃圾收集器（Garbage-First Garbage Collector）：</strong> G1垃圾收集器是一种面向服务器的垃圾收集器，它在尽量减少停顿时间的同时，还能在不同内存区域之间进行垃圾回收，适用于大内存、多核服务器环境。</p></li></ol><p>在实际中，选择垃圾回收器应考虑以下几个方面：</p><ol><li><p><strong>应用需求：</strong> 不同的应用对垃圾回收器的要求不同。例如，对于对响应时间要求较高的应用，应选择低延迟的垃圾收集器，如CMS GC或G1 GC；而对于对吞吐量要求较高的应用，应选择吞吐量优先的垃圾收集器，如Parallel GC。</p></li><li><p><strong>硬件环境：</strong> 垃圾收集器的性能受到硬件环境的影响。例如，并行垃圾收集器在多核服务器上表现更好，而G1垃圾收集器适用于大内存服务器环境。</p></li><li><p><strong>内存配置：</strong> 垃圾收集器的性能与内存配置有关。例如，CMS GC和G1 GC更适用于大内存配置，而串行垃圾收集器和并行垃圾收集器适用于小内存配置。</p></li><li><p><strong>JDK版本：</strong> 不同版本的JDK可能会引入新的垃圾收集器或优化现有的垃圾收集器，因此选择垃圾收集器时应考虑JDK的版本。</p></li></ol><p>综上所述，选择垃圾收集器应综合考虑应用需求、硬件环境、内存配置和JDK版本等因素，根据具体情况进行选择。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面试准备整理(一)</title>
      <link href="/2024/04/07/java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E6%95%B4%E7%90%86-%E4%B8%80/"/>
      <url>/2024/04/07/java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E6%95%B4%E7%90%86-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-java面向对象有哪些特征"><a href="#1-java面向对象有哪些特征" class="headerlink" title="1. java面向对象有哪些特征"></a>1. java面向对象有哪些特征</h2><p>面向对象的三大特征：<strong>封装、继承、多态</strong></p><h2 id="2-ArrayList和LinkedList的区别"><a href="#2-ArrayList和LinkedList的区别" class="headerlink" title="2. ArrayList和LinkedList的区别"></a>2. ArrayList和LinkedList的区别</h2><p>都实现了<code>List</code>接口。<br><code>ArrayList</code>是基于索引的数据接口，底层是数组。<br><code>LinkedList</code>(链表)是以元素列表的形式存储数据。</p><h2 id="3-高并发中的集合有哪些问题"><a href="#3-高并发中的集合有哪些问题" class="headerlink" title="3. 高并发中的集合有哪些问题"></a>3. 高并发中的集合有哪些问题</h2><h3 id="1-第一代线程安全集合类"><a href="#1-第一代线程安全集合类" class="headerlink" title="1. 第一代线程安全集合类"></a>1. 第一代线程安全集合类</h3><p><code>Vector</code>、<code>Hashtable</code>。使用<code>synchronized</code>。效率低下。</p><h3 id="2-第二代"><a href="#2-第二代" class="headerlink" title="2. 第二代"></a>2. 第二代</h3><p><code>ArrayList</code>、<code>HashMap</code>。使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedList(list);</span><br><span class="line">Collections.synchronizedMap(m);</span><br></pre></td></tr></table></figure></p><h3 id="3-第三代"><a href="#3-第三代" class="headerlink" title="3. 第三代"></a>3. 第三代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.*</span><br><span class="line">ConcurrentHashMap</span><br><span class="line">CopyOnWriteArrayList</span><br><span class="line">CopyOnWriteArraySet</span><br></pre></td></tr></table></figure><p>Java 中的高并发环境下使用集合可能会遇到以下问题：</p><ol><li><p><strong>线程安全性问题</strong>：Java 中的大多数集合类（如 <code>ArrayList</code>、<code>HashMap</code> 等）在多线程环境下不是线程安全的，因此可能会导致数据不一致或者其他意外行为。</p></li><li><p><strong>性能问题</strong>：在高并发环境下，如果使用线程安全的集合类（如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等），可能会引入额外的性能开销，因为它们通常会使用同步或者复制等机制来保证线程安全。</p></li><li><p><strong>迭代器失效问题</strong>：在使用迭代器遍历集合时，如果其他线程对集合进行了修改，可能会导致迭代器失效，抛出 <code>ConcurrentModificationException</code> 异常。</p></li><li><p><strong>死锁问题</strong>：如果在高并发环境下不正确地使用集合，可能会出现死锁问题，例如两个线程分别持有集合中的不同锁，并试图获取对方持有的锁。</p></li><li><p><strong>内存泄漏问题</strong>：如果不正确地使用集合，可能会导致内存泄漏问题，例如在高并发环境下频繁地向集合中添加元素但未及时删除，可能会导致集合持有过多的引用而无法被及时回收。</p></li></ol><p>为了解决这些问题，可以采用以下方法：</p><ul><li>使用线程安全的集合类，如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等。</li><li>使用同步机制来保证多线程访问的安全性，例如使用 <code>synchronized</code> 关键字或者 <code>ReentrantLock</code> 类。</li><li>避免在迭代集合时对集合进行修改，可以使用迭代器的安全删除操作或者将集合复制一份后再进行操作。</li><li>注意合理设计并发访问的逻辑，避免死锁等并发问题的发生。</li><li>注意集合的内存使用情况，避免内存泄漏问题的发生。<h2 id="4-JDK1-8的新特性有哪些"><a href="#4-JDK1-8的新特性有哪些" class="headerlink" title="4. JDK1.8的新特性有哪些"></a>4. JDK1.8的新特性有哪些</h2>由于要兼容Lambda表达式，接口里实现了默认方法，接口中带了实现。<br>函数式接口<br>支持了多重注解<br>Java 8 引入了许多重要的新特性，其中一些最显着的包括：</li></ul><ol><li><p><strong>Lambda 表达式</strong>：Lambda 表达式是一种匿名函数，它可以作为参数传递给方法或者作为函数式接口的实例使用，极大地简化了代码的编写和阅读。</p></li><li><p><strong>Stream API</strong>：Stream API 提供了一种声明式的方式来操作集合，可以轻松地进行过滤、映射、排序、聚合等操作，大大提高了代码的简洁性和可读性。</p></li><li><p><strong>函数式接口</strong>：Java 8 引入了 <code>@FunctionalInterface</code> 注解，用于标识函数式接口，即只包含一个抽象方法的接口。这种接口可以被 Lambda 表达式直接实现，使得函数式编程更加方便。</p></li><li><p><strong>方法引用</strong>：方法引用允许通过方法的名字来引用方法，而不需要像 Lambda 表达式那样提供方法的完整定义，可以进一步简化代码。</p></li><li><p><strong>默认方法</strong>：接口中可以定义默认方法，这些方法可以在接口中提供默认的实现，从而在接口的实现类中直接使用，而无需重新实现。</p></li><li><p><strong>Optional 类</strong>：Optional 类是一个容器对象，用于包装可能为 null 的值，可以避免空指针异常，并提供了一些便利的方法来处理可能为 null 的值。</p></li><li><p><strong>新的日期和时间 API</strong>：Java 8 引入了 <code>java.time</code> 包，提供了全新的日期和时间 API，解决了旧的 <code>java.util.Date</code> 和 <code>java.util.Calendar</code> API 的许多问题，例如线程安全性和易用性。</p></li><li><p><strong>CompletableFuture 类</strong>：CompletableFuture 类提供了一种便利的方式来进行异步编程，可以轻松地处理异步任务的完成和组合。</p></li></ol><p>这些新特性使得 Java 8 成为一个重要的版本，为 Java 编程带来了许多新的可能性和优势。</p><h2 id="5-Java接口和抽象类有哪些区别"><a href="#5-Java接口和抽象类有哪些区别" class="headerlink" title="5. Java接口和抽象类有哪些区别"></a>5. Java接口和抽象类有哪些区别</h2><p>语法的区别<br>语义的区别：什么时候用接口，什么时候用抽象类。<br>抽象类面对的是一个概念，动物，哺乳动物，植物，有具体概念的建议用抽象类去实现。<br>接口描述的是某些共同特征，比如flyable</p><h2 id="6-hashcode和equals如何使用"><a href="#6-hashcode和equals如何使用" class="headerlink" title="6. hashcode和equals如何使用"></a>6. hashcode和equals如何使用</h2><p>在Java中，<code>hashCode()</code>和<code>equals()</code>方法是用于处理对象相等性和哈希值计算的两个重要方法。</p><ol><li><p><code>hashCode()</code>方法：</p><ul><li><code>hashCode()</code>方法用于返回对象的哈希码（hash code），它是一个32位的整数。</li><li>哈希码用于快速定位对象在哈希表中的位置，因此它对于实现高效的数据结构如HashMap、HashSet等非常重要。</li><li>在实现<code>hashCode()</code>方法时，通常需要遵循以下约定：<ul><li>如果两个对象根据<code>equals()</code>方法相等，则它们的哈希码必须相等。</li><li>但是，两个对象的哈希码相等并不意味着它们相等，即对于不同的对象，哈希码可能相同（哈希冲突）。</li></ul></li><li>如果重写了<code>equals()</code>方法，则通常也需要重写<code>hashCode()</code>方法，以保持对象相等性和哈希码一致。</li></ul></li><li><p><code>equals()</code>方法：</p><ul><li><code>equals()</code>方法用于比较两个对象是否相等。在Java中，默认的<code>equals()</code>方法实现是比较对象的引用是否相同（即比较内存地址）。</li><li>通常需要重写<code>equals()</code>方法来定义对象相等的规则。重写<code>equals()</code>方法时，需要遵循以下约定：<ul><li>自反性：对于任何非空引用值<code>x</code>，<code>x.equals(x)</code>必须返回<code>true</code>。</li><li>对称性：对于任何非空引用值<code>x</code>和<code>y</code>，如果<code>x.equals(y)</code>返回<code>true</code>，则<code>y.equals(x)</code>也必须返回<code>true</code>。</li><li>传递性：对于任何非空引用值<code>x</code>、<code>y</code>和<code>z</code>，如果<code>x.equals(y)</code>返回<code>true</code>，<code>y.equals(z)</code>返回<code>true</code>，则<code>x.equals(z)</code>也必须返回<code>true</code>。</li><li>一致性：对于任何非空引用值<code>x</code>和<code>y</code>，如果对象中的信息没有改变，多次调用<code>x.equals(y)</code>应该始终返回相同的结果。</li><li>对于任何非空引用值<code>x</code>，<code>x.equals(null)</code>必须返回<code>false</code>。</li></ul></li><li>重写<code>equals()</code>方法时，需要确保与<code>hashCode()</code>方法一致，即如果两个对象根据<code>equals()</code>方法相等，则它们的哈希码也必须相等。</li></ul></li></ol><p>综上所述，<code>hashCode()</code>和<code>equals()</code>方法在Java中常用于实现对象的相等性比较和哈希值计算，这对于在集合中存储对象、使用哈希表等数据结构非常重要。</p><h2 id="7-java代理的几种实现方式"><a href="#7-java代理的几种实现方式" class="headerlink" title="7. java代理的几种实现方式"></a>7. java代理的几种实现方式</h2><p>静态代理<br>两种动态代理<br>在Java中，代理是一种常见的设计模式，用于控制对其他对象的访问。代理可以在访问对象时添加额外的逻辑，例如日志记录、性能监控、安全控制等。Java中实现代理的几种方式包括：</p><ol><li><p>静态代理：</p><ul><li>静态代理是在编译时确定代理类和被代理类的关系。代理类和被代理类在编译期间就已经确定，代理类通常实现与被代理类相同的接口或者继承相同的父类。</li><li>静态代理的实现比较简单，可以直接在代理类中调用被代理类的方法，并在方法前后添加额外的逻辑。</li></ul></li><li><p>动态代理（JDK动态代理）：</p><ul><li>JDK动态代理是在运行时动态生成代理类的方式。它是通过Java反射机制实现的，在运行时创建代理对象并动态处理对被代理方法的调用。</li><li>JDK动态代理要求被代理的类必须实现接口，代理类通过实现<code>InvocationHandler</code>接口来处理被代理方法的调用。</li></ul></li><li><p>CGLIB代理：</p><ul><li>CGLIB代理是针对类的代理，它通过动态生成被代理类的子类来实现代理。因此，被代理类不需要实现接口，而是通过继承来实现代理。</li><li>CGLIB代理通过字节码技术在运行时创建代理类的子类，并重写其中的方法，在方法前后添加额外的逻辑。</li></ul></li><li><p>Java动态代理与CGLIB代理的比较：</p><ul><li>Java动态代理适用于接口代理，要求被代理的类必须实现接口，因此更加灵活，但是无法对类的非接口方法进行代理。</li><li>CGLIB代理适用于类的代理，不要求被代理的类实现接口，因此更加灵活，可以代理类的任何方法，但是无法代理<code>final</code>方法和<code>private</code>方法。</li></ul></li></ol><p>总的来说，静态代理、JDK动态代理和CGLIB代理是Java中常用的代理实现方式，它们各自具有不同的特点和适用场景，可以根据具体需求选择合适的代理方式。</p><h2 id="8-java中-和-equals-有哪些区别"><a href="#8-java中-和-equals-有哪些区别" class="headerlink" title="8. java中 == 和 equals 有哪些区别"></a>8. java中 == 和 equals 有哪些区别</h2><p><code>==</code> 基本数据类型比较值，引用数据类型比较的地址。<br><code>equals</code> 比较两个对象的内容是否相等</p><h2 id="9-java中异常处理机制是什么"><a href="#9-java中异常处理机制是什么" class="headerlink" title="9. java中异常处理机制是什么"></a>9. java中异常处理机制是什么</h2><p>抛出异常 throw<br>捕获异常 try catch finally<br>声明异常 throws</p><h2 id="10-java中重写和重载有哪些区别"><a href="#10-java中重写和重载有哪些区别" class="headerlink" title="10. java中重写和重载有哪些区别"></a>10. java中重写和重载有哪些区别</h2><p>重载overload：同一个类中，参数不同的<br>重写override：子类和父类中，重写的方法和被重写的方法</p><h2 id="11-String、StringBuffer、StringBuilder区别及使用场景"><a href="#11-String、StringBuffer、StringBuilder区别及使用场景" class="headerlink" title="11. String、StringBuffer、StringBuilder区别及使用场景"></a>11. String、StringBuffer、StringBuilder区别及使用场景</h2><p>String是只读字符串<br><code>String</code>、<code>StringBuffer</code>和<code>StringBuilder</code>是Java中用于处理字符串的三个类，它们在设计和使用上有一些区别，适用于不同的场景：</p><ol><li><p><code>String</code>：</p><ul><li><code>String</code>是不可变的（immutable）类，一旦创建就不能被修改。这意味着每次对<code>String</code>进行修改时，都会创建一个新的<code>String</code>对象，旧的对象会被丢弃，这样会导致性能开销和内存浪费。</li><li>由于<code>String</code>是不可变的，因此它是线程安全的，可以被多个线程安全地共享。</li></ul></li><li><p><code>StringBuffer</code>：</p><ul><li><code>StringBuffer</code>是可变的（mutable）类，它提供了对字符串进行修改的方法，例如<code>append()</code>、<code>insert()</code>、<code>delete()</code>等。因此，对于频繁的字符串拼接或者修改操作，使用<code>StringBuffer</code>会比直接使用<code>String</code>更高效。</li><li><code>StringBuffer</code>是线程安全的，它的方法都是同步的，适用于多线程环境。</li></ul></li><li><p><code>StringBuilder</code>：</p><ul><li><code>StringBuilder</code>与<code>StringBuffer</code>类似，也是可变的字符串序列。但是，与<code>StringBuffer</code>不同的是，<code>StringBuilder</code>的方法都是非同步的，因此在单线程环境下性能更好。</li><li>由于<code>StringBuilder</code>的方法不是同步的，因此它不适用于多线程环境。</li></ul></li></ol><p>使用场景：</p><ul><li>当需要处理不可变的字符串时，例如字符串常量，可以使用<code>String</code>类。</li><li>当需要在单线程环境下进行频繁的字符串操作时，例如字符串拼接、修改等，可以使用<code>StringBuilder</code>。</li><li>当需要在多线程环境下进行字符串操作时，可以使用<code>StringBuffer</code>，因为它是线程安全的，但是性能相对较低，如果不需要线程安全的话，也可以使用<code>StringBuilder</code>。</li></ul><p>综上所述，根据具体需求和线程安全性要求，可以选择使用<code>String</code>、<code>StringBuffer</code>或者<code>StringBuilder</code>来处理字符串。</p><h2 id="12-怎样声明一个类不会被继承，什么场景下会用"><a href="#12-怎样声明一个类不会被继承，什么场景下会用" class="headerlink" title="12. 怎样声明一个类不会被继承，什么场景下会用"></a>12. 怎样声明一个类不会被继承，什么场景下会用</h2><p>用final修饰。例如Math类</p><h2 id="13-自定义异常在生产中如何应用"><a href="#13-自定义异常在生产中如何应用" class="headerlink" title="13. 自定义异常在生产中如何应用"></a>13. 自定义异常在生产中如何应用</h2><p>自定义异常在生产环境中的应用可以提高代码的健壮性、可维护性和可读性，使得异常处理更加规范和易于管理。合理地使用自定义异常可以有效地提高系统的稳定性和可靠性，从而提升用户体验和系统性能。<br>继承合适的父类：自定义异常类应当继承自Exception类或者其子类，例如RuntimeException，以便在异常处理时能够统一处理或者捕获。</p><h2 id="14-Redis线程模型有哪些，单线程为什么快"><a href="#14-Redis线程模型有哪些，单线程为什么快" class="headerlink" title="14. Redis线程模型有哪些，单线程为什么快"></a>14. Redis线程模型有哪些，单线程为什么快</h2><p>Redis的线程模型主要有单线程模型和多线程模型两种。</p><ol><li><p>单线程模型：</p><ul><li>Redis最初采用的是单线程模型。单线程模型指的是Redis服务器在一个线程中顺序地处理所有请求，所有的命令都在一个事件循环中执行。</li><li>单线程模型的优势在于简单高效，因为不需要考虑线程同步和线程切换的开销，避免了多线程并发访问共享数据可能引发的竞态条件和死锁问题。</li><li>Redis单线程模型适用于大多数情况下的数据存储和处理，特别是在单个CPU核心的情况下，单线程模型的性能表现通常比较优秀。</li></ul></li><li><p>多线程模型：</p><ul><li>Redis 6.0 版本引入了多线程模型（Redis主从分离模式），可以充分利用多核CPU的性能，提升服务器的吞吐量和并发处理能力。</li><li>多线程模型将网络IO、命令处理和数据读写等操作分配给多个工作线程处理，可以提高系统的并发处理能力，适用于高并发的场景。</li></ul></li></ol><p>为什么单线程模型在某些情况下会比多线程模型快呢？</p><ol><li><p>线程切换开销：在多线程模型中，由于涉及到线程的创建、销毁和切换，会产生额外的开销，而单线程模型避免了这些开销。</p></li><li><p>CPU缓存优化：单线程模型可以更好地利用CPU缓存，因为数据和指令都在同一个线程中执行，避免了多线程中频繁的数据共享和同步操作可能引发的缓存失效问题。</p></li><li><p>线程同步和锁竞争：在多线程模型中，由于涉及到多个线程对共享资源的访问和修改，需要进行线程同步和锁竞争，而单线程模型避免了这些问题。</p></li></ol><p>虽然单线程模型在某些情况下性能优于多线程模型，但是对于高并发、大规模的应用场景，多线程模型能够更好地利用多核CPU的性能，提高系统的并发处理能力。因此，选择合适的线程模型需要根据具体的应用场景和需求进行权衡和选择。</p><h2 id="15-Redis持久化机制：RDB和AOF"><a href="#15-Redis持久化机制：RDB和AOF" class="headerlink" title="15. Redis持久化机制：RDB和AOF"></a>15. Redis持久化机制：RDB和AOF</h2><p>Redis（远程字典服务器）是一种流行的内存数据库，它支持多种持久化机制来保证数据的安全性和可靠性。两种主要的持久化机制是RDB（Redis Database）和AOF（Append-Only File）。</p><ol><li><p><strong>RDB（Redis Database）</strong>：</p><ul><li>RDB 是 Redis 的一种快照持久化方式，它周期性地将 Redis 在内存中的数据以快照的形式保存到硬盘上的一个文件中。</li><li>生成 RDB 文件的时机可以通过配置文件中的保存条件来设置，比如在一定的时间间隔内或者在达到一定数量的写操作后。</li><li>由于 RDB 是将整个数据集保存到文件中，因此它的恢复速度比较快，适用于对数据一致性要求不是很高、需要定期备份或者迁移数据的场景。</li></ul></li><li><p><strong>AOF（Append-Only File）</strong>：</p><ul><li>AOF 是通过将 Redis 的写操作以追加的方式记录到一个文件中来实现持久化的机制。</li><li>AOF 文件记录了 Redis 服务器接收到的所有写命令，通过重放这些命令可以恢复数据。</li><li>AOF 文件的内容是可读的，因此在故障发生时可以比较容易地手动修复，但相对于 RDB，AOF 文件通常会更大一些。</li><li>AOF 提供了不同的同步选项，可以在性能和数据安全之间进行权衡，比如可以选择每个命令都同步到磁盘，或者每秒同步一次等。</li></ul></li></ol><p>在实际应用中，可以根据业务需求和对数据一致性、恢复速度等方面的要求选择适合的持久化机制，甚至可以同时使用 RDB 和 AOF 来提高数据的安全性。</p><h2 id="16-redis的过期键有哪些删除策略"><a href="#16-redis的过期键有哪些删除策略" class="headerlink" title="16. redis的过期键有哪些删除策略"></a>16. redis的过期键有哪些删除策略</h2><p>Redis 中有几种删除过期键的策略，它们分别是：</p><ol><li><p><strong>定期删除（定时任务）</strong>：<br>Redis 默认会每秒检查一定数量的过期键，然后删除其中已过期的键。这个数量可以通过配置文件中的 <code>hz</code> 参数进行设置，默认为 10。</p></li><li><p><strong>惰性删除</strong>：<br>当客户端尝试访问某个键时，Redis 会先检查该键是否过期，如果过期则会立即删除。这种方式称为惰性删除。</p></li><li><p><strong>定期删除 + 惰性删除结合</strong>：<br>定期删除和惰性删除可以结合使用，定期删除确保过期键不会一直占据内存，而惰性删除则保证了内存的及时回收。</p></li><li><p><strong>过期键删除策略配置</strong>：<br>在 Redis 的配置文件中，可以通过设置 <code>maxmemory-policy</code> 参数来调整过期键的删除策略。常见的策略包括：</p><ul><li><code>volatile-lru</code>：从已设置过期时间的键中挑选最近最少使用的键进行删除。</li><li><code>volatile-ttl</code>：从已设置过期时间的键中挑选即将过期的键进行删除。</li><li><code>volatile-random</code>：从已设置过期时间的键中随机选择键进行删除。</li><li><code>allkeys-lru</code>：从所有键中挑选最近最少使用的键进行删除，包括设置过期时间和未设置过期时间的键。</li><li><code>allkeys-random</code>：从所有键中随机选择键进行删除。</li><li><code>noeviction</code>：禁止删除任何键，当内存用完时，所有写操作都会返回错误。</li></ul></li></ol><p>通过选择合适的删除策略，可以根据实际需求来平衡内存使用和数据可用性。</p><h2 id="17-redis缓存如何回收"><a href="#17-redis缓存如何回收" class="headerlink" title="17. redis缓存如何回收"></a>17. redis缓存如何回收</h2><p>Redis 中的缓存回收通常是指对内存的回收，以确保 Redis 不会因为内存占用过高而导致性能下降或者服务不可用。主要的缓存回收方法包括：</p><ol><li><p><strong>内存淘汰策略</strong>：<br>Redis 提供了多种内存淘汰策略，用于在内存达到最大限制时选择要移除的键。常见的淘汰策略包括：</p><ul><li>LRU（最近最少使用）：移除最近最少使用的键。</li><li>LFU（最少频繁使用）：移除最少频繁使用的键。</li><li>TTL（过期时间）：移除最早过期的键。</li></ul></li><li><p><strong>设置内存最大限制</strong>：<br>可以在 Redis 配置文件中设置 <code>maxmemory</code> 参数，限制 Redis 实例使用的最大内存量。当达到这个限制时，Redis 将会根据配置的内存淘汰策略来回收内存。</p></li><li><p><strong>手动删除</strong>：<br>可以通过手动删除键来释放内存。当某些键不再需要缓存时，可以通过 <code>DEL</code> 命令删除这些键。</p></li><li><p><strong>持久化策略</strong>：<br>使用持久化机制（如 RDB 或 AOF）时，可以通过合理的设置持久化策略来控制数据的持久化频率，从而间接地控制内存的占用。</p></li><li><p><strong>过期键自动删除</strong>：<br>Redis 中的键可以设置过期时间，一旦过期时间到达，Redis 将自动删除这些键以释放内存空间。</p></li><li><p><strong>内存优化</strong>：<br>可以通过一些优化策略来减少 Redis 实例的内存占用，比如使用数据结构优化、压缩数据、分片数据等方式。</p></li></ol><p>综合利用这些方法，可以有效地管理 Redis 的内存使用，确保其在高性能的同时不会因为内存溢出而导致服务不可用。</p><h2 id="18-redis集群方案有哪些"><a href="#18-redis集群方案有哪些" class="headerlink" title="18. redis集群方案有哪些"></a>18. redis集群方案有哪些</h2><p>在搭建 Redis 集群时，有几种常见的方案：</p><ol><li><p><strong>Redis Sentinel</strong>：<br>Redis Sentinel 是 Redis 官方提供的高可用性解决方案，它可以监控 Redis 实例的健康状态，并在主节点宕机时自动将从节点提升为主节点，以保证系统的可用性。但是 Redis Sentinel 本身并不支持数据分片，只能用于高可用性方案。</p></li><li><p><strong>Redis Cluster</strong>：<br>Redis Cluster 是 Redis 官方提供的分布式方案，它将数据分片存储在多个节点上，并提供了自动数据分片和数据复制等功能，可以实现水平扩展和高可用性。Redis Cluster 在设计上遵循了主从复制、数据分片和节点互相通信等原则，提供了一套完整的分布式解决方案。</p></li><li><p><strong>第三方方案</strong>：<br>除了官方提供的解决方案之外，还有一些第三方工具和方案可以实现 Redis 的集群化，比如 Twemproxy、Codis 等。这些方案可能会提供一些额外的功能或者更加灵活的配置选项，但也可能会增加系统的复杂度和维护成本。</p></li></ol><p>在选择适合自己的 Redis 集群方案时，需要考虑到系统的需求、性能要求、高可用性要求以及团队的技术栈和维护成本等因素。</p><h2 id="19-redis事务是怎么实现的"><a href="#19-redis事务是怎么实现的" class="headerlink" title="19. redis事务是怎么实现的"></a>19. redis事务是怎么实现的</h2><p>Redis 的事务是通过 MULTI/EXEC 命令组合来实现的，具体过程如下：</p><ol><li><p><strong>MULTI 命令</strong>：<br>客户端发送 MULTI 命令给 Redis 服务器，表示开始一个事务。Redis 服务器收到 MULTI 命令后，会将当前客户端设置为事务状态，并将后续的命令都放入一个队列中，等待执行。</p></li><li><p><strong>命令入队</strong>：<br>在 MULTI 和 EXEC 之间的所有命令都会被放入事务队列中，而不是立即执行。这些命令不会立即改变数据库状态，而是暂时保存在队列中。</p></li><li><p><strong>命令执行</strong>：<br>客户端发送 EXEC 命令给 Redis 服务器，表示执行事务中的所有命令。Redis 服务器收到 EXEC 命令后，会按照命令入队的顺序，逐个执行事务队列中的命令。</p></li><li><p><strong>事务原子性</strong>：<br>在执行事务期间，Redis 会将这些命令作为一个整体进行执行，要么全部执行成功，要么全部执行失败。这保证了事务的原子性，即要么所有命令都成功执行，要么都不执行。</p></li><li><p><strong>执行结果返回</strong>：<br>执行事务队列中的命令后，Redis 会将每个命令的执行结果按照顺序返回给客户端。如果在执行事务过程中出现了错误，Redis 会返回一个错误给客户端，同时回滚之前已执行的命令。</p></li></ol><p>通过这种方式，Redis 的事务可以确保一系列命令的原子性执行，但需要注意的是，Redis 的事务并不支持回滚操作，因此在发生错误时，需要由客户端自行处理错误并进行补偿操作。</p><h2 id="20-redis-主从复制的原理"><a href="#20-redis-主从复制的原理" class="headerlink" title="20. redis 主从复制的原理"></a>20. redis 主从复制的原理</h2><p>Redis 主从复制是一种常用的高可用性和读写分离方案，它的原理如下：</p><ol><li><p><strong>建立连接</strong>：<br>首先，从节点（Slave）会向主节点（Master）发送一个 PSYNC 或 SYNC 命令，请求建立复制连接。</p></li><li><p><strong>同步数据</strong>：<br>一旦连接建立成功，主节点会将自己的数据发送给从节点，从节点会接收并保存这些数据。如果是首次进行复制，主节点会发送整个数据集；如果是增量复制，主节点会发送从上次复制点之后的数据变化。</p></li><li><p><strong>增量复制</strong>：<br>在初始同步完成后，主节点会继续将所有写命令发送给从节点，从节点会根据这些写命令来更新自己的数据集。这样，从节点就能保持和主节点一样的数据状态。</p></li><li><p><strong>持续连接和同步</strong>：<br>一旦复制建立，主从节点之间会维持一个持久的连接。主节点会持续地将写命令发送给从节点，确保从节点始终与主节点保持同步。</p></li><li><p><strong>主从切换</strong>：<br>当主节点宕机或者不可用时，可以手动或自动地将从节点提升为主节点，以保证系统的高可用性。在自动故障转移中，Redis Sentinel 或其他监控工具会监测主节点的状态，并在主节点不可用时自动将某个从节点升级为主节点。</p></li></ol><p>通过主从复制，Redis 实现了数据的备份和读写分离，提高了系统的可用性和性能。从节点可以处理读请求，分担主节点的压力，同时在主节点故障时可以快速接管，保证服务的连续性。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>verbal advantage level 1 41-50</title>
      <link href="/2024/04/07/verbal-advantage-level-1-41-50/"/>
      <url>/2024/04/07/verbal-advantage-level-1-41-50/</url>
      
        <content type="html"><![CDATA[<h1 id="word-41-50"><a href="#word-41-50" class="headerlink" title="word 41-50"></a>word 41-50</h1><h2 id="word-41-cantankerous-脾气坏的，爱争吵的"><a href="#word-41-cantankerous-脾气坏的，爱争吵的" class="headerlink" title="word 41: cantankerous 脾气坏的，爱争吵的"></a>word 41: <strong>cantankerous</strong> 脾气坏的，爱争吵的</h2><p>They are often obstinate and cantankerous, and as a result they are unwanted by their relations.</p><h2 id="word-42-flippant-轻率的，无礼的"><a href="#word-42-flippant-轻率的，无礼的" class="headerlink" title="word 42: flippant 轻率的，无礼的"></a>word 42: <strong>flippant</strong> 轻率的，无礼的</h2><p>He was very flippant in parts of his speech and completely callous in other parts of it.</p><h2 id="word-43-subjugate-征服，镇压"><a href="#word-43-subjugate-征服，镇压" class="headerlink" title="word 43: subjugate 征服，镇压"></a>word 43: <strong>subjugate</strong> 征服，镇压</h2><p>Nearly 1, 000 years have passed since we were conquered or subjugated by external force.</p><h2 id="word-44-wry-扭曲的，歪斜的"><a href="#word-44-wry-扭曲的，歪斜的" class="headerlink" title="word 44: wry 扭曲的，歪斜的"></a>word 44: <strong>wry</strong> 扭曲的，歪斜的</h2><p>It is characterized by a lot of wry humour, some of which had me spontaneously laughing aloud.</p><h2 id="word-45-urbane-温文尔雅的，彬彬有礼的"><a href="#word-45-urbane-温文尔雅的，彬彬有礼的" class="headerlink" title="word 45: urbane 温文尔雅的，彬彬有礼的"></a>word 45: <strong>urbane</strong> 温文尔雅的，彬彬有礼的</h2><p>Yet he proves to be far from the urbane wealthy gentleman they were expecting.</p><h2 id="word-46-jargon-行话，术语"><a href="#word-46-jargon-行话，术语" class="headerlink" title="word 46: jargon 行话，术语"></a>word 46: <strong>jargon</strong> 行话，术语</h2><p>To sum up, this book is very clearly written and presented throughout, and refreshingly free of jargon and conceptual obfuscation.</p><h2 id="word-47-prudent-谨慎的，节俭的"><a href="#word-47-prudent-谨慎的，节俭的" class="headerlink" title="word 47: prudent 谨慎的，节俭的"></a>word 47: <strong>prudent</strong> 谨慎的，节俭的</h2><p>In other words, democratic responsibility requires that policy decisions are clearly defensible as being prudent and in the public interest.</p><h2 id="word-48-inviolable-不可侵犯的，不可违返的"><a href="#word-48-inviolable-不可侵犯的，不可违返的" class="headerlink" title="word 48: inviolable 不可侵犯的，不可违返的"></a>word 48: <strong>inviolable</strong> 不可侵犯的，不可违返的</h2><p>The condition would be inviolable, because every candidate would have the property.</p><h2 id="word-49-commodious-宽敞的"><a href="#word-49-commodious-宽敞的" class="headerlink" title="word 49: commodious 宽敞的"></a>word 49: <strong>commodious</strong> 宽敞的</h2><p>More commodious quarters increased in cost.</p><h2 id="word-50-proximity-接近，附近"><a href="#word-50-proximity-接近，附近" class="headerlink" title="word 50: proximity 接近，附近"></a>word 50: <strong>proximity</strong> 接近，附近</h2><p>He visited rural villages and witnessed how the different groups lived in close proximity to one another.</p>]]></content>
      
      
      <categories>
          
          <category> VERBAL ADVANTAGE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1655 斯特灵数java</title>
      <link href="/2024/04/05/%E6%B4%9B%E8%B0%B7P1655-%E6%96%AF%E7%89%B9%E7%81%B5%E6%95%B0java/"/>
      <url>/2024/04/05/%E6%B4%9B%E8%B0%B7P1655-%E6%96%AF%E7%89%B9%E7%81%B5%E6%95%B0java/</url>
      
        <content type="html"><![CDATA[<h1 id="小朋友的球"><a href="#小朋友的球" class="headerlink" title="小朋友的球"></a>小朋友的球</h1><p><a href="https://www.luogu.com.cn/problem/P1655">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>@发源于 小朋友最近特别喜欢球。有一天他脑子抽了，从口袋里拿出了 $N$ 个不同的球，想把它们放到 $M$ 个相同的盒子里，并且要求每个盒子中至少要有一个球，他好奇有几种放法，于是尝试编程实现，但由于他天天不好好学习，只会上 B 站看游泳教练，于是他向你求助。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>多组数据，每行两个数 $N,M$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>每组数据一行，表示方案数。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>对于 $20\%$ 的数据，满足 $N,M \leq 10$；</li><li>对于 $100\%$ 的数据，满足 $1 \leq N,M \leq 100$，一个测试文件最多有 $10$ 组测试数据。</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%96%AF%E7%89%B9%E7%81%B5%E6%95%B0">斯特灵数</a></p><h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><p>因为实在不想写C++高精，或者说我已经不用写C++高精了，所以选择java或者python去解决问题更明智一些。<br>简单记录一下java中BigInteger的使用方法。<br><strong>在 Java 中，<code>BigInteger</code> 是不可变的类，这意味着一旦创建了一个 BigInteger 对象，它的值就不能被改变。</strong><br>BigInteger 类是 Java 中用来表示任意精度整数的类。由于它可以处理比 long 类型更大范围的整数，因此在需要处理大整数计算时非常有用。以下是一些 BigInteger 类的常见用法：</p><ol><li><p><strong>创建 BigInteger 对象</strong>：可以通过构造函数或静态工厂方法来创建 BigInteger 对象。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12345678901234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">num2</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">98765432109876543210L</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>常用方法</strong>：</p><ul><li>加法：<code>add(BigInteger val)</code></li><li>减法：<code>subtract(BigInteger val)</code></li><li>乘法：<code>multiply(BigInteger val)</code></li><li>除法：<code>divide(BigInteger val)</code></li><li>取余：<code>remainder(BigInteger val)</code></li><li>绝对值：<code>abs()</code></li><li>比较：<code>compareTo(BigInteger val)</code></li><li>转换为 long 类型：<code>longValue()</code></li><li>转换为字符串：<code>toString()</code></li></ul></li><li><p><strong>与原始数据类型的转换</strong>：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> num1.intValue();</span><br><span class="line"><span class="type">long</span> <span class="variable">longValue</span> <span class="operator">=</span> num1.longValue();</span><br><span class="line"><span class="type">double</span> <span class="variable">doubleValue</span> <span class="operator">=</span> num1.doubleValue();</span><br></pre></td></tr></table></figure></li><li><p><strong>比较两个 BigInteger</strong>：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (num1.compareTo(num2) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// num1 大于 num2</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1.compareTo(num2) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// num1 小于 num2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// num1 等于 num2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>BigInteger 的不可变性</strong>：BigInteger 对象的值是不可变的，因此任何数学运算都会产生一个新的 BigInteger 对象。所以，进行数学运算后，原始的 BigInteger 对象不会改变。</p></li><li><p><strong>BigInteger 的位运算</strong>：BigInteger 类也支持位运算方法，比如 <code>and()</code>、<code>or()</code>、<code>xor()</code> 和 <code>shiftLeft()</code>、<code>shiftRight()</code> 等方法。</p></li></ol><p>以上是一些常见的 BigInteger 类的用法，可以根据具体的需求选择合适的方法来操作 BigInteger 对象。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> BigInteger[][] S = <span class="keyword">new</span> <span class="title class_">BigInteger</span>[MAX][MAX];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initS</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;MAX;i++)&#123;</span><br><span class="line">            S[i][i]=BigInteger.ONE;</span><br><span class="line">            S[i][<span class="number">1</span>]=BigInteger.ONE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;j++)&#123;</span><br><span class="line">                S[i][j]=S[i-<span class="number">1</span>][j-<span class="number">1</span>].add(S[i-<span class="number">1</span>][j].multiply(BigInteger.valueOf(j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        initS();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNextInt())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(n&lt;m) System.out.println(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> System.out.println(S[n][m]);</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>verbal advantage level 1 21-40</title>
      <link href="/2024/04/05/verbal-advantage-level-1-21-40/"/>
      <url>/2024/04/05/verbal-advantage-level-1-21-40/</url>
      
        <content type="html"><![CDATA[<h1 id="word-21-30"><a href="#word-21-30" class="headerlink" title="word 21-30"></a>word 21-30</h1><h2 id="word-21-creed-信条，信仰"><a href="#word-21-creed-信条，信仰" class="headerlink" title="word 21: creed 信条，信仰"></a>word 21: <strong>creed</strong> 信条，信仰</h2><p>It takes in anybody regardless of religion, colour, or creed.</p><h2 id="word-22-tawdry-廉价而花哨的，俗艳的"><a href="#word-22-tawdry-廉价而花哨的，俗艳的" class="headerlink" title="word 22: tawdry 廉价而花哨的，俗艳的"></a>word 22: <strong>tawdry</strong> 廉价而花哨的，俗艳的</h2><p>A person may wear tawdry clothing or have a tawdry reputation.</p><h2 id="word-23-peevish-易怒的，坏脾气的"><a href="#word-23-peevish-易怒的，坏脾气的" class="headerlink" title="word 23: peevish 易怒的，坏脾气的"></a>word 23: <strong>peevish</strong> 易怒的，坏脾气的</h2><p>She glared down at me with a peevish expression on her face.</p><h2 id="word-24-arduous-费力的，艰难的"><a href="#word-24-arduous-费力的，艰难的" class="headerlink" title="word 24: arduous 费力的，艰难的"></a>word 24: <strong>arduous</strong> 费力的，艰难的</h2><p>We must have patience in doing arduous work.</p><h2 id="word-25-personable-英俊的，漂亮的，好看的"><a href="#word-25-personable-英俊的，漂亮的，好看的" class="headerlink" title="word 25: personable 英俊的，漂亮的，好看的"></a>word 25: <strong>personable</strong> 英俊的，漂亮的，好看的</h2><p>Jeremy excepted, the men seemed personable.</p><h2 id="word-26-resolute-坚决的，果断的"><a href="#word-26-resolute-坚决的，果断的" class="headerlink" title="word 26: resolute 坚决的，果断的"></a>word 26: <strong>resolute</strong> 坚决的，果断的</h2><p>Voters perceive him as a decisive and resolute international leader.</p><h2 id="word-27-supposition-假定，推测"><a href="#word-27-supposition-假定，推测" class="headerlink" title="word 27: supposition 假定，推测"></a>word 27: <strong>supposition</strong> 假定，推测</h2><p>The report is based entirely on supposition.</p><h2 id="word-28-arbitrary-武断的，主观的"><a href="#word-28-arbitrary-武断的，主观的" class="headerlink" title="word 28: arbitrary 武断的，主观的"></a>word 28: <strong>arbitrary</strong> 武断的，主观的</h2><p>He makes unpredictable, arbitrary decisions.</p><h2 id="word-29-monotonous-单调的，无变化的"><a href="#word-29-monotonous-单调的，无变化的" class="headerlink" title="word 29: monotonous 单调的，无变化的"></a>word 29: <strong>monotonous</strong> 单调的，无变化的</h2><p>It’s monotonous work, like most factory jobs.</p><h2 id="word-30-legacy-遗产，遗赠"><a href="#word-30-legacy-遗产，遗赠" class="headerlink" title="word 30: legacy 遗产，遗赠"></a>word 30: <strong>legacy</strong> 遗产，遗赠</h2><p>They each received a legacy of $5 000.</p><h1 id="word-31-40"><a href="#word-31-40" class="headerlink" title="word 31-40"></a>word 31-40</h1><h2 id="word-31：manifold-各种各样的，多方面的"><a href="#word-31：manifold-各种各样的，多方面的" class="headerlink" title="word 31：manifold 各种各样的，多方面的"></a>word 31：<strong>manifold</strong> 各种各样的，多方面的</h2><p>The possibilities were manifold.</p><h2 id="word-32-pliant-柔韧的，可塑的-能适应的，易受影响的"><a href="#word-32-pliant-柔韧的，可塑的-能适应的，易受影响的" class="headerlink" title="word 32: pliant 柔韧的，可塑的 / 能适应的，易受影响的"></a>word 32: <strong>pliant</strong> 柔韧的，可塑的 / 能适应的，易受影响的</h2><p>She lay pliant in his arms.</p><h2 id="word-33-retort-反驳，回嘴"><a href="#word-33-retort-反驳，回嘴" class="headerlink" title="word 33: retort 反驳，回嘴"></a>word 33: <strong>retort</strong> 反驳，回嘴</h2><p>His sharp retort clearly made an impact.</p><h2 id="word-34-obstinate-固执的，倔强的"><a href="#word-34-obstinate-固执的，倔强的" class="headerlink" title="word 34: obstinate 固执的，倔强的"></a>word 34: <strong>obstinate</strong> 固执的，倔强的</h2><p>He is obstinate and determined and will not give up.</p><h2 id="word-35-lacerate-撕裂，割破"><a href="#word-35-lacerate-撕裂，割破" class="headerlink" title="word 35: lacerate 撕裂，割破"></a>word 35: <strong>lacerate</strong> 撕裂，割破</h2><p>Her husband’s vicious retort lacerated her pride and made her burst into tears.</p><h2 id="word-36-omnipotent-全能的，有无限权力的"><a href="#word-36-omnipotent-全能的，有无限权力的" class="headerlink" title="word 36: omnipotent 全能的，有无限权力的"></a>word 36: <strong>omnipotent</strong> 全能的，有无限权力的</h2><p>Doug lived in the shadow of his seemingly omnipotent father.</p><h2 id="word-37-unscrupulous-不道德的，无耻的"><a href="#word-37-unscrupulous-不道德的，无耻的" class="headerlink" title="word 37: unscrupulous 不道德的，无耻的"></a>word 37: <strong>unscrupulous</strong> 不道德的，无耻的</h2><p>These kids are being exploited by very unscrupulous people.</p><h2 id="word-38-renaissance-复兴，再生"><a href="#word-38-renaissance-复兴，再生" class="headerlink" title="word 38: renaissance 复兴，再生"></a>word 38: <strong>renaissance</strong> 复兴，再生</h2><p>Popular art is experiencing a renaissance.</p><h2 id="word-39-genesis-开创，起源"><a href="#word-39-genesis-开创，起源" class="headerlink" title="word 39: genesis 开创，起源"></a>word 39: <strong>genesis</strong> 开创，起源</h2><p>It’s the story of Ziusudra, and it’s very similar to the Genesis flood story of Noah.</p><h2 id="word-40-warrant-成为……的依据，保证，担保"><a href="#word-40-warrant-成为……的依据，保证，担保" class="headerlink" title="word 40: warrant 成为……的依据，保证，担保"></a>word 40: <strong>warrant</strong> 成为……的依据，保证，担保</h2><p>There is no warrant for such criticism.</p>]]></content>
      
      
      <categories>
          
          <category> VERBAL ADVANTAGE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>verbal advantage level 1 1-20</title>
      <link href="/2024/04/03/verbal-advantage-level-1-1-20/"/>
      <url>/2024/04/03/verbal-advantage-level-1-1-20/</url>
      
        <content type="html"><![CDATA[<h1 id="word-1-10"><a href="#word-1-10" class="headerlink" title="word 1-10"></a>word 1-10</h1><h2 id="word-1-paraphrase-改写，重说"><a href="#word-1-paraphrase-改写，重说" class="headerlink" title="word 1: paraphrase 改写，重说"></a>word 1: <strong>paraphrase</strong> 改写，重说</h2><p>Try to paraphrase the question before you answer it.</p><h2 id="word-2-ostensible-表面的，假装的"><a href="#word-2-ostensible-表面的，假装的" class="headerlink" title="word 2: ostensible 表面的，假装的"></a>word 2: <strong>ostensible</strong> 表面的，假装的</h2><p>The ostensible reason for his absence was illness.</p><h2 id="word-3-digress-偏离，离题"><a href="#word-3-digress-偏离，离题" class="headerlink" title="word 3: digress 偏离，离题"></a>word 3: <strong>digress</strong> 偏离，离题</h2><p>His essay digress from the main subject.</p><h2 id="word-4-uncanny-神秘的，离奇的"><a href="#word-4-uncanny-神秘的，离奇的" class="headerlink" title="word 4: uncanny 神秘的，离奇的"></a>word 4: <strong>uncanny</strong> 神秘的，离奇的</h2><p>She bears an uncanny resemblance to Dido.</p><h2 id="word-5-candor-坦诚，直率"><a href="#word-5-candor-坦诚，直率" class="headerlink" title="word 5: candor 坦诚，直率"></a>word 5: <strong>candor</strong> 坦诚，直率</h2><p>I was surprised at his candor.</p><h2 id="word-6-morose-郁闷的，坏脾气的"><a href="#word-6-morose-郁闷的，坏脾气的" class="headerlink" title="word 6: morose 郁闷的，坏脾气的"></a>word 6: <strong>morose</strong> 郁闷的，坏脾气的</h2><p>After weeks of futile job-hunting, he became morose.</p><h2 id="word-7-adept-熟练的，擅长的"><a href="#word-7-adept-熟练的，擅长的" class="headerlink" title="word 7: adept 熟练的，擅长的"></a>word 7: <strong>adept</strong> 熟练的，擅长的</h2><p>As a composer he proved himself adept at large dramatic forms.</p><h2 id="word-8-saturated-饱和的，湿透的"><a href="#word-8-saturated-饱和的，湿透的" class="headerlink" title="word 8: saturated 饱和的，湿透的"></a>word 8: <strong>saturated</strong> 饱和的，湿透的</h2><p>The snack food market is largely saturated, and to grow.</p><h2 id="word-9-pragmatic-实际的，实用主义的"><a href="#word-9-pragmatic-实际的，实用主义的" class="headerlink" title="word 9: pragmatic 实际的，实用主义的"></a>word 9: <strong>pragmatic</strong> 实际的，实用主义的</h2><p>Robin took a pragmatic look at her situation.</p><h2 id="word-10-congenial-意气相投的，性格相似的"><a href="#word-10-congenial-意气相投的，性格相似的" class="headerlink" title="word 10: congenial 意气相投的，性格相似的"></a>word 10: <strong>congenial</strong> 意气相投的，性格相似的</h2><p>He is back in more congenial company.</p><h1 id="word-11-20"><a href="#word-11-20" class="headerlink" title="word 11-20"></a>word 11-20</h1><h2 id="word-11：capricious-善变的，任性的"><a href="#word-11：capricious-善变的，任性的" class="headerlink" title="word 11：capricious 善变的，任性的"></a>word 11：<strong>capricious</strong> 善变的，任性的</h2><p>He was accused of being capricious and undemocratic.</p><h2 id="word-12-blatant-喧嚣的，公然的"><a href="#word-12-blatant-喧嚣的，公然的" class="headerlink" title="word 12: blatant 喧嚣的，公然的"></a>word 12: <strong>blatant</strong> 喧嚣的，公然的</h2><p>It was a blatant lie.</p><h2 id="word-13-obligatory-必须的，要求的"><a href="#word-13-obligatory-必须的，要求的" class="headerlink" title="word 13: obligatory 必须的，要求的"></a>word 13: <strong>obligatory</strong> 必须的，要求的</h2><p>It is obligatory for all employees to wear protective clothing.</p><h2 id="word-14-negligible-微不足道的"><a href="#word-14-negligible-微不足道的" class="headerlink" title="word 14: negligible 微不足道的"></a>word 14: <strong>negligible</strong> 微不足道的</h2><p>The cost was negligible.</p><h2 id="word-15-adamant-坚定不移的，固执的"><a href="#word-15-adamant-坚定不移的，固执的" class="headerlink" title="word 15: adamant 坚定不移的，固执的"></a>word 15: <strong>adamant</strong> 坚定不移的，固执的</h2><p>Eva was adamant that she would not come.</p><h2 id="word-16-sporadic-零星的，分散的"><a href="#word-16-sporadic-零星的，分散的" class="headerlink" title="word 16: sporadic 零星的，分散的"></a>word 16: <strong>sporadic</strong> 零星的，分散的</h2><p>Her attendance in school was sporadic.</p><h2 id="word-17-vanguard-先锋，先驱"><a href="#word-17-vanguard-先锋，先驱" class="headerlink" title="word 17: vanguard 先锋，先驱"></a>word 17: <strong>vanguard</strong> 先锋，先驱</h2><p>Students and intellectuals have been in the vanguard of revolutionary change in China.</p><h2 id="word-18-concur-同意，一致"><a href="#word-18-concur-同意，一致" class="headerlink" title="word 18: concur 同意，一致"></a>word 18: <strong>concur</strong> 同意，一致</h2><p>Local feeling does not necessarily concur with the press.</p><h2 id="word-19-precociousness-早熟，提前成熟"><a href="#word-19-precociousness-早熟，提前成熟" class="headerlink" title="word 19: precociousness 早熟，提前成熟"></a>word 19: <strong>precociousness</strong> 早熟，提前成熟</h2><p>Precociousness in a child may be a sign of above-average intelligence.</p><h2 id="word-20-aloof-冷淡的，疏远的"><a href="#word-20-aloof-冷淡的，疏远的" class="headerlink" title="word 20: aloof 冷淡的，疏远的"></a>word 20: <strong>aloof</strong> 冷淡的，疏远的</h2><p>The Emperor kept himself aloof from the people.</p>]]></content>
      
      
      <categories>
          
          <category> VERBAL ADVANTAGE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google Docs导出pdf中文很难看，粗体不显示的问题</title>
      <link href="/2024/03/26/Google-Docs%E5%AF%BC%E5%87%BApdf%E4%B8%AD%E6%96%87%E5%BE%88%E9%9A%BE%E7%9C%8B%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/26/Google-Docs%E5%AF%BC%E5%87%BApdf%E4%B8%AD%E6%96%87%E5%BE%88%E9%9A%BE%E7%9C%8B%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Google-Docs-导出-pdf-中文很难看，粗体不显示的问题"><a href="#Google-Docs-导出-pdf-中文很难看，粗体不显示的问题" class="headerlink" title="Google Docs 导出 pdf 中文很难看，粗体不显示的问题"></a>Google Docs 导出 pdf 中文很难看，粗体不显示的问题</h1><p>最近在用 Google Docs 写简历，但是在导出 pdf 的时候发现中文字体并没有像编辑一样美观，变得非常扭曲和丑陋。而且粗体也没有显示。</p><h2 id="1-如何选择华文宋体"><a href="#1-如何选择华文宋体" class="headerlink" title="1. 如何选择华文宋体"></a>1. 如何选择华文宋体</h2><p>点击左上角<code>File</code>， <code>language</code>选项中选择<code>中文（中国）</code>就可以在字体栏看到华文宋体。<br><img src="/images/GoogleDocs/choseChinese.jpg" alt="chooseChinese"><br><img src="/images/GoogleDocs/song.jpg" alt="Fontsong"></p><h2 id="2-选择您的设备"><a href="#2-选择您的设备" class="headerlink" title="2. 选择您的设备"></a>2. 选择您的设备</h2><p><strong>一定一定要用电脑打开 Google Docs 网页版</strong>，实测 ipad（air 5）打开的网页里面并不能看见宋体字体选项，而且在预览打印里也不能正确渲染字体。</p><h2 id="3-预览打印"><a href="#3-预览打印" class="headerlink" title="3. 预览打印"></a>3. 预览打印</h2><p>点击左上角<code>File</code>，然后选择<code>Print</code>,会出现预览界面。<br><img src="/images/GoogleDocs/print.jpg" alt="Print"><br>然后点击保存，所见即所得。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li>使用电脑打开网页</li><li>语言选择中文</li><li>预览打印</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google Docs </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1789【Mc 生存】插火把</title>
      <link href="/2024/03/25/%E6%B4%9B%E8%B0%B7P1789/"/>
      <url>/2024/03/25/%E6%B4%9B%E8%B0%B7P1789/</url>
      
        <content type="html"><![CDATA[<h1 id="【Mc-生存】插火把"><a href="#【Mc-生存】插火把" class="headerlink" title="【Mc 生存】插火把"></a>【Mc 生存】插火把</h1><p><a href="https://www.luogu.com.cn/problem/P1789">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>话说有一天 linyorson 在“我的世界”开了一个 $n \times n$ 的方阵，现在他有 $m$ 个火把和 $k$ 个萤石，分别放在 $(x_1, y_1) \sim (x_m, y_m)$ 和 $(o_1, p_1) \sim (o_k, p_k)$ 的位置，没有光并且没放东西的地方会生成怪物。请问在这个方阵中有几个点会生成怪物？</p><p>P.S. 火把的照亮范围是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|暗|暗| 光 |暗|暗|</span><br><span class="line">|暗|光| 光 |光|暗|</span><br><span class="line">|光|光|火把|光|光|</span><br><span class="line">|暗|光| 光 |光|暗|</span><br><span class="line">|暗|暗| 光 |暗|暗|</span><br></pre></td></tr></table></figure><p>萤石：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|光|光| 光 |光|光|</span><br><span class="line">|光|光| 光 |光|光|</span><br><span class="line">|光|光|萤石|光|光|</span><br><span class="line">|光|光| 光 |光|光|</span><br><span class="line">|光|光| 光 |光|光|</span><br></pre></td></tr></table></figure><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入共 $m + k + 1$ 行。<br>第一行为 $n, m, k$。<br>第 $2$ 到第 $m + 1$ 行分别是火把的位置 $x_i, y_i$。<br>第 $m + 2$ 到第 $m + k + 1$ 行分别是萤石的位置 $o_i, p_i$。</p><p>注：可能没有萤石，但一定有火把。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>有几个点会生出怪物。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 1 0</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>数据保证，$1 \le n \le 100$，$1 \leq m+k \leq 25$，$1 \leq m \leq 25$，$0 \leq k \leq 5$。</p><hr><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="1-第一次尝试"><a href="#1-第一次尝试" class="headerlink" title="1. 第一次尝试"></a>1. 第一次尝试</h2><p>非常简单的模拟，只需要开一个 mcMap[][] 二维数组，记录哪里有火把哪里有石头就可以了。遍历一遍有火把或者石头就更新光亮。有光亮的就直接跳过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fire 2, stone 3, light 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(McMap[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (McMap[i][j] == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">fireLight</span>(i, j);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (McMap[i][j] == <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">stoneLight</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有四十分。。。<br><strong>很显然因为只有一个数组，在更新的时候会覆盖火把或者石头</strong></p><h2 id="2-第二次尝试"><a href="#2-第二次尝试" class="headerlink" title="2. 第二次尝试"></a>2. 第二次尝试</h2><p>既然只需要不被光亮覆盖，再开一个 flag[][]单独存储火把和石头的位置就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(McMap[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag[i][j] == <span class="number">2</span>)</span><br><span class="line">                <span class="built_in">fireLight</span>(i, j);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (flag[i][j] == <span class="number">3</span>)</span><br><span class="line">                <span class="built_in">stoneLight</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>还是只有四十分。。。<br>怎么回事！下载了错误的测试样例后发现了问题还是出在上面的二重循环中，本想着在有光亮的的地方就直接跳过剪枝了，没想到直接剪到大动脉上了，<code>if(McMap[i][j] == 1) continue;</code> ，因为火把或石头的位置可能被其他地方的光源照亮，如果直接跳过这个位置就会跳过更新光亮的 flag 判断语句，造成光亮更新失误。</p><h2 id="3-最后一次提交"><a href="#3-最后一次提交" class="headerlink" title="3. 最后一次提交"></a>3. 最后一次提交</h2><p>只需要删除那句话即可。<br>最后代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> mcMap[<span class="number">115</span>][<span class="number">115</span>];</span><br><span class="line"><span class="type">int</span> flag[<span class="number">115</span>][<span class="number">115</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fireLight</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mcMap[x][y] = <span class="number">1</span>;</span><br><span class="line">    mcMap[<span class="built_in">max</span>(<span class="number">1</span>, x - <span class="number">1</span>)][y] = <span class="number">1</span>;</span><br><span class="line">    mcMap[<span class="built_in">max</span>(<span class="number">1</span>, x - <span class="number">2</span>)][y] = <span class="number">1</span>;</span><br><span class="line">    mcMap[<span class="built_in">max</span>(<span class="number">1</span>, x - <span class="number">1</span>)][<span class="built_in">max</span>(<span class="number">1</span>, y - <span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">    mcMap[x][<span class="built_in">max</span>(<span class="number">1</span>, y - <span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">    mcMap[x][<span class="built_in">max</span>(<span class="number">1</span>, y - <span class="number">2</span>)] = <span class="number">1</span>;</span><br><span class="line">    mcMap[<span class="built_in">min</span>(n, x + <span class="number">1</span>)][y] = <span class="number">1</span>;</span><br><span class="line">    mcMap[<span class="built_in">min</span>(n, x + <span class="number">2</span>)][y] = <span class="number">1</span>;</span><br><span class="line">    mcMap[<span class="built_in">min</span>(n, x + <span class="number">1</span>)][<span class="built_in">max</span>(<span class="number">1</span>, y - <span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">    mcMap[x][<span class="built_in">min</span>(n, y + <span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">    mcMap[x][<span class="built_in">min</span>(n, y + <span class="number">2</span>)] = <span class="number">1</span>;</span><br><span class="line">    mcMap[<span class="built_in">max</span>(<span class="number">1</span>, x - <span class="number">1</span>)][<span class="built_in">min</span>(n, y + <span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">    mcMap[<span class="built_in">min</span>(n, x + <span class="number">1</span>)][<span class="built_in">min</span>(n, y + <span class="number">1</span>)] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stoneLight</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mcMap[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, x - <span class="number">2</span>); i &lt;= <span class="built_in">min</span>(n, x + <span class="number">2</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">max</span>(<span class="number">1</span>, y - <span class="number">2</span>); j &lt;= <span class="built_in">min</span>(n, y + <span class="number">2</span>); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            mcMap[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="comment">// fire 2, stone 3, light 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        flag[x][y] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        flag[x][y] = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[i][j] == <span class="number">2</span>)</span><br><span class="line">                <span class="built_in">fireLight</span>(i, j);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (flag[i][j] == <span class="number">3</span>)</span><br><span class="line">                <span class="built_in">stoneLight</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mcMap[i][j])</span><br><span class="line">                sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><del>能 AC 的代码就是好代码</del>。可以明显地看到我那个丑陋地 fireLight 函数，十二个位置直接暴力更新，实际上这是很容易犯错误地写法，如果写错了然后去找错误将是极大地麻烦。在 Github Copilot 地带领下很幸运我一次性写对了。正确地比较稳妥地方式是开<code>dx[]</code>和<code>dy[]</code>数组，将所有坐标一次性写出来，然后 for 循环去更新。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dx1[<span class="number">13</span>]=&#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">-2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">    dy1[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>对于数组越界问题解决方案</strong>：</p><ol><li>像我一样用 min，max 判断</li><li>直接把(3,3)当原点避免数组下标为负数</li><li>自定义函数判断是负数就返回零</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker learn</title>
      <link href="/2024/03/22/Docker-learn-1/"/>
      <url>/2024/03/22/Docker-learn-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-Learn-1"><a href="#Docker-Learn-1" class="headerlink" title="Docker Learn 1"></a>Docker Learn 1</h1><p>summary of <a href="https://www.docker.com/101-tutorial/">https://www.docker.com/101-tutorial/</a></p><h2 id="The-command-you-should-run"><a href="#The-command-you-should-run" class="headerlink" title="The command you should run"></a>The command you should run</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 docker/getting-started</span><br></pre></td></tr></table></figure><p>then Open your browser to <a href="http://localhost">http://localhost</a></p><h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><h2 id="Building-the-App’s-Container-Image"><a href="#Building-the-App’s-Container-Image" class="headerlink" title="Building the App’s Container Image"></a>Building the App’s Container Image</h2><ol><li>Create a Dockerfile</li><li>run command <code>docker build -t getting-started .</code> “-t” is to tag the image and “getting-started” is the name of the image. The “.” means to find Dockerfile in current directory.</li></ol><h2 id="Starting-an-App-Container"><a href="#Starting-an-App-Container" class="headerlink" title="Starting an App Container"></a>Starting an App Container</h2><ol><li>run <code>docker run -dp 3000:3000 getting-started</code> “-d” means “detached” mode. “-p” means creating a mapping between the host’s port 3000 to the container’s port 3000.</li></ol><h2 id="Updating-our-App"><a href="#Updating-our-App" class="headerlink" title="Updating our App"></a>Updating our App</h2><ol><li>if you have updated the source code, you need to build the updated version of the image.<br>run <code>docker build -t getting-started .</code></li><li>And have to start a new container using the updated code.<br>run <code>docker run -dp 3000:3000 getting-started</code>, then you will get an Error response.<del>(WT…F)</del></li></ol><h2 id="Replacing-our-Old-Container"><a href="#Replacing-our-Old-Container" class="headerlink" title="Replacing our Old Container"></a>Replacing our Old Container</h2><ol><li><code>docker ps</code> （find the old container ID）</li><li><code>docker stop &lt;the-container-id&gt;</code> （stop it！）</li><li><code>docker rm &lt;the-container-id&gt;</code> （delete it）</li><li>you can also use <code>docker rm -f &lt;the-container-id&gt;</code> to stop and delete the container in one command.</li></ol><h3 id="the-run-docker-run-dp-3000-3000-getting-started-again"><a href="#the-run-docker-run-dp-3000-3000-getting-started-again" class="headerlink" title="the run docker run -dp 3000:3000 getting-started again."></a>the run <code>docker run -dp 3000:3000 getting-started</code> again.</h3><h2 id="Sharing-our-App"><a href="#Sharing-our-App" class="headerlink" title="Sharing our App"></a>Sharing our App</h2><h3 id="Create-a-Repo"><a href="#Create-a-Repo" class="headerlink" title="Create a Repo"></a>Create a Repo</h3><ol><li>go to <a href="https://hub.docker.com/">https://hub.docker.com/</a> to create one.</li><li><p>Use the docker tag command to give the getting-started image a new name. Be sure to swap out YOUR-USER-NAME with your Docker ID.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag getting-started YOUR-USER-NAME/getting-started</span><br></pre></td></tr></table></figure></li><li><p>then push it. <code>docker push YOUR-USER-NAME/getting-started</code><br><strong>remember to login to Docker Desktop</strong></p></li><li>open <a href="https://labs.play-with-docker.com/">https://labs.play-with-docker.com/</a> ,<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 YOUR-USER-NAME/getting-started</span><br></pre></td></tr></table></figure></li></ol><h2 id="Container-Volumes"><a href="#Container-Volumes" class="headerlink" title="Container Volumes"></a>Container Volumes</h2><ol><li>create a volume<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create todo-db</span><br></pre></td></tr></table></figure></li><li>stop the to-do app<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker stop &lt;the-container-id&gt;</span><br></pre></td></tr></table></figure></li><li>start the to-do app with <code>-v</code> flag<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started</span><br></pre></td></tr></table></figure>then open <a href="http://localhost:3000/">http://localhost:3000/</a> again and add some values.</li><li>remove the container<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker rm -f &lt;container-id&gt;</span><br></pre></td></tr></table></figure></li><li>Start a new container and open the app.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started</span><br></pre></td></tr></table></figure>the items in list should still there.</li></ol><h2 id="Starting-a-Dev-Mode-Container"><a href="#Starting-a-Dev-Mode-Container" class="headerlink" title="Starting a Dev-Mode Container"></a>Starting a Dev-Mode Container</h2><ol><li>Make sure you don’t have any of your own <code>getting-started</code> containers running (only the tutorial itself should be running).</li><li>get in the path of ‘app’</li><li><p>use powershell.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 `</span><br><span class="line">   -w /app -v &quot;$(pwd):/app&quot; `</span><br><span class="line">   node:18-alpine `</span><br><span class="line">   sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;</span><br></pre></td></tr></table></figure><ul><li>-dp 3000:3000 - same as before. Run in detached (background) mode and create a port mapping</li><li>-w /app - sets the container’s present working directory where the command will run from</li><li>-v “$(pwd):/app” - bind mount (link) the host’s present getting-started/app directory to the container’s /app directory. Note: Docker requires absolute paths for binding mounts, so in this example we use pwd for printing the absolute path of the working directory, i.e. the app directory, instead of typing it manually</li><li>node:18-alpine - the image to use. Note that this is the base image for our app from the Dockerfile</li><li>sh -c “yarn install &amp;&amp; yarn run dev” - the command. We’re starting a shell using sh (alpine doesn’t have bash) and running yarn install to install all dependencies and then running yarn run dev. If we look in the package.json, we’ll see that the dev script is starting nodemon.<br>if you see some error message like this:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker: Error response from daemon: Ports are not available: exposing port TCP 0.0.0.0:3000 -&gt; 0.0.0.0:0: listen tcp 0.0.0.0:3000: bind: An attempt was made to access a socket in a way forbidden by its access permissions.</span><br></pre></td></tr></table></figure><p>please Open powershell with administrator rights，and restart winnat.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop winnat</span><br><span class="line">net start winnat</span><br></pre></td></tr></table></figure></li><li><p>build your new image using <code>docker build -t getting-started .</code><br>you properly may see an error.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=&gt; CANCELED [internal] load build context</span><br><span class="line">=&gt; =&gt; transferring context: 558B</span><br><span class="line">ERROR: failed to solve: Canceled: context canceled</span><br></pre></td></tr></table></figure><p>you need to create a <code>.dockerignore</code> file in the path of <code>app</code>,and add <code>node_modules/</code> in it.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Vscode 连不上服务器的问题</title>
      <link href="/2024/03/18/%E5%85%B3%E4%BA%8E-Vscode-%E8%BF%9E%E4%B8%8D%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/18/%E5%85%B3%E4%BA%8E-Vscode-%E8%BF%9E%E4%B8%8D%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="关于-Vscode-连不上服务器的问题"><a href="#关于-Vscode-连不上服务器的问题" class="headerlink" title="关于 Vscode 连不上服务器的问题"></a>关于 Vscode 连不上服务器的问题</h1><p>在网络中找了好多方法都不管用，具体问题是 XShell 能够通过 ssh 连接云服务器的，但是 vscode 一直连不上，会显示“连接的管道不存在”，我解决问题的方法是打开 ssh 的 config 所在的目录，具体是<code>C:\Users\user\.ssh</code>，里面有一个文件叫<code>known_hosts</code>，把里边的关于云服务器公网 ip 那一行删掉就行了。<br>具体原因应该是我更换过很多次服务器的系统，然后那边的这个信息重置了，但是 vscode 在使用第一次下载的东西连接，所以导致连接不上。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 备份 </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql更改角色权限并实现备份</title>
      <link href="/2024/03/18/mysql%E6%9B%B4%E6%94%B9%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%A4%87%E4%BB%BD/"/>
      <url>/2024/03/18/mysql%E6%9B%B4%E6%94%B9%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<p>接上一篇接着写如何更改角色权限并实现备份。<br>如果你在备份 mysql 时遇到这个报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump: Error: &#x27;Access denied; you need (at least one of) the PROCESS privilege(s) for this operation&#x27; when trying to dump tablespaces</span><br></pre></td></tr></table></figure><p>并且知道 mysql root 的密码，</p><ol><li><strong>登录 mysql root 账号</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><ol><li><strong>更改角色权限</strong>。这里的单引号不能删除，只需要把 user1 改成需要的用户名就行</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT PROCESS ON *.* TO &#x27;user1&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><ol><li><strong>备份数据库</strong>。这里需要退出 mysql 在根目录里执行。username 换成自己角色名，dbname 换成需要备份的数据库名称。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u username -p dbname &gt; backup.sql</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 备份 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重置 mysql root 密码</title>
      <link href="/2024/03/18/%E9%87%8D%E7%BD%AE-mysql-root-%E5%AF%86%E7%A0%81/"/>
      <url>/2024/03/18/%E9%87%8D%E7%BD%AE-mysql-root-%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="重置-mysql-root-密码"><a href="#重置-mysql-root-密码" class="headerlink" title="重置 mysql root 密码"></a>重置 mysql root 密码</h1><p>这可能是建站以来遇见的最大的一次困难了，因为建站的时候直接使用了宝塔然后一键部署，我今天突发奇想既然网站已经搭建好，我已经不需要宝塔了，然后就进行了宝塔的卸载。这就是噩梦的开始。<br>显然仅卸载宝塔对网站没有任何影响。但是之前我用到过宝塔的数据库备份功能，所以我打算重新去写数据库备份的脚本。就当我兴致冲冲去运行脚本的时候，mysql 就报错了，说我的角色权限不足，不能备份数据库里的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump: Error: &#x27;Access denied; you need (at least one of) the PROCESS privilege(s) for this operation&#x27; when trying to dump tablespaces</span><br></pre></td></tr></table></figure><hr><p>这里提到为什么我不知道 root 密码，因为一键部署的话他是会给你创一个新的角色然后去使用数据库，这就导致了他在给我数据库密码的时候只给了我这个角色的名称和密码，具体 root 的密码我在网上查说是面板里可以看，但是我这时候已经卸载了，而且这个面板只支持纯净系统里安装。</p><hr><p>回归正题，感谢 chatgpt。这次真的是幸运，因为网上搜的杂七杂八的，有的连 markdown 都不写，运行语句都连在一起，也不知道哪里应该替换成自己的，索性去问了 chatgpt，最开始我是怀疑它给出的方案的，因为里面的语句和我查到了别人博客里写的不太一样。但是最终还是成功了，所以我不敢保证我这里的方法对你们是否有用，起码思路应该是正确的。<br>这里提示以下我的系统是 ubuntu2204，mysql5.7。</p><hr><p>如果你忘记了 MySQL root 用户的密码，你可以通过以下步骤重置密码：</p><ol><li><p><strong>停止 MySQL 服务</strong>：首先，停止 MySQL 服务以确保没有活动的数据库连接。你可以使用以下命令停止 MySQL 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop mysql</span><br></pre></td></tr></table></figure><p>或者，如果你使用的是旧版本的 Ubuntu，可以使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql stop</span><br></pre></td></tr></table></figure></li><li><p><strong>启动 MySQL 服务，并跳过权限验证</strong>：使用以下命令启动 MySQL 服务，但跳过权限验证，这样你就可以在不知道密码的情况下登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysqld_safe --skip-grant-tables --skip-networking &amp;</span><br></pre></td></tr></table></figure></li><li><p><strong>登录到 MySQL 服务器</strong>：现在你可以使用以下命令登录到 MySQL 服务器，不需要密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root</span><br></pre></td></tr></table></figure></li><li><p><strong>重置密码</strong>：在 MySQL 命令行中，执行以下命令来重置 root 用户的密码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure><p>将 <code>&#39;new_password&#39;</code> 替换为你想要设置的新密码。</p></li><li><p><strong>退出 MySQL 并重新启动服务</strong>：退出 MySQL 命令行界面，并重新启动 MySQL 服务以使更改生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysql</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure></li></ol><p>现在，你应该可以使用新密码登录到 MySQL 服务器了。</p><hr><p><strong>值得一提的是，如果 mysql 卡死不能执行命令的时候，<code>ctrl+d</code> 可以强制退出 mysql 回到 linux</strong></p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 备份 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的开始</title>
      <link href="/2024/03/18/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
      <url>/2024/03/18/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="简单记录一下博客搭建过程"><a href="#简单记录一下博客搭建过程" class="headerlink" title="简单记录一下博客搭建过程"></a>简单记录一下博客搭建过程</h1><p>&nbsp;&nbsp;很早以前就有了搭建博客的想法，也有用过 react 写过博客前端页面，但是很快我就知道了这不是短时间工程。所以我去寻找现成的模板。<br>&nbsp;&nbsp;显然我需要一个服务器。我去搜了并且决定是阿里云服务器，因为大学生使用很长时间几乎是免费（<del>这不是广告</del>）。试错了很多，也跟着教程做了几个实验，基本是熟悉了服务器的操作。<br>&nbsp;&nbsp;虽然但是，我还是使用了 AWS（<del>也是白嫖</del>）。具体申请条件就请去官网看吧，毕竟时时都在变化。<br>&nbsp;&nbsp;总之我会继续完善这个博客的，毕竟现在的时间实在是太宝贵了。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 备份 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Pragmatic Programmer</title>
      <link href="/2024/03/18/The-Pragmatic-Programmer/"/>
      <url>/2024/03/18/The-Pragmatic-Programmer/</url>
      
        <content type="html"><![CDATA[<p>Programming is a craft. At its simplest, it comes down to getting a computer to do what you want it to do (or what your user wants it to do). As a programmer, you are part listener, part advisor, part interpreter, and part dictator.You try to capture elusive requirements and find a way of expressing them so that a mere machine can do them justice. You try to document your work so that others can understand it, and you try to engineer your work so that others can build on it. What’s more, you try to do all this against the relentless ticking of the project clock. You work small miracles every day.</p>]]></content>
      
      
      <categories>
          
          <category> 摘抄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POV of Oppenheimer</title>
      <link href="/2024/03/13/POV-of-Oppenheimer/"/>
      <url>/2024/03/13/POV-of-Oppenheimer/</url>
      
        <content type="html"><![CDATA[<h1 id="Oppenheimer-film"><a href="#Oppenheimer-film" class="headerlink" title="Oppenheimer (film)"></a>Oppenheimer (film)</h1><p>After watching the Oppenheimer, I can’t tell that what I am feeling. First of all, it must be clear that the conversation I will talk is not about any country, any government, any things in reality. What I will talk is just about the film.<br>&ensp;&ensp; Yes, the film is extremely good. The sound, the actors, the music. I found that some Oppenheimer’s personality is just the same as mine. We both pursue the high end technology, think about how to change the world. I don’t deny that I like the learning atmosphere abroad. But I can feel the responsibility on his shoulder is becoming heavier. Yes, succeed in technical field, too successful to explosion. Because of it, so many people died. They have the right to invent it, but no right to decide whether use it or not. There is no true or false. Just one way they have is just going down. Not everyone want to know the truth, but there’s someone known the truth. It’s completely the hell. Oppenheimer is smart, he really want to take all the responsibilities on his own. It’s unfair, but understandable.<br>&ensp;&ensp; However, we go to a movie for the art, not for solving the problem that even Oppenheimer can’t solve. Few things can be more exciting than build a town and some bombs by spending 2 billion dollars. At the end, let me criticism subtitle group. The translation is so bad that I even wonder if you just use the tools to translate instead of their stupid brain. ( Forgive my rudeness! )<br>&ensp;&ensp; PS: Cillian Murphy, I like him so much. I began to know him by watching the Peaky Blinders. Perfect actors!</p>]]></content>
      
      
      <categories>
          
          <category> 有感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
            <tag> 奥本海默 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
